/**
 * Glyph game object module.
 *
 * @author kidthales <kidthales@agogpixel.com>
 * @copyright 2021-present AgogPixel
 * @license {@link https://agogpixel.github.io/phaser3-glyph-plugin/LICENSE|MIT License}
 * @module
 */

declare const WEBGL_RENDERER: unknown;
declare const CANVAS_RENDERER: unknown;

import { Mask, Size, TextureCrop, Tint } from '@agogpixel/phaser3-ts-utils/mixins/gameobjects/components';

import { Font, GlyphLike, readGlyphsFromBuffer } from '../shared';
import { convertHexStringToBuffer } from '../shared';

import type {
  GlyphPluginGameObjectCanvasRenderer,
  GlyphPluginGameObjectConfig,
  GlyphPluginGameObjectWebGLRenderer
} from './glyph-plugin-gameobject';
import { GlyphPluginGameObject } from './glyph-plugin-gameobject';

/**
 * Glyph factory type.
 */
export type GlyphFactory = (
  ...args: ConstructorParameters<typeof Glyph> extends [unknown, ...infer R] ? R : never
) => Glyph;

/**
 * Glyph creator type.
 */
export type GlyphCreator = (config?: GlyphConfig, addToScene?: boolean) => Glyph;

/**
 * Glyph creator configuration.
 */
export interface GlyphConfig extends GlyphPluginGameObjectConfig {
  /**
   * Glyphlike data.
   */
  glyph?: GlyphLike;
}

/**
 * Glyph factory.
 * @param this Phaser GameObject factory.
 * @param args Glyph instantiation arguments.
 * @returns Glyph instance.
 * @internal
 */
export const glyphFactory: GlyphFactory = function glyphFactory(this: Phaser.GameObjects.GameObjectFactory, ...args) {
  return this.displayList.add(new Glyph(this.scene, ...args)) as Glyph;
};

/**
 * Glyph creator.
 * @param this Phaser GameObject creator.
 * @param config Glyph creator configuration.
 * @param addToScene Add this Game Object to the Scene after creating it? If set
 * this argument overrides the `add` property in the config object.
 * @returns Glyph instance.
 * @internal
 */
export const glyphCreator: GlyphCreator = function glyphCreator(
  this: Phaser.GameObjects.GameObjectCreator,
  config: GlyphConfig = {},
  addToScene?: boolean
) {
  const glyph = new Glyph(this.scene, 0, 0, config.glyph, config.font, config.forceSquareRatio, config.pluginKey);

  if (addToScene !== undefined) {
    config.add = addToScene;
  }

  Phaser.GameObjects.BuildGameObject(this.scene, glyph, config);

  return glyph;
};

/**
 * Glyphmap WebGL renderer.
 * @internal
 */
let renderWebGL: GlyphPluginGameObjectWebGLRenderer<Glyph> = Phaser.Utils.NOOP;

/**
 * Glyphmap canvas renderer.
 * @internal
 */
let renderCanvas: GlyphPluginGameObjectCanvasRenderer<Glyph> = Phaser.Utils.NOOP;

if (typeof WEBGL_RENDERER) {
  renderWebGL = (renderer, src, camera, parentMatrix) => {
    const pipeline = renderer.pipelines.set(src.pipeline, src) as Phaser.Renderer.WebGL.Pipelines.MultiPipeline;
    pipeline.batchSprite(src as never, camera, parentMatrix);
  };
}

if (typeof CANVAS_RENDERER) {
  renderCanvas = (renderer, src, camera, parentMatrix) => {
    renderer.batchSprite(src, src.frame, camera, parentMatrix);
  };
}

/**
 * Glyph Game Object.
 */
export class Glyph extends Mask(Size(TextureCrop(Tint(class extends GlyphPluginGameObject {})))) {
  /**
   * Read the first section of glyph texture key (hex string containing ch, fg, & bg data).
   * @param texture Texture generated by a glyph plugin.
   * @returns Hex string containing ch, fg, & bg data.
   */
  private static readMinimalGlyphString(texture: Phaser.Textures.Texture) {
    return texture.key.split(' ')[0] as `0x${string}`;
  }

  /**
   * Canvas renderer.
   * @protected
   * @internal
   */
  readonly renderCanvas = renderCanvas;

  /**
   * WebGL renderer.
   * @protected
   * @internal
   */
  readonly renderWebGL = renderWebGL;

  /**
   * Refresh glyph texture.
   * @returns Glyph instance for further chaining.
   * @protected
   */
  readonly refresh = () => {
    return this.setTexture(
      this.currentGlyphPlugin['getTextureFromBuffer'](
        convertHexStringToBuffer(Glyph.readMinimalGlyphString(this.texture)),
        this.currentFont,
        this.currentForceSquareRatio
      ).key
    ).setSizeToFrame(undefined);
  };

  /**
   * Internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.
   * @internal
   */
  protected _crop: Record<string, unknown>;

  /**
   * Get current glyph data with 'rgba' color format.
   */
  get glyph() {
    return readGlyphsFromBuffer(
      'rgba',
      convertHexStringToBuffer(Glyph.readMinimalGlyphString(this.texture))
    )[0] as GlyphLike;
  }

  /**
   * Set glyph data.
   * @see {@link Glyph.setGlyph}
   */
  set glyph(value: GlyphLike) {
    this.setGlyph(value);
  }

  /**
   * Instantiate glyph game object.
   * @param scene The Scene to which this Game Object belongs.
   * @param x (Default: 0) World X-coordinate.
   * @param y (Default: 0) World Y-coordinate.
   * @param glyph (Optional) Glyphlike data.
   * @param font (Optional) Font to use.
   * @param forceSquareRatio (Optional) Force square glyph frames/cells,
   * using the greater of width or height of the associated glyph plugin's
   * measurement character.
   * @param pluginKey (Optional) Glyph plugin key.
   */
  constructor(
    scene: Phaser.Scene,
    x = 0,
    y = 0,
    glyph: GlyphLike = [' ', '#0000'],
    font?: Font,
    forceSquareRatio?: boolean,
    pluginKey?: string
  ) {
    super(scene, 'Glyph', x, y, font, forceSquareRatio, pluginKey);

    this._crop = this['resetCropObject']();

    this.setGlyph(glyph).setPosition(x, y).setOriginFromFrame();
  }

  /**
   * Set glyph. Updates texture & size.
   * @param glyph Glyphlike data to use.
   * @returns Reference to glyph for further chaining.
   */
  setGlyph(glyph: GlyphLike) {
    return this.setTexture(
      this.currentGlyphPlugin.getTexture([glyph], this.currentFont, this.currentForceSquareRatio).key
    ).setSizeToFrame(undefined);
  }
}
