{"version":3,"file":"590.demos.bundle.js","mappings":";qIAMA,IAAIA,EAAiB,EAAQ,OACzBC,EAAQ,EAAQ,OAChBC,EAAa,EAAQ,OACrBC,EAAa,EAAQ,OACrBC,EAAe,EAAQ,OA0CvBC,EAAS,IAAIJ,EAAM,CAEnBK,QAASH,EAETI,OAAQ,CACJL,EAAWM,MACXN,EAAWO,UACXP,EAAWQ,MACXR,EAAWS,KACXT,EAAWU,GACXV,EAAWW,UACXX,EAAWY,KACXZ,EAAWa,OACXb,EAAWc,SACXd,EAAWe,aACXf,EAAWgB,KACXhB,EAAWiB,YACXjB,EAAWkB,KACXlB,EAAWmB,UACXnB,EAAWoB,QACXlB,GAGJmB,WAEA,SAAiBC,EAAOC,EAAGC,EAAGC,EAASC,GAEnCzB,EAAW0B,KAAKC,KAAMN,EAAO,UAU7BM,KAAKC,MAAQD,KAAKE,kBAalBF,KAAKG,MAAQ,IAAIjC,EAAe8B,MAEhCA,KAAKI,WAAWP,EAASC,GACzBE,KAAKK,YAAYV,EAAGC,GACpBI,KAAKM,iBACLN,KAAKO,qBACLP,KAAKQ,gBAITC,aAAc,WAEVT,KAAKN,MAAMgB,IAAIC,WAAWC,IAAIZ,OAIlCa,iBAAkB,WAEdb,KAAKN,MAAMgB,IAAIC,WAAWG,OAAOd,OAarCe,UAAW,SAAUC,EAAMC,GAEvBjB,KAAKG,MAAMe,OAAOF,EAAMC,IA+D5BE,KAAM,SAAUC,EAAKC,GAEjB,OAAOrB,KAAKG,MAAMgB,KAAKC,EAAKC,IA+DhCC,YAAa,SAAUF,EAAKC,GAExB,OAAOrB,KAAKG,MAAMmB,YAAYF,EAAKC,IA4BvCE,eAAgB,SAAUH,EAAKI,GAE3B,OAAOxB,KAAKG,MAAMoB,eAAeH,EAAKI,IAyB1CC,gBAAiB,SAAUL,EAAKM,GAE5B,OAAO1B,KAAKG,MAAMsB,gBAAgBL,EAAKM,IA8B3CC,MAAO,SAAUP,GAEb,OAAOpB,KAAKG,MAAMwB,MAAMP,IAgB5BQ,KAAM,WAEF,OAAO5B,KAAKG,MAAMyB,QAqBtBC,eAAgB,SAAUL,GAEtB,OAAOxB,KAAKG,MAAM0B,eAAeL,IAqBrCM,gBAAiB,SAAUJ,GAEvB,OAAO1B,KAAKG,MAAM2B,gBAAgBJ,IAsBtCK,YAAa,SAAUjC,GAEnB,OAAOE,KAAKG,MAAM4B,YAAYjC,IAWlCkC,OAAQ,WAEJ,OAAO5D,EAAW6D,OAAOjC,OAU7BkC,WAAY,WAERlC,KAAKG,MAAMgC,UAEXnC,KAAKG,WAAQiC,KAKrBC,EAAOC,QAAU/D,aC/bjB8D,EAAOC,QAPoB,SAAUC,EAAUC,EAAKC,EAAQC,GAExDD,EAAOE,gBAAgBH,GAEvBD,EAASK,YAAYJ,EAAKA,EAAI1C,MAAO2C,EAAQC,qBClBjD,IAAIG,EAAc,EAAQ,OACtBC,EAAe,EAAQ,OAIvBD,EAAc,EAAQ,OAKtBC,EAAe,EAAQ,OAG3BT,EAAOC,QAAU,CAEbO,YAAaA,EACbC,aAAcA,cCKlBT,EAAOC,QAPmB,SAAUC,EAAUC,EAAKC,EAAQC,GAEvDD,EAAOE,gBAAgBH,GAEvBA,EAAIO,SAASH,YAAYJ,EAAKC,EAAQC","sources":["webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/gameobjects/sprite/Sprite.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/gameobjects/sprite/SpriteCanvasRenderer.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/gameobjects/sprite/SpriteRender.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/gameobjects/sprite/SpriteWebGLRenderer.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AnimationState = require('../../animations/AnimationState');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar SpriteRender = require('./SpriteRender');\r\n\r\n/**\r\n * @classdesc\r\n * A Sprite Game Object.\r\n *\r\n * A Sprite Game Object is used for the display of both static and animated images in your game.\r\n * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled\r\n * and animated.\r\n *\r\n * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.\r\n * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation\r\n * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.\r\n *\r\n * @class Sprite\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.FX\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.TextureCrop\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n */\r\nvar Sprite = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.FX,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Size,\r\n        Components.TextureCrop,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        SpriteRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Sprite (scene, x, y, texture, frame)\r\n    {\r\n        GameObject.call(this, scene, 'Sprite');\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.GameObjects.Sprite#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        /**\r\n         * The Animation State component of this Sprite.\r\n         *\r\n         * This component provides features to apply animations to this Sprite.\r\n         * It is responsible for playing, loading, queuing animations for later playback,\r\n         * mixing between animations and setting the current animation frame to this Sprite.\r\n         *\r\n         * @name Phaser.GameObjects.Sprite#anims\r\n         * @type {Phaser.Animations.AnimationState}\r\n         * @since 3.0.0\r\n         */\r\n        this.anims = new AnimationState(this);\r\n\r\n        this.setTexture(texture, frame);\r\n        this.setPosition(x, y);\r\n        this.setSizeToFrame();\r\n        this.setOriginFromFrame();\r\n        this.initPipeline();\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    /**\r\n     * Update this Sprite's animations.\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#preUpdate\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    preUpdate: function (time, delta)\r\n    {\r\n        this.anims.update(time, delta);\r\n    },\r\n\r\n    /**\r\n     * Start playing the given animation on this Sprite.\r\n     *\r\n     * Animations in Phaser can either belong to the global Animation Manager, or specifically to this Sprite.\r\n     *\r\n     * The benefit of a global animation is that multiple Sprites can all play the same animation, without\r\n     * having to duplicate the data. You can just create it once and then play it on any Sprite.\r\n     *\r\n     * The following code shows how to create a global repeating animation. The animation will be created\r\n     * from all of the frames within the sprite sheet that was loaded with the key 'muybridge':\r\n     *\r\n     * ```javascript\r\n     * var config = {\r\n     *     key: 'run',\r\n     *     frames: 'muybridge',\r\n     *     frameRate: 15,\r\n     *     repeat: -1\r\n     * };\r\n     *\r\n     * //  This code should be run from within a Scene:\r\n     * this.anims.create(config);\r\n     * ```\r\n     *\r\n     * However, if you wish to create an animation that is unique to this Sprite, and this Sprite alone,\r\n     * you can call the `Animation.create` method instead. It accepts the exact same parameters as when\r\n     * creating a global animation, however the resulting data is kept locally in this Sprite.\r\n     *\r\n     * With the animation created, either globally or locally, you can now play it on this Sprite:\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y).play('run');\r\n     * ```\r\n     *\r\n     * Alternatively, if you wish to run it at a different frame rate, for example, you can pass a config\r\n     * object instead:\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y).play({ key: 'run', frameRate: 24 });\r\n     * ```\r\n     *\r\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\r\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\r\n     * search the global Animation Manager and look for it there.\r\n     *\r\n     * If you need a Sprite to be able to play both local and global animations, make sure they don't\r\n     * have conflicting keys.\r\n     *\r\n     * See the documentation for the `PlayAnimationConfig` config object for more details about this.\r\n     *\r\n     * Also, see the documentation in the Animation Manager for further details on creating animations.\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#play\r\n     * @fires Phaser.Animations.Events#ANIMATION_START\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\r\n     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    play: function (key, ignoreIfPlaying)\r\n    {\r\n        return this.anims.play(key, ignoreIfPlaying);\r\n    },\r\n\r\n    /**\r\n     * Start playing the given animation on this Sprite, in reverse.\r\n     *\r\n     * Animations in Phaser can either belong to the global Animation Manager, or specifically to this Sprite.\r\n     *\r\n     * The benefit of a global animation is that multiple Sprites can all play the same animation, without\r\n     * having to duplicate the data. You can just create it once and then play it on any Sprite.\r\n     *\r\n     * The following code shows how to create a global repeating animation. The animation will be created\r\n     * from all of the frames within the sprite sheet that was loaded with the key 'muybridge':\r\n     *\r\n     * ```javascript\r\n     * var config = {\r\n     *     key: 'run',\r\n     *     frames: 'muybridge',\r\n     *     frameRate: 15,\r\n     *     repeat: -1\r\n     * };\r\n     *\r\n     * //  This code should be run from within a Scene:\r\n     * this.anims.create(config);\r\n     * ```\r\n     *\r\n     * However, if you wish to create an animation that is unique to this Sprite, and this Sprite alone,\r\n     * you can call the `Animation.create` method instead. It accepts the exact same parameters as when\r\n     * creating a global animation, however the resulting data is kept locally in this Sprite.\r\n     *\r\n     * With the animation created, either globally or locally, you can now play it on this Sprite:\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y).playReverse('run');\r\n     * ```\r\n     *\r\n     * Alternatively, if you wish to run it at a different frame rate, for example, you can pass a config\r\n     * object instead:\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y).playReverse({ key: 'run', frameRate: 24 });\r\n     * ```\r\n     *\r\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\r\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\r\n     * search the global Animation Manager and look for it there.\r\n     *\r\n     * If you need a Sprite to be able to play both local and global animations, make sure they don't\r\n     * have conflicting keys.\r\n     *\r\n     * See the documentation for the `PlayAnimationConfig` config object for more details about this.\r\n     *\r\n     * Also, see the documentation in the Animation Manager for further details on creating animations.\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#playReverse\r\n     * @fires Phaser.Animations.Events#ANIMATION_START\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\r\n     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    playReverse: function (key, ignoreIfPlaying)\r\n    {\r\n        return this.anims.playReverse(key, ignoreIfPlaying);\r\n    },\r\n\r\n    /**\r\n     * Waits for the specified delay, in milliseconds, then starts playback of the given animation.\r\n     *\r\n     * If the animation _also_ has a delay value set in its config, it will be **added** to the delay given here.\r\n     *\r\n     * If an animation is already running and a new animation is given to this method, it will wait for\r\n     * the given delay before starting the new animation.\r\n     *\r\n     * If no animation is currently running, the given one begins after the delay.\r\n     *\r\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\r\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\r\n     * search the global Animation Manager and look for it there.\r\n     *\r\n     * Prior to Phaser 3.50 this method was called 'delayedPlay'.\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#playAfterDelay\r\n     * @fires Phaser.Animations.Events#ANIMATION_START\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\r\n     * @param {number} delay - The delay, in milliseconds, to wait before starting the animation playing.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    playAfterDelay: function (key, delay)\r\n    {\r\n        return this.anims.playAfterDelay(key, delay);\r\n    },\r\n\r\n    /**\r\n     * Waits for the current animation to complete the `repeatCount` number of repeat cycles, then starts playback\r\n     * of the given animation.\r\n     *\r\n     * You can use this to ensure there are no harsh jumps between two sets of animations, i.e. going from an\r\n     * idle animation to a walking animation, by making them blend smoothly into each other.\r\n     *\r\n     * If no animation is currently running, the given one will start immediately.\r\n     *\r\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\r\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\r\n     * search the global Animation Manager and look for it there.\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#playAfterRepeat\r\n     * @fires Phaser.Animations.Events#ANIMATION_START\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\r\n     * @param {number} [repeatCount=1] - How many times should the animation repeat before the next one starts?\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    playAfterRepeat: function (key, repeatCount)\r\n    {\r\n        return this.anims.playAfterRepeat(key, repeatCount);\r\n    },\r\n\r\n    /**\r\n     * Sets an animation, or an array of animations, to be played immediately after the current one completes or stops.\r\n     *\r\n     * The current animation must enter a 'completed' state for this to happen, i.e. finish all of its repeats, delays, etc,\r\n     * or have the `stop` method called directly on it.\r\n     *\r\n     * An animation set to repeat forever will never enter a completed state.\r\n     *\r\n     * You can chain a new animation at any point, including before the current one starts playing, during it,\r\n     * or when it ends (via its `animationcomplete` event).\r\n     *\r\n     * Chained animations are specific to a Game Object, meaning different Game Objects can have different chained\r\n     * animations without impacting the animation they're playing.\r\n     *\r\n     * Call this method with no arguments to reset all currently chained animations.\r\n     *\r\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\r\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\r\n     * search the global Animation Manager and look for it there.\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#chain\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig|string[]|Phaser.Animations.Animation[]|Phaser.Types.Animations.PlayAnimationConfig[])} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object, or an array of them.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    chain: function (key)\r\n    {\r\n        return this.anims.chain(key);\r\n    },\r\n\r\n    /**\r\n     * Immediately stops the current animation from playing and dispatches the `ANIMATION_STOP` events.\r\n     *\r\n     * If no animation is playing, no event will be dispatched.\r\n     *\r\n     * If there is another animation queued (via the `chain` method) then it will start playing immediately.\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#stop\r\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\r\n     * @since 3.50.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    stop: function ()\r\n    {\r\n        return this.anims.stop();\r\n    },\r\n\r\n    /**\r\n     * Stops the current animation from playing after the specified time delay, given in milliseconds.\r\n     *\r\n     * It then dispatches the `ANIMATION_STOP` event.\r\n     *\r\n     * If no animation is running, no events will be dispatched.\r\n     *\r\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\r\n     * when the current one stops.\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#stopAfterDelay\r\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} delay - The number of milliseconds to wait before stopping this animation.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    stopAfterDelay: function (delay)\r\n    {\r\n        return this.anims.stopAfterDelay(delay);\r\n    },\r\n\r\n    /**\r\n     * Stops the current animation from playing after the given number of repeats.\r\n     *\r\n     * It then dispatches the `ANIMATION_STOP` event.\r\n     *\r\n     * If no animation is running, no events will be dispatched.\r\n     *\r\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\r\n     * when the current one stops.\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#stopAfterRepeat\r\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [repeatCount=1] - How many times should the animation repeat before stopping?\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    stopAfterRepeat: function (repeatCount)\r\n    {\r\n        return this.anims.stopAfterRepeat(repeatCount);\r\n    },\r\n\r\n    /**\r\n     * Stops the current animation from playing when it next sets the given frame.\r\n     * If this frame doesn't exist within the animation it will not stop it from playing.\r\n     *\r\n     * It then dispatches the `ANIMATION_STOP` event.\r\n     *\r\n     * If no animation is running, no events will be dispatched.\r\n     *\r\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\r\n     * when the current one stops.\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#stopOnFrame\r\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Animations.AnimationFrame} frame - The frame to check before stopping this animation.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    stopOnFrame: function (frame)\r\n    {\r\n        return this.anims.stopOnFrame(frame);\r\n    },\r\n\r\n    /**\r\n     * Build a JSON representation of this Sprite.\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return Components.ToJSON(this);\r\n    },\r\n\r\n    /**\r\n     * Handles the pre-destroy step for the Sprite, which removes the Animation component.\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#preDestroy\r\n     * @private\r\n     * @since 3.14.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.anims.destroy();\r\n\r\n        this.anims = undefined;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Sprite;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Sprite#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Sprite} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar SpriteCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.batchSprite(src, src.frame, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = SpriteCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./SpriteWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./SpriteCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Sprite#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Sprite} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar SpriteWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    src.pipeline.batchSprite(src, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = SpriteWebGLRenderer;\r\n"],"names":["AnimationState","Class","Components","GameObject","SpriteRender","Sprite","Extends","Mixins","Alpha","BlendMode","Depth","Flip","FX","GetBounds","Mask","Origin","Pipeline","ScrollFactor","Size","TextureCrop","Tint","Transform","Visible","initialize","scene","x","y","texture","frame","call","this","_crop","resetCropObject","anims","setTexture","setPosition","setSizeToFrame","setOriginFromFrame","initPipeline","addedToScene","sys","updateList","add","removedFromScene","remove","preUpdate","time","delta","update","play","key","ignoreIfPlaying","playReverse","playAfterDelay","delay","playAfterRepeat","repeatCount","chain","stop","stopAfterDelay","stopAfterRepeat","stopOnFrame","toJSON","ToJSON","preDestroy","destroy","undefined","module","exports","renderer","src","camera","parentMatrix","addToRenderList","batchSprite","renderWebGL","renderCanvas","pipeline"],"sourceRoot":""}