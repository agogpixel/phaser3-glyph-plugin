{"version":3,"file":"911.demos.bundle.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/gameobjects/bitmaptext/ParseXMLBitmapFont.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/File.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/GetURL.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/LoaderPlugin.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/MergeXHRSettings.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/MultiFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/XHRLoader.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/XHRSettings.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/const.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/AnimationJSONFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/AsepriteFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/AtlasJSONFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/AtlasXMLFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/AudioFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/AudioSpriteFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/BinaryFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/BitmapFontFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/CSSFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/CompressedTextureFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/GLSLFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/HTML5AudioFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/HTMLFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/HTMLTextureFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/ImageFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/JSONFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/MultiAtlasFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/MultiScriptFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/OBJFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/PackFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/PluginFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/SVGFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/SceneFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/ScenePluginFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/ScriptFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/SpriteSheetFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/TextFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/TilemapCSVFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/TilemapImpactFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/TilemapJSONFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/UnityAtlasFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/VideoFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/XMLFile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/filetypes/index.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/loader/index.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/Formats.js"],"sourcesContent":["/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Read an integer value from an XML Node.\n *\n * @function getValue\n * @since 3.0.0\n * @private\n *\n * @param {Node} node - The XML Node.\n * @param {string} attribute - The attribute to read.\n *\n * @return {number} The parsed value.\n */\nfunction getValue (node, attribute)\n{\n    return parseInt(node.getAttribute(attribute), 10);\n}\n\n/**\n * Parse an XML font to Bitmap Font data for the Bitmap Font cache.\n *\n * @function ParseXMLBitmapFont\n * @since 3.0.0\n * @private\n *\n * @param {XMLDocument} xml - The XML Document to parse the font from.\n * @param {Phaser.Textures.Frame} frame - The texture frame to take into account when creating the uv data.\n * @param {number} [xSpacing=0] - The x-axis spacing to add between each letter.\n * @param {number} [ySpacing=0] - The y-axis spacing to add to the line height.\n * @param {Phaser.Textures.Texture} [texture] - If provided, each glyph in the Bitmap Font will be added to this texture as a frame.\n *\n * @return {Phaser.Types.GameObjects.BitmapText.BitmapFontData} The parsed Bitmap Font data.\n */\nvar ParseXMLBitmapFont = function (xml, frame, xSpacing, ySpacing, texture)\n{\n    if (xSpacing === undefined) { xSpacing = 0; }\n    if (ySpacing === undefined) { ySpacing = 0; }\n\n    var textureX = frame.cutX;\n    var textureY = frame.cutY;\n    var textureWidth = frame.source.width;\n    var textureHeight = frame.source.height;\n    var sourceIndex = frame.sourceIndex;\n\n    var data = {};\n    var info = xml.getElementsByTagName('info')[0];\n    var common = xml.getElementsByTagName('common')[0];\n\n    data.font = info.getAttribute('face');\n    data.size = getValue(info, 'size');\n    data.lineHeight = getValue(common, 'lineHeight') + ySpacing;\n    data.chars = {};\n\n    var letters = xml.getElementsByTagName('char');\n\n    var adjustForTrim = (frame !== undefined && frame.trimmed);\n\n    if (adjustForTrim)\n    {\n        var top = frame.height;\n        var left = frame.width;\n    }\n\n    for (var i = 0; i < letters.length; i++)\n    {\n        var node = letters[i];\n\n        var charCode = getValue(node, 'id');\n        var letter = String.fromCharCode(charCode);\n        var gx = getValue(node, 'x');\n        var gy = getValue(node, 'y');\n        var gw = getValue(node, 'width');\n        var gh = getValue(node, 'height');\n\n        //  Handle frame trim issues\n\n        if (adjustForTrim)\n        {\n            if (gx < left)\n            {\n                left = gx;\n            }\n\n            if (gy < top)\n            {\n                top = gy;\n            }\n        }\n\n        if (adjustForTrim && top !== 0 && left !== 0)\n        {\n            //  Now we know the top and left coordinates of the glyphs in the original data\n            //  so we can work out how much to adjust the glyphs by\n\n            gx -= frame.x;\n            gy -= frame.y;\n        }\n\n        var u0 = (textureX + gx) / textureWidth;\n        var v0 = (textureY + gy) / textureHeight;\n        var u1 = (textureX + gx + gw) / textureWidth;\n        var v1 = (textureY + gy + gh) / textureHeight;\n\n        data.chars[charCode] =\n        {\n            x: gx,\n            y: gy,\n            width: gw,\n            height: gh,\n            centerX: Math.floor(gw / 2),\n            centerY: Math.floor(gh / 2),\n            xOffset: getValue(node, 'xoffset'),\n            yOffset: getValue(node, 'yoffset'),\n            xAdvance: getValue(node, 'xadvance') + xSpacing,\n            data: {},\n            kerning: {},\n            u0: u0,\n            v0: v0,\n            u1: u1,\n            v1: v1\n        };\n\n        if (texture && gw !== 0 && gh !== 0)\n        {\n            var charFrame = texture.add(letter, sourceIndex, gx, gy, gw, gh);\n\n            if (charFrame)\n            {\n                charFrame.setUVs(gw, gh, u0, v0, u1, v1);\n            }\n        }\n    }\n\n    var kernings = xml.getElementsByTagName('kerning');\n\n    for (i = 0; i < kernings.length; i++)\n    {\n        var kern = kernings[i];\n\n        var first = getValue(kern, 'first');\n        var second = getValue(kern, 'second');\n        var amount = getValue(kern, 'amount');\n\n        data.chars[second].kerning[first] = amount;\n    }\n\n    return data;\n};\n\nmodule.exports = ParseXMLBitmapFont;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar Events = require('./events');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar GetURL = require('./GetURL');\r\nvar MergeXHRSettings = require('./MergeXHRSettings');\r\nvar XHRLoader = require('./XHRLoader');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * @classdesc\r\n * The base File class used by all File Types that the Loader can support.\r\n * You shouldn't create an instance of a File directly, but should extend it with your own class, setting a custom type and processing methods.\r\n *\r\n * @class File\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.\r\n * @param {Phaser.Types.Loader.FileConfig} fileConfig - The file configuration object, as created by the file type.\r\n */\r\nvar File = new Class({\r\n\r\n    initialize:\r\n\r\n    function File (loader, fileConfig)\r\n    {\r\n        /**\r\n         * A reference to the Loader that is going to load this file.\r\n         *\r\n         * @name Phaser.Loader.File#loader\r\n         * @type {Phaser.Loader.LoaderPlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.loader = loader;\r\n\r\n        /**\r\n         * A reference to the Cache, or Texture Manager, that is going to store this file if it loads.\r\n         *\r\n         * @name Phaser.Loader.File#cache\r\n         * @type {(Phaser.Cache.BaseCache|Phaser.Textures.TextureManager)}\r\n         * @since 3.7.0\r\n         */\r\n        this.cache = GetFastValue(fileConfig, 'cache', false);\r\n\r\n        /**\r\n         * The file type string (image, json, etc) for sorting within the Loader.\r\n         *\r\n         * @name Phaser.Loader.File#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = GetFastValue(fileConfig, 'type', false);\r\n\r\n        /**\r\n         * Unique cache key (unique within its file type)\r\n         *\r\n         * @name Phaser.Loader.File#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.key = GetFastValue(fileConfig, 'key', false);\r\n\r\n        var loadKey = this.key;\r\n\r\n        if (loader.prefix && loader.prefix !== '')\r\n        {\r\n            this.key = loader.prefix + loadKey;\r\n        }\r\n\r\n        if (!this.type || !this.key)\r\n        {\r\n            throw new Error('Invalid Loader.' + this.type + ' key');\r\n        }\r\n\r\n        var url = GetFastValue(fileConfig, 'url');\r\n\r\n        if (url === undefined)\r\n        {\r\n            url = loader.path + loadKey + '.' + GetFastValue(fileConfig, 'extension', '');\r\n        }\r\n        else if (typeof url === 'string' && !url.match(/^(?:blob:|data:|capacitor:\\/\\/|http:\\/\\/|https:\\/\\/|\\/\\/)/))\r\n        {\r\n            url = loader.path + url;\r\n        }\r\n\r\n        /**\r\n         * The URL of the file, not including baseURL.\r\n         *\r\n         * Automatically has Loader.path prepended to it if a string.\r\n         *\r\n         * Can also be a JavaScript Object, such as the results of parsing JSON data.\r\n         *\r\n         * @name Phaser.Loader.File#url\r\n         * @type {object|string}\r\n         * @since 3.0.0\r\n         */\r\n        this.url = url;\r\n\r\n        /**\r\n         * The final URL this file will load from, including baseURL and path.\r\n         * Set automatically when the Loader calls 'load' on this file.\r\n         *\r\n         * @name Phaser.Loader.File#src\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.src = '';\r\n\r\n        /**\r\n         * The merged XHRSettings for this file.\r\n         *\r\n         * @name Phaser.Loader.File#xhrSettings\r\n         * @type {Phaser.Types.Loader.XHRSettingsObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhrSettings = XHRSettings(GetFastValue(fileConfig, 'responseType', undefined));\r\n\r\n        if (GetFastValue(fileConfig, 'xhrSettings', false))\r\n        {\r\n            this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, 'xhrSettings', {}));\r\n        }\r\n\r\n        /**\r\n         * The XMLHttpRequest instance (as created by XHR Loader) that is loading this File.\r\n         *\r\n         * @name Phaser.Loader.File#xhrLoader\r\n         * @type {?XMLHttpRequest}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhrLoader = null;\r\n\r\n        /**\r\n         * The current state of the file. One of the FILE_CONST values.\r\n         *\r\n         * @name Phaser.Loader.File#state\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.state = (typeof(this.url) === 'function') ? CONST.FILE_POPULATED : CONST.FILE_PENDING;\r\n\r\n        /**\r\n         * The total size of this file.\r\n         * Set by onProgress and only if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#bytesTotal\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.bytesTotal = 0;\r\n\r\n        /**\r\n         * Updated as the file loads.\r\n         * Only set if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#bytesLoaded\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.bytesLoaded = -1;\r\n\r\n        /**\r\n         * A percentage value between 0 and 1 indicating how much of this file has loaded.\r\n         * Only set if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#percentComplete\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.percentComplete = -1;\r\n\r\n        /**\r\n         * For CORs based loading.\r\n         * If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)\r\n         *\r\n         * @name Phaser.Loader.File#crossOrigin\r\n         * @type {(string|undefined)}\r\n         * @since 3.0.0\r\n         */\r\n        this.crossOrigin = undefined;\r\n\r\n        /**\r\n         * The processed file data, stored here after the file has loaded.\r\n         *\r\n         * @name Phaser.Loader.File#data\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = undefined;\r\n\r\n        /**\r\n         * A config object that can be used by file types to store transitional data.\r\n         *\r\n         * @name Phaser.Loader.File#config\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = GetFastValue(fileConfig, 'config', {});\r\n\r\n        /**\r\n         * If this is a multipart file, i.e. an atlas and its json together, then this is a reference\r\n         * to the parent MultiFile. Set and used internally by the Loader or specific file types.\r\n         *\r\n         * @name Phaser.Loader.File#multiFile\r\n         * @type {?Phaser.Loader.MultiFile}\r\n         * @since 3.7.0\r\n         */\r\n        this.multiFile;\r\n\r\n        /**\r\n         * Does this file have an associated linked file? Such as an image and a normal map.\r\n         * Atlases and Bitmap Fonts use the multiFile, because those files need loading together but aren't\r\n         * actually bound by data, where-as a linkFile is.\r\n         *\r\n         * @name Phaser.Loader.File#linkFile\r\n         * @type {?Phaser.Loader.File}\r\n         * @since 3.7.0\r\n         */\r\n        this.linkFile;\r\n    },\r\n\r\n    /**\r\n     * Links this File with another, so they depend upon each other for loading and processing.\r\n     *\r\n     * @method Phaser.Loader.File#setLink\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} fileB - The file to link to this one.\r\n     */\r\n    setLink: function (fileB)\r\n    {\r\n        this.linkFile = fileB;\r\n\r\n        fileB.linkFile = this;\r\n    },\r\n\r\n    /**\r\n     * Resets the XHRLoader instance this file is using.\r\n     *\r\n     * @method Phaser.Loader.File#resetXHR\r\n     * @since 3.0.0\r\n     */\r\n    resetXHR: function ()\r\n    {\r\n        if (this.xhrLoader)\r\n        {\r\n            this.xhrLoader.onload = undefined;\r\n            this.xhrLoader.onerror = undefined;\r\n            this.xhrLoader.onprogress = undefined;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the Loader, starts the actual file downloading.\r\n     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.\r\n     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.\r\n     *\r\n     * @method Phaser.Loader.File#load\r\n     * @since 3.0.0\r\n     */\r\n    load: function ()\r\n    {\r\n        if (this.state === CONST.FILE_POPULATED)\r\n        {\r\n            //  Can happen for example in a JSONFile if they've provided a JSON object instead of a URL\r\n            this.loader.nextFile(this, true);\r\n        }\r\n        else\r\n        {\r\n            this.state = CONST.FILE_LOADING;\r\n\r\n            this.src = GetURL(this, this.loader.baseURL);\r\n\r\n            if (this.src.indexOf('data:') === 0)\r\n            {\r\n                console.warn('Local data URIs are not supported: ' + this.key);\r\n            }\r\n            else\r\n            {\r\n                //  The creation of this XHRLoader starts the load process going.\r\n                //  It will automatically call the following, based on the load outcome:\r\n                //\r\n                // xhr.onload = this.onLoad\r\n                // xhr.onerror = this.onError\r\n                // xhr.onprogress = this.onProgress\r\n\r\n                this.xhrLoader = XHRLoader(this, this.loader.xhr);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called when the file finishes loading, is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onLoad\r\n     * @since 3.0.0\r\n     *\r\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.\r\n     */\r\n    onLoad: function (xhr, event)\r\n    {\r\n        // On iOS, Capacitor often runs on a capacitor:// protocol, meaning local files are served from capacitor:// rather than file://\r\n        // See: https://github.com/photonstorm/phaser/issues/5685\r\n\r\n        var isLocalFile = xhr.responseURL && (xhr.responseURL.indexOf('file://') === 0 || xhr.responseURL.indexOf('capacitor://') === 0);\r\n\r\n        var localFileOk = (isLocalFile && event.target.status === 0);\r\n\r\n        var success = !(event.target && event.target.status !== 200) || localFileOk;\r\n\r\n        //  Handle HTTP status codes of 4xx and 5xx as errors, even if xhr.onerror was not called.\r\n        if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599)\r\n        {\r\n            success = false;\r\n        }\r\n\r\n        this.state = CONST.FILE_LOADED;\r\n\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, success);\r\n    },\r\n\r\n    /**\r\n     * Called if the file errors while loading, is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onError\r\n     * @since 3.0.0\r\n     *\r\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this error.\r\n     */\r\n    onError: function ()\r\n    {\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, false);\r\n    },\r\n\r\n    /**\r\n     * Called during the file load progress. Is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onProgress\r\n     * @fires Phaser.Loader.Events#FILE_PROGRESS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent.\r\n     */\r\n    onProgress: function (event)\r\n    {\r\n        if (event.lengthComputable)\r\n        {\r\n            this.bytesLoaded = event.loaded;\r\n            this.bytesTotal = event.total;\r\n\r\n            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);\r\n\r\n            this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Usually overridden by the FileTypes and is called by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data, for example a JSON file will parse itself during this stage.\r\n     *\r\n     * @method Phaser.Loader.File#onProcess\r\n     * @since 3.0.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Called when the File has completed processing.\r\n     * Checks on the state of its multifile, if set.\r\n     *\r\n     * @method Phaser.Loader.File#onProcessComplete\r\n     * @since 3.7.0\r\n     */\r\n    onProcessComplete: function ()\r\n    {\r\n        this.state = CONST.FILE_COMPLETE;\r\n\r\n        if (this.multiFile)\r\n        {\r\n            this.multiFile.onFileComplete(this);\r\n        }\r\n\r\n        this.loader.fileProcessComplete(this);\r\n    },\r\n\r\n    /**\r\n     * Called when the File has completed processing but it generated an error.\r\n     * Checks on the state of its multifile, if set.\r\n     *\r\n     * @method Phaser.Loader.File#onProcessError\r\n     * @since 3.7.0\r\n     */\r\n    onProcessError: function ()\r\n    {\r\n        // eslint-disable-next-line no-console\r\n        console.error('Failed to process file: %s \"%s\"', this.type, this.key);\r\n\r\n        this.state = CONST.FILE_ERRORED;\r\n\r\n        if (this.multiFile)\r\n        {\r\n            this.multiFile.onFileFailed(this);\r\n        }\r\n\r\n        this.loader.fileProcessComplete(this);\r\n    },\r\n\r\n    /**\r\n     * Checks if a key matching the one used by this file exists in the target Cache or not.\r\n     * This is called automatically by the LoaderPlugin to decide if the file can be safely\r\n     * loaded or will conflict.\r\n     *\r\n     * @method Phaser.Loader.File#hasCacheConflict\r\n     * @since 3.7.0\r\n     *\r\n     * @return {boolean} `true` if adding this file will cause a conflict, otherwise `false`.\r\n     */\r\n    hasCacheConflict: function ()\r\n    {\r\n        return (this.cache && this.cache.exists(this.key));\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     * This method is often overridden by specific file types.\r\n     *\r\n     * @method Phaser.Loader.File#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.cache)\r\n        {\r\n            this.cache.add(this.key, this.data);\r\n        }\r\n\r\n        this.pendingDestroy();\r\n    },\r\n\r\n    /**\r\n     * Called once the file has been added to its cache and is now ready for deletion from the Loader.\r\n     * It will emit a `filecomplete` event from the LoaderPlugin.\r\n     *\r\n     * @method Phaser.Loader.File#pendingDestroy\r\n     * @fires Phaser.Loader.Events#FILE_COMPLETE\r\n     * @fires Phaser.Loader.Events#FILE_KEY_COMPLETE\r\n     * @since 3.7.0\r\n     */\r\n    pendingDestroy: function (data)\r\n    {\r\n        if (data === undefined) { data = this.data; }\r\n\r\n        var key = this.key;\r\n        var type = this.type;\r\n\r\n        this.loader.emit(Events.FILE_COMPLETE, key, type, data);\r\n        this.loader.emit(Events.FILE_KEY_COMPLETE + type + '-' + key, key, type, data);\r\n\r\n        this.loader.flagForRemoval(this);\r\n    },\r\n\r\n    /**\r\n     * Destroy this File and any references it holds.\r\n     *\r\n     * @method Phaser.Loader.File#destroy\r\n     * @since 3.7.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.loader = null;\r\n        this.cache = null;\r\n        this.xhrSettings = null;\r\n        this.multiFile = null;\r\n        this.linkFile = null;\r\n        this.data = null;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Static method for creating object URL using URL API and setting it as image 'src' attribute.\r\n * If URL API is not supported (usually on old browsers) it falls back to creating Base64 encoded url using FileReader.\r\n *\r\n * @method Phaser.Loader.File.createObjectURL\r\n * @static\r\n * @since 3.7.0\r\n *\r\n * @param {HTMLImageElement} image - Image object which 'src' attribute should be set to object URL.\r\n * @param {Blob} blob - A Blob object to create an object URL for.\r\n * @param {string} defaultType - Default mime type used if blob type is not available.\r\n */\r\nFile.createObjectURL = function (image, blob, defaultType)\r\n{\r\n    if (typeof URL === 'function')\r\n    {\r\n        image.src = URL.createObjectURL(blob);\r\n    }\r\n    else\r\n    {\r\n        var reader = new FileReader();\r\n\r\n        reader.onload = function ()\r\n        {\r\n            image.removeAttribute('crossOrigin');\r\n            image.src = 'data:' + (blob.type || defaultType) + ';base64,' + reader.result.split(',')[1];\r\n        };\r\n\r\n        reader.onerror = image.onerror;\r\n\r\n        reader.readAsDataURL(blob);\r\n    }\r\n};\r\n\r\n/**\r\n * Static method for releasing an existing object URL which was previously created\r\n * by calling {@link File#createObjectURL} method.\r\n *\r\n * @method Phaser.Loader.File.revokeObjectURL\r\n * @static\r\n * @since 3.7.0\r\n *\r\n * @param {HTMLImageElement} image - Image object which 'src' attribute should be revoked.\r\n */\r\nFile.revokeObjectURL = function (image)\r\n{\r\n    if (typeof URL === 'function')\r\n    {\r\n        URL.revokeObjectURL(image.src);\r\n    }\r\n};\r\n\r\nmodule.exports = File;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Given a File and a baseURL value this returns the URL the File will use to download from.\r\n *\r\n * @function Phaser.Loader.GetURL\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.File} file - The File object.\r\n * @param {string} baseURL - A default base URL.\r\n *\r\n * @return {string} The URL the File will use.\r\n */\r\nvar GetURL = function (file, baseURL)\r\n{\r\n    if (!file.url)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (file.url.match(/^(?:blob:|data:|capacitor:\\/\\/|http:\\/\\/|https:\\/\\/|\\/\\/)/))\r\n    {\r\n        return file.url;\r\n    }\r\n    else\r\n    {\r\n        return baseURL + file.url;\r\n    }\r\n};\r\n\r\nmodule.exports = GetURL;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar CustomSet = require('../structs/Set');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar FileTypesManager = require('./FileTypesManager');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar SceneEvents = require('../scene/events');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * @classdesc\r\n * The Loader handles loading all external content such as Images, Sounds, Texture Atlases and data files.\r\n * You typically interact with it via `this.load` in your Scene. Scenes can have a `preload` method, which is always\r\n * called before the Scenes `create` method, allowing you to preload assets that the Scene may need.\r\n *\r\n * If you call any `this.load` methods from outside of `Scene.preload` then you need to start the Loader going\r\n * yourself by calling `Loader.start()`. It's only automatically started during the Scene preload.\r\n *\r\n * The Loader uses a combination of tag loading (eg. Audio elements) and XHR and provides progress and completion events.\r\n * Files are loaded in parallel by default. The amount of concurrent connections can be controlled in your Game Configuration.\r\n *\r\n * Once the Loader has started loading you are still able to add files to it. These can be injected as a result of a loader\r\n * event, the type of file being loaded (such as a pack file) or other external events. As long as the Loader hasn't finished\r\n * simply adding a new file to it, while running, will ensure it's added into the current queue.\r\n *\r\n * Every Scene has its own instance of the Loader and they are bound to the Scene in which they are created. However,\r\n * assets loaded by the Loader are placed into global game-level caches. For example, loading an XML file will place that\r\n * file inside `Game.cache.xml`, which is accessible from every Scene in your game, no matter who was responsible\r\n * for loading it. The same is true of Textures. A texture loaded in one Scene is instantly available to all other Scenes\r\n * in your game.\r\n *\r\n * The Loader works by using custom File Types. These are stored in the FileTypesManager, which injects them into the Loader\r\n * when it's instantiated. You can create your own custom file types by extending either the File or MultiFile classes.\r\n * See those files for more details.\r\n *\r\n * @class LoaderPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene which owns this Loader instance.\r\n */\r\nvar LoaderPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function LoaderPlugin (scene)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        var gameConfig = scene.sys.game.config;\r\n        var sceneConfig = scene.sys.settings.loader;\r\n\r\n        /**\r\n         * The Scene which owns this Loader instance.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A reference to the global Cache Manager.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#cacheManager\r\n         * @type {Phaser.Cache.CacheManager}\r\n         * @since 3.7.0\r\n         */\r\n        this.cacheManager = scene.sys.cache;\r\n\r\n        /**\r\n         * A reference to the global Texture Manager.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#textureManager\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.7.0\r\n         */\r\n        this.textureManager = scene.sys.textures;\r\n\r\n        /**\r\n         * A reference to the global Scene Manager.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#sceneManager\r\n         * @type {Phaser.Scenes.SceneManager}\r\n         * @protected\r\n         * @since 3.16.0\r\n         */\r\n        this.sceneManager = scene.sys.game.scene;\r\n\r\n        //  Inject the available filetypes into the Loader\r\n        FileTypesManager.install(this);\r\n\r\n        /**\r\n         * An optional prefix that is automatically prepended to the start of every file key.\r\n         * If prefix was `MENU.` and you load an image with the key 'Background' the resulting key would be `MENU.Background`.\r\n         * You can set this directly, or call `Loader.setPrefix()`. It will then affect every file added to the Loader\r\n         * from that point on. It does _not_ change any file already in the load queue.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#prefix\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.7.0\r\n         */\r\n        this.prefix = '';\r\n\r\n        /**\r\n         * The value of `path`, if set, is placed before any _relative_ file path given. For example:\r\n         *\r\n         * ```javascript\r\n         * this.load.path = \"images/sprites/\";\r\n         * this.load.image(\"ball\", \"ball.png\");\r\n         * this.load.image(\"tree\", \"level1/oaktree.png\");\r\n         * this.load.image(\"boom\", \"http://server.com/explode.png\");\r\n         * ```\r\n         *\r\n         * Would load the `ball` file from `images/sprites/ball.png` and the tree from\r\n         * `images/sprites/level1/oaktree.png` but the file `boom` would load from the URL\r\n         * given as it's an absolute URL.\r\n         *\r\n         * Please note that the path is added before the filename but *after* the baseURL (if set.)\r\n         *\r\n         * If you set this property directly then it _must_ end with a \"/\". Alternatively, call `setPath()` and it'll do it for you.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#path\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.path = '';\r\n\r\n        /**\r\n         * If you want to append a URL before the path of any asset you can set this here.\r\n         *\r\n         * Useful if allowing the asset base url to be configured outside of the game code.\r\n         *\r\n         * If you set this property directly then it _must_ end with a \"/\". Alternatively, call `setBaseURL()` and it'll do it for you.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#baseURL\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.baseURL = '';\r\n\r\n        this.setBaseURL(GetFastValue(sceneConfig, 'baseURL', gameConfig.loaderBaseURL));\r\n\r\n        this.setPath(GetFastValue(sceneConfig, 'path', gameConfig.loaderPath));\r\n\r\n        this.setPrefix(GetFastValue(sceneConfig, 'prefix', gameConfig.loaderPrefix));\r\n\r\n        /**\r\n         * The number of concurrent / parallel resources to try and fetch at once.\r\n         *\r\n         * Old browsers limit 6 requests per domain; modern ones, especially those with HTTP/2 don't limit it at all.\r\n         *\r\n         * The default is 32 but you can change this in your Game Config, or by changing this property before the Loader starts.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#maxParallelDownloads\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.maxParallelDownloads = GetFastValue(sceneConfig, 'maxParallelDownloads', gameConfig.loaderMaxParallelDownloads);\r\n\r\n        /**\r\n         * xhr specific global settings (can be overridden on a per-file basis)\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#xhr\r\n         * @type {Phaser.Types.Loader.XHRSettingsObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhr = XHRSettings(\r\n            GetFastValue(sceneConfig, 'responseType', gameConfig.loaderResponseType),\r\n            GetFastValue(sceneConfig, 'async', gameConfig.loaderAsync),\r\n            GetFastValue(sceneConfig, 'user', gameConfig.loaderUser),\r\n            GetFastValue(sceneConfig, 'password', gameConfig.loaderPassword),\r\n            GetFastValue(sceneConfig, 'timeout', gameConfig.loaderTimeout),\r\n            GetFastValue(sceneConfig, 'withCredentials', gameConfig.loaderWithCredentials)\r\n        );\r\n\r\n        /**\r\n         * The crossOrigin value applied to loaded images. Very often this needs to be set to 'anonymous'.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#crossOrigin\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.crossOrigin = GetFastValue(sceneConfig, 'crossOrigin', gameConfig.loaderCrossOrigin);\r\n\r\n        /**\r\n         * Optional load type for image files. `XHR` is the default. Set to `HTMLImageElement` to load images using the Image tag instead.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#imageLoadType\r\n         * @type {string}\r\n         * @since 3.60.0\r\n         */\r\n        this.imageLoadType = GetFastValue(sceneConfig, 'imageLoadType', gameConfig.loaderImageLoadType);\r\n\r\n        /**\r\n         * The total number of files to load. It may not always be accurate because you may add to the Loader during the process\r\n         * of loading, especially if you load a Pack File. Therefore this value can change, but in most cases remains static.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#totalToLoad\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.totalToLoad = 0;\r\n\r\n        /**\r\n         * The progress of the current load queue, as a float value between 0 and 1.\r\n         * This is updated automatically as files complete loading.\r\n         * Note that it is possible for this value to go down again if you add content to the current load queue during a load.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#progress\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.progress = 0;\r\n\r\n        /**\r\n         * Files are placed in this Set when they're added to the Loader via `addFile`.\r\n         *\r\n         * They are moved to the `inflight` Set when they start loading, and assuming a successful\r\n         * load, to the `queue` Set for further processing.\r\n         *\r\n         * By the end of the load process this Set will be empty.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#list\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @since 3.0.0\r\n         */\r\n        this.list = new CustomSet();\r\n\r\n        /**\r\n         * Files are stored in this Set while they're in the process of being loaded.\r\n         *\r\n         * Upon a successful load they are moved to the `queue` Set.\r\n         *\r\n         * By the end of the load process this Set will be empty.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#inflight\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @since 3.0.0\r\n         */\r\n        this.inflight = new CustomSet();\r\n\r\n        /**\r\n         * Files are stored in this Set while they're being processed.\r\n         *\r\n         * If the process is successful they are moved to their final destination, which could be\r\n         * a Cache or the Texture Manager.\r\n         *\r\n         * At the end of the load process this Set will be empty.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#queue\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @since 3.0.0\r\n         */\r\n        this.queue = new CustomSet();\r\n\r\n        /**\r\n         * A temporary Set in which files are stored after processing,\r\n         * awaiting destruction at the end of the load process.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#_deleteQueue\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @private\r\n         * @since 3.7.0\r\n         */\r\n        this._deleteQueue = new CustomSet();\r\n\r\n        /**\r\n         * The total number of files that failed to load during the most recent load.\r\n         * This value is reset when you call `Loader.start`.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#totalFailed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.7.0\r\n         */\r\n        this.totalFailed = 0;\r\n\r\n        /**\r\n         * The total number of files that successfully loaded during the most recent load.\r\n         * This value is reset when you call `Loader.start`.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#totalComplete\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.7.0\r\n         */\r\n        this.totalComplete = 0;\r\n\r\n        /**\r\n         * The current state of the Loader.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#state\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.state = CONST.LOADER_IDLE;\r\n\r\n        /**\r\n         * The current index being used by multi-file loaders to avoid key clashes.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#multiKeyIndex\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this.multiKeyIndex = 0;\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.pluginStart, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#pluginStart\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    pluginStart: function ()\r\n    {\r\n        this.systems.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * If you want to append a URL before the path of any asset you can set this here.\r\n     *\r\n     * Useful if allowing the asset base url to be configured outside of the game code.\r\n     *\r\n     * Once a base URL is set it will affect every file loaded by the Loader from that point on. It does _not_ change any\r\n     * file _already_ being loaded. To reset it, call this method with no arguments.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setBaseURL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [url] - The URL to use. Leave empty to reset.\r\n     *\r\n     * @return {this} This Loader object.\r\n     */\r\n    setBaseURL: function (url)\r\n    {\r\n        if (url === undefined) { url = ''; }\r\n\r\n        if (url !== '' && url.substr(-1) !== '/')\r\n        {\r\n            url = url.concat('/');\r\n        }\r\n\r\n        this.baseURL = url;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The value of `path`, if set, is placed before any _relative_ file path given. For example:\r\n     *\r\n     * ```javascript\r\n     * this.load.setPath(\"images/sprites/\");\r\n     * this.load.image(\"ball\", \"ball.png\");\r\n     * this.load.image(\"tree\", \"level1/oaktree.png\");\r\n     * this.load.image(\"boom\", \"http://server.com/explode.png\");\r\n     * ```\r\n     *\r\n     * Would load the `ball` file from `images/sprites/ball.png` and the tree from\r\n     * `images/sprites/level1/oaktree.png` but the file `boom` would load from the URL\r\n     * given as it's an absolute URL.\r\n     *\r\n     * Please note that the path is added before the filename but *after* the baseURL (if set.)\r\n     *\r\n     * Once a path is set it will then affect every file added to the Loader from that point on. It does _not_ change any\r\n     * file _already_ in the load queue. To reset it, call this method with no arguments.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setPath\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [path] - The path to use. Leave empty to reset.\r\n     *\r\n     * @return {this} This Loader object.\r\n     */\r\n    setPath: function (path)\r\n    {\r\n        if (path === undefined) { path = ''; }\r\n\r\n        if (path !== '' && path.substr(-1) !== '/')\r\n        {\r\n            path = path.concat('/');\r\n        }\r\n\r\n        this.path = path;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * An optional prefix that is automatically prepended to the start of every file key.\r\n     *\r\n     * If prefix was `MENU.` and you load an image with the key 'Background' the resulting key would be `MENU.Background`.\r\n     *\r\n     * Once a prefix is set it will then affect every file added to the Loader from that point on. It does _not_ change any\r\n     * file _already_ in the load queue. To reset it, call this method with no arguments.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setPrefix\r\n     * @since 3.7.0\r\n     *\r\n     * @param {string} [prefix] - The prefix to use. Leave empty to reset.\r\n     *\r\n     * @return {this} This Loader object.\r\n     */\r\n    setPrefix: function (prefix)\r\n    {\r\n        if (prefix === undefined) { prefix = ''; }\r\n\r\n        this.prefix = prefix;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Cross Origin Resource Sharing value used when loading files.\r\n     *\r\n     * Files can override this value on a per-file basis by specifying an alternative `crossOrigin` value in their file config.\r\n     *\r\n     * Once CORs is set it will then affect every file loaded by the Loader from that point on, as long as they don't have\r\n     * their own CORs setting. To reset it, call this method with no arguments.\r\n     *\r\n     * For more details about CORs see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setCORS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [crossOrigin] - The value to use for the `crossOrigin` property in the load request.\r\n     *\r\n     * @return {this} This Loader object.\r\n     */\r\n    setCORS: function (crossOrigin)\r\n    {\r\n        this.crossOrigin = crossOrigin;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a file, or array of files, into the load queue.\r\n     *\r\n     * The file must be an instance of `Phaser.Loader.File`, or a class that extends it. The Loader will check that the key\r\n     * used by the file won't conflict with any other key either in the loader, the inflight queue or the target cache.\r\n     * If allowed it will then add the file into the pending list, read for the load to start. Or, if the load has already\r\n     * started, ready for the next batch of files to be pulled from the list to the inflight queue.\r\n     *\r\n     * You should not normally call this method directly, but rather use one of the Loader methods like `image` or `atlas`,\r\n     * however you can call this as long as the file given to it is well formed.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#addFile\r\n     * @fires Phaser.Loader.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Loader.File|Phaser.Loader.File[])} file - The file, or array of files, to be added to the load queue.\r\n     */\r\n    addFile: function (file)\r\n    {\r\n        if (!Array.isArray(file))\r\n        {\r\n            file = [ file ];\r\n        }\r\n\r\n        for (var i = 0; i < file.length; i++)\r\n        {\r\n            var item = file[i];\r\n\r\n            //  Does the file already exist in the cache or texture manager?\r\n            //  Or will it conflict with a file already in the queue or inflight?\r\n            if (!this.keyExists(item))\r\n            {\r\n                this.list.set(item);\r\n\r\n                this.emit(Events.ADD, item.key, item.type, this, item);\r\n\r\n                if (this.isLoading())\r\n                {\r\n                    this.totalToLoad++;\r\n                    this.updateProgress();\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks the key and type of the given file to see if it will conflict with anything already\r\n     * in a Cache, the Texture Manager, or the list or inflight queues.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#keyExists\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The file to check the key of.\r\n     *\r\n     * @return {boolean} `true` if adding this file will cause a cache or queue conflict, otherwise `false`.\r\n     */\r\n    keyExists: function (file)\r\n    {\r\n        var keyConflict = file.hasCacheConflict();\r\n\r\n        if (!keyConflict)\r\n        {\r\n            this.list.iterate(function (item)\r\n            {\r\n                if (item.type === file.type && item.key === file.key)\r\n                {\r\n                    keyConflict = true;\r\n\r\n                    return false;\r\n                }\r\n\r\n            });\r\n        }\r\n\r\n        if (!keyConflict && this.isLoading())\r\n        {\r\n            this.inflight.iterate(function (item)\r\n            {\r\n                if (item.type === file.type && item.key === file.key)\r\n                {\r\n                    keyConflict = true;\r\n\r\n                    return false;\r\n                }\r\n\r\n            });\r\n\r\n            this.queue.iterate(function (item)\r\n            {\r\n                if (item.type === file.type && item.key === file.key)\r\n                {\r\n                    keyConflict = true;\r\n\r\n                    return false;\r\n                }\r\n\r\n            });\r\n        }\r\n\r\n        return keyConflict;\r\n    },\r\n\r\n    /**\r\n     * Takes a well formed, fully parsed pack file object and adds its entries into the load queue. Usually you do not call\r\n     * this method directly, but instead use `Loader.pack` and supply a path to a JSON file that holds the\r\n     * pack data. However, if you've got the data prepared you can pass it to this method.\r\n     *\r\n     * You can also provide an optional key. If you do then it will only add the entries from that part of the pack into\r\n     * to the load queue. If not specified it will add all entries it finds. For more details about the pack file format\r\n     * see the `LoaderPlugin.pack` method.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#addPack\r\n     * @since 3.7.0\r\n     *\r\n     * @param {any} pack - The Pack File data to be parsed and each entry of it to added to the load queue.\r\n     * @param {string} [packKey] - An optional key to use from the pack file data.\r\n     *\r\n     * @return {boolean} `true` if any files were added to the queue, otherwise `false`.\r\n     */\r\n    addPack: function (pack, packKey)\r\n    {\r\n        //  if no packKey provided we'll add everything to the queue\r\n        if (packKey && pack.hasOwnProperty(packKey))\r\n        {\r\n            pack = { packKey: pack[packKey] };\r\n        }\r\n\r\n        var total = 0;\r\n\r\n        //  Store the loader settings in case this pack replaces them\r\n        var currentBaseURL = this.baseURL;\r\n        var currentPath = this.path;\r\n        var currentPrefix = this.prefix;\r\n\r\n        //  Here we go ...\r\n        for (var key in pack)\r\n        {\r\n            if (!Object.prototype.hasOwnProperty.call(pack, key))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var config = pack[key];\r\n\r\n            //  Any meta data to process?\r\n            var baseURL = GetFastValue(config, 'baseURL', currentBaseURL);\r\n            var path = GetFastValue(config, 'path', currentPath);\r\n            var prefix = GetFastValue(config, 'prefix', currentPrefix);\r\n            var files = GetFastValue(config, 'files', null);\r\n            var defaultType = GetFastValue(config, 'defaultType', 'void');\r\n\r\n            if (Array.isArray(files))\r\n            {\r\n                this.setBaseURL(baseURL);\r\n                this.setPath(path);\r\n                this.setPrefix(prefix);\r\n\r\n                for (var i = 0; i < files.length; i++)\r\n                {\r\n                    var file = files[i];\r\n                    var type = (file.hasOwnProperty('type')) ? file.type : defaultType;\r\n\r\n                    if (this[type])\r\n                    {\r\n                        this[type](file);\r\n                        total++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //  Reset the loader settings\r\n        this.setBaseURL(currentBaseURL);\r\n        this.setPath(currentPath);\r\n        this.setPrefix(currentPrefix);\r\n\r\n        return (total > 0);\r\n    },\r\n\r\n    /**\r\n     * Is the Loader actively loading, or processing loaded files?\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#isLoading\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if the Loader is busy loading or processing, otherwise `false`.\r\n     */\r\n    isLoading: function ()\r\n    {\r\n        return (this.state === CONST.LOADER_LOADING || this.state === CONST.LOADER_PROCESSING);\r\n    },\r\n\r\n    /**\r\n     * Is the Loader ready to start a new load?\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#isReady\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if the Loader is ready to start a new load, otherwise `false`.\r\n     */\r\n    isReady: function ()\r\n    {\r\n        return (this.state === CONST.LOADER_IDLE || this.state === CONST.LOADER_COMPLETE);\r\n    },\r\n\r\n    /**\r\n     * Starts the Loader running. This will reset the progress and totals and then emit a `start` event.\r\n     * If there is nothing in the queue the Loader will immediately complete, otherwise it will start\r\n     * loading the first batch of files.\r\n     *\r\n     * The Loader is started automatically if the queue is populated within your Scenes `preload` method.\r\n     *\r\n     * However, outside of this, you need to call this method to start it.\r\n     *\r\n     * If the Loader is already running this method will simply return.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#start\r\n     * @fires Phaser.Loader.Events#START\r\n     * @since 3.0.0\r\n     */\r\n    start: function ()\r\n    {\r\n        if (!this.isReady())\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.progress = 0;\r\n\r\n        this.totalFailed = 0;\r\n        this.totalComplete = 0;\r\n        this.totalToLoad = this.list.size;\r\n\r\n        this.emit(Events.START, this);\r\n\r\n        if (this.list.size === 0)\r\n        {\r\n            this.loadComplete();\r\n        }\r\n        else\r\n        {\r\n            this.state = CONST.LOADER_LOADING;\r\n\r\n            this.inflight.clear();\r\n            this.queue.clear();\r\n\r\n            this.updateProgress();\r\n\r\n            this.checkLoadQueue();\r\n\r\n            this.systems.events.on(SceneEvents.UPDATE, this.update, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically during the load process.\r\n     * It updates the `progress` value and then emits a progress event, which you can use to\r\n     * display a loading bar in your game.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#updateProgress\r\n     * @fires Phaser.Loader.Events#PROGRESS\r\n     * @since 3.0.0\r\n     */\r\n    updateProgress: function ()\r\n    {\r\n        this.progress = 1 - ((this.list.size + this.inflight.size) / this.totalToLoad);\r\n\r\n        this.emit(Events.PROGRESS, this.progress);\r\n    },\r\n\r\n    /**\r\n     * Called automatically during the load process.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#update\r\n     * @since 3.10.0\r\n     */\r\n    update: function ()\r\n    {\r\n        if (this.state === CONST.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads)\r\n        {\r\n            this.checkLoadQueue();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * An internal method called by the Loader.\r\n     *\r\n     * It will check to see if there are any more files in the pending list that need loading, and if so it will move\r\n     * them from the list Set into the inflight Set, set their CORs flag and start them loading.\r\n     *\r\n     * It will carrying on doing this for each file in the pending list until it runs out, or hits the max allowed parallel downloads.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#checkLoadQueue\r\n     * @private\r\n     * @since 3.7.0\r\n     */\r\n    checkLoadQueue: function ()\r\n    {\r\n        this.list.each(function (file)\r\n        {\r\n            if (file.state === CONST.FILE_POPULATED || (file.state === CONST.FILE_PENDING && this.inflight.size < this.maxParallelDownloads))\r\n            {\r\n                this.inflight.set(file);\r\n\r\n                this.list.delete(file);\r\n\r\n                //  If the file doesn't have its own crossOrigin set, we'll use the Loaders (which is undefined by default)\r\n                if (!file.crossOrigin)\r\n                {\r\n                    file.crossOrigin = this.crossOrigin;\r\n                }\r\n\r\n                file.load();\r\n            }\r\n\r\n            if (this.inflight.size === this.maxParallelDownloads)\r\n            {\r\n                //  Tells the Set iterator to abort\r\n                return false;\r\n            }\r\n\r\n        }, this);\r\n    },\r\n\r\n    /**\r\n     * An internal method called automatically by the XHRLoader belong to a File.\r\n     *\r\n     * This method will remove the given file from the inflight Set and update the load progress.\r\n     * If the file was successful its `onProcess` method is called, otherwise it is added to the delete queue.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#nextFile\r\n     * @fires Phaser.Loader.Events#FILE_LOAD\r\n     * @fires Phaser.Loader.Events#FILE_LOAD_ERROR\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that just finished loading, or errored during load.\r\n     * @param {boolean} success - `true` if the file loaded successfully, otherwise `false`.\r\n     */\r\n    nextFile: function (file, success)\r\n    {\r\n        //  Has the game been destroyed during load? If so, bail out now.\r\n        if (!this.inflight)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.inflight.delete(file);\r\n\r\n        this.updateProgress();\r\n\r\n        if (success)\r\n        {\r\n            this.totalComplete++;\r\n\r\n            this.queue.set(file);\r\n\r\n            this.emit(Events.FILE_LOAD, file);\r\n\r\n            file.onProcess();\r\n        }\r\n        else\r\n        {\r\n            this.totalFailed++;\r\n\r\n            this._deleteQueue.set(file);\r\n\r\n            this.emit(Events.FILE_LOAD_ERROR, file);\r\n\r\n            this.fileProcessComplete(file);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * An internal method that is called automatically by the File when it has finished processing.\r\n     *\r\n     * If the process was successful, and the File isn't part of a MultiFile, its `addToCache` method is called.\r\n     *\r\n     * It this then removed from the queue. If there are no more files to load `loadComplete` is called.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#fileProcessComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The file that has finished processing.\r\n     */\r\n    fileProcessComplete: function (file)\r\n    {\r\n        //  Has the game been destroyed during load? If so, bail out now.\r\n        if (!this.scene || !this.systems || !this.systems.game || this.systems.game.pendingDestroy)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  This file has failed, so move it to the failed Set\r\n        if (file.state === CONST.FILE_ERRORED)\r\n        {\r\n            if (file.multiFile)\r\n            {\r\n                file.multiFile.onFileFailed(file);\r\n            }\r\n        }\r\n        else if (file.state === CONST.FILE_COMPLETE)\r\n        {\r\n            if (file.multiFile)\r\n            {\r\n                if (file.multiFile.isReadyToProcess())\r\n                {\r\n                    //  If we got here then all files the link file needs are ready to add to the cache\r\n                    file.multiFile.addToCache();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  If we got here, then the file processed, so let it add itself to its cache\r\n                file.addToCache();\r\n            }\r\n        }\r\n\r\n        //  Remove it from the queue\r\n        this.queue.delete(file);\r\n\r\n        //  Nothing left to do?\r\n\r\n        if (this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0)\r\n        {\r\n            this.loadComplete();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called at the end when the load queue is exhausted and all files have either loaded or errored.\r\n     * By this point every loaded file will now be in its associated cache and ready for use.\r\n     *\r\n     * Also clears down the Sets, puts progress to 1 and clears the deletion queue.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#loadComplete\r\n     * @fires Phaser.Loader.Events#COMPLETE\r\n     * @fires Phaser.Loader.Events#POST_PROCESS\r\n     * @since 3.7.0\r\n     */\r\n    loadComplete: function ()\r\n    {\r\n        this.emit(Events.POST_PROCESS, this);\r\n\r\n        this.list.clear();\r\n        this.inflight.clear();\r\n        this.queue.clear();\r\n\r\n        this.progress = 1;\r\n\r\n        this.state = CONST.LOADER_COMPLETE;\r\n\r\n        this.systems.events.off(SceneEvents.UPDATE, this.update, this);\r\n\r\n        //  Call 'destroy' on each file ready for deletion\r\n        this._deleteQueue.iterateLocal('destroy');\r\n\r\n        this._deleteQueue.clear();\r\n\r\n        this.emit(Events.COMPLETE, this, this.totalComplete, this.totalFailed);\r\n    },\r\n\r\n    /**\r\n     * Adds a File into the pending-deletion queue.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#flagForRemoval\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File to be queued for deletion when the Loader completes.\r\n     */\r\n    flagForRemoval: function (file)\r\n    {\r\n        this._deleteQueue.set(file);\r\n    },\r\n\r\n    /**\r\n     * Converts the given JSON data into a file that the browser then prompts you to download so you can save it locally.\r\n     *\r\n     * The data must be well formed JSON and ready-parsed, not a JavaScript object.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#saveJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} data - The JSON data, ready parsed.\r\n     * @param {string} [filename=file.json] - The name to save the JSON file as.\r\n     *\r\n     * @return {this} This Loader plugin.\r\n     */\r\n    saveJSON: function (data, filename)\r\n    {\r\n        return this.save(JSON.stringify(data), filename);\r\n    },\r\n\r\n    /**\r\n     * Causes the browser to save the given data as a file to its default Downloads folder.\r\n     *\r\n     * Creates a DOM level anchor link, assigns it as being a `download` anchor, sets the href\r\n     * to be an ObjectURL based on the given data, and then invokes a click event.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#save\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} data - The data to be saved. Will be passed through URL.createObjectURL.\r\n     * @param {string} [filename=file.json] - The filename to save the file as.\r\n     * @param {string} [filetype=application/json] - The file type to use when saving the file. Defaults to JSON.\r\n     *\r\n     * @return {this} This Loader plugin.\r\n     */\r\n    save: function (data, filename, filetype)\r\n    {\r\n        if (filename === undefined) { filename = 'file.json'; }\r\n        if (filetype === undefined) { filetype = 'application/json'; }\r\n\r\n        var blob = new Blob([ data ], { type: filetype });\r\n\r\n        var url = URL.createObjectURL(blob);\r\n\r\n        var a = document.createElement('a');\r\n\r\n        a.download = filename;\r\n        a.textContent = 'Download ' + filename;\r\n        a.href = url;\r\n        a.click();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets the Loader.\r\n     *\r\n     * This will clear all lists and reset the base URL, path and prefix.\r\n     *\r\n     * Warning: If the Loader is currently downloading files, or has files in its queue, they will be aborted.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#reset\r\n     * @since 3.0.0\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.list.clear();\r\n        this.inflight.clear();\r\n        this.queue.clear();\r\n\r\n        var gameConfig = this.systems.game.config;\r\n        var sceneConfig = this.systems.settings.loader;\r\n\r\n        this.setBaseURL(GetFastValue(sceneConfig, 'baseURL', gameConfig.loaderBaseURL));\r\n        this.setPath(GetFastValue(sceneConfig, 'path', gameConfig.loaderPath));\r\n        this.setPrefix(GetFastValue(sceneConfig, 'prefix', gameConfig.loaderPrefix));\r\n\r\n        this.state = CONST.LOADER_IDLE;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.reset();\r\n\r\n        this.state = CONST.LOADER_SHUTDOWN;\r\n\r\n        this.systems.events.off(SceneEvents.UPDATE, this.update, this);\r\n        this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.state = CONST.LOADER_DESTROYED;\r\n\r\n        this.systems.events.off(SceneEvents.UPDATE, this.update, this);\r\n        this.systems.events.off(SceneEvents.START, this.pluginStart, this);\r\n\r\n        this.list = null;\r\n        this.inflight = null;\r\n        this.queue = null;\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n        this.textureManager = null;\r\n        this.cacheManager = null;\r\n        this.sceneManager = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('Loader', LoaderPlugin, 'load');\r\n\r\nmodule.exports = LoaderPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Extend = require('../utils/object/Extend');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * Takes two XHRSettings Objects and creates a new XHRSettings object from them.\r\n *\r\n * The new object is seeded by the values given in the global settings, but any setting in\r\n * the local object overrides the global ones.\r\n *\r\n * @function Phaser.Loader.MergeXHRSettings\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} global - The global XHRSettings object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} local - The local XHRSettings object.\r\n *\r\n * @return {Phaser.Types.Loader.XHRSettingsObject} A newly formed XHRSettings object.\r\n */\r\nvar MergeXHRSettings = function (global, local)\r\n{\r\n    var output = (global === undefined) ? XHRSettings() : Extend({}, global);\r\n\r\n    if (local)\r\n    {\r\n        for (var setting in local)\r\n        {\r\n            if (local[setting] !== undefined)\r\n            {\r\n                output[setting] = local[setting];\r\n            }\r\n        }\r\n    }\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = MergeXHRSettings;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A MultiFile is a special kind of parent that contains two, or more, Files as children and looks after\r\n * the loading and processing of them all. It is commonly extended and used as a base class for file types such as AtlasJSON or BitmapFont.\r\n *\r\n * You shouldn't create an instance of a MultiFile directly, but should extend it with your own class, setting a custom type and processing methods.\r\n *\r\n * @class MultiFile\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.\r\n * @param {string} type - The file type string for sorting within the Loader.\r\n * @param {string} key - The key of the file within the loader.\r\n * @param {Phaser.Loader.File[]} files - An array of Files that make-up this MultiFile.\r\n */\r\nvar MultiFile = new Class({\r\n\r\n    initialize:\r\n\r\n    function MultiFile (loader, type, key, files)\r\n    {\r\n        var finalFiles = [];\r\n\r\n        //  Clean out any potential 'null' or 'undefined' file entries\r\n        files.forEach(function (file)\r\n        {\r\n            if (file)\r\n            {\r\n                finalFiles.push(file);\r\n            }\r\n        });\r\n\r\n        /**\r\n         * A reference to the Loader that is going to load this file.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#loader\r\n         * @type {Phaser.Loader.LoaderPlugin}\r\n         * @since 3.7.0\r\n         */\r\n        this.loader = loader;\r\n\r\n        /**\r\n         * The file type string for sorting within the Loader.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#type\r\n         * @type {string}\r\n         * @since 3.7.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * Unique cache key (unique within its file type)\r\n         *\r\n         * @name Phaser.Loader.MultiFile#key\r\n         * @type {string}\r\n         * @since 3.7.0\r\n         */\r\n        this.key = key;\r\n\r\n        /**\r\n         * The current index being used by multi-file loaders to avoid key clashes.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#multiKeyIndex\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this.multiKeyIndex = loader.multiKeyIndex++;\r\n\r\n        /**\r\n         * Array of files that make up this MultiFile.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#files\r\n         * @type {Phaser.Loader.File[]}\r\n         * @since 3.7.0\r\n         */\r\n        this.files = finalFiles;\r\n\r\n        /**\r\n         * The completion status of this MultiFile.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#complete\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.7.0\r\n         */\r\n        this.complete = false;\r\n\r\n        /**\r\n         * The number of files to load.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#pending\r\n         * @type {number}\r\n         * @since 3.7.0\r\n         */\r\n\r\n        this.pending = finalFiles.length;\r\n\r\n        /**\r\n         * The number of files that failed to load.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#failed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.7.0\r\n         */\r\n        this.failed = 0;\r\n\r\n        /**\r\n         * A storage container for transient data that the loading files need.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#config\r\n         * @type {any}\r\n         * @since 3.7.0\r\n         */\r\n        this.config = {};\r\n\r\n        /**\r\n         * A reference to the Loaders baseURL at the time this MultiFile was created.\r\n         * Used to populate child-files.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#baseURL\r\n         * @type {string}\r\n         * @since 3.20.0\r\n         */\r\n        this.baseURL = loader.baseURL;\r\n\r\n        /**\r\n         * A reference to the Loaders path at the time this MultiFile was created.\r\n         * Used to populate child-files.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#path\r\n         * @type {string}\r\n         * @since 3.20.0\r\n         */\r\n        this.path = loader.path;\r\n\r\n        /**\r\n         * A reference to the Loaders prefix at the time this MultiFile was created.\r\n         * Used to populate child-files.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#prefix\r\n         * @type {string}\r\n         * @since 3.20.0\r\n         */\r\n        this.prefix = loader.prefix;\r\n\r\n        //  Link the files\r\n        for (var i = 0; i < finalFiles.length; i++)\r\n        {\r\n            finalFiles[i].multiFile = this;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks if this MultiFile is ready to process its children or not.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#isReadyToProcess\r\n     * @since 3.7.0\r\n     *\r\n     * @return {boolean} `true` if all children of this MultiFile have loaded, otherwise `false`.\r\n     */\r\n    isReadyToProcess: function ()\r\n    {\r\n        return (this.pending === 0 && this.failed === 0 && !this.complete);\r\n    },\r\n\r\n    /**\r\n     * Adds another child to this MultiFile, increases the pending count and resets the completion status.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#addToMultiFile\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} files - The File to add to this MultiFile.\r\n     *\r\n     * @return {Phaser.Loader.MultiFile} This MultiFile instance.\r\n     */\r\n    addToMultiFile: function (file)\r\n    {\r\n        this.files.push(file);\r\n\r\n        file.multiFile = this;\r\n\r\n        this.pending++;\r\n\r\n        this.complete = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#onFileComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by each File that fails to load.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#onFileFailed\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has failed to load.\r\n     */\r\n    onFileFailed: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.failed++;\r\n\r\n            // eslint-disable-next-line no-console\r\n            console.error('File failed: %s \"%s\" (via %s \"%s\")', this.type, this.key, file.type, file.key);\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MultiFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MergeXHRSettings = require('./MergeXHRSettings');\r\n\r\n/**\r\n * Creates a new XMLHttpRequest (xhr) object based on the given File and XHRSettings\r\n * and starts the download of it. It uses the Files own XHRSettings and merges them\r\n * with the global XHRSettings object to set the xhr values before download.\r\n *\r\n * @function Phaser.Loader.XHRLoader\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.File} file - The File to download.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} globalXHRSettings - The global XHRSettings object.\r\n *\r\n * @return {XMLHttpRequest} The XHR object.\r\n */\r\nvar XHRLoader = function (file, globalXHRSettings)\r\n{\r\n    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);\r\n\r\n    var xhr = new XMLHttpRequest();\r\n\r\n    xhr.open('GET', file.src, config.async, config.user, config.password);\r\n\r\n    xhr.responseType = file.xhrSettings.responseType;\r\n    xhr.timeout = config.timeout;\r\n\r\n    if (config.headers)\r\n    {\r\n        for (var key in config.headers)\r\n        {\r\n            xhr.setRequestHeader(key, config.headers[key]);\r\n        }\r\n    }\r\n\r\n    if (config.header && config.headerValue)\r\n    {\r\n        xhr.setRequestHeader(config.header, config.headerValue);\r\n    }\r\n\r\n    if (config.requestedWith)\r\n    {\r\n        xhr.setRequestHeader('X-Requested-With', config.requestedWith);\r\n    }\r\n\r\n    if (config.overrideMimeType)\r\n    {\r\n        xhr.overrideMimeType(config.overrideMimeType);\r\n    }\r\n\r\n    if (config.withCredentials)\r\n    {\r\n        xhr.withCredentials = true;\r\n    }\r\n\r\n    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)\r\n\r\n    xhr.onload = file.onLoad.bind(file, xhr);\r\n    xhr.onerror = file.onError.bind(file, xhr);\r\n    xhr.onprogress = file.onProgress.bind(file);\r\n\r\n    //  This is the only standard method, the ones above are browser additions (maybe not universal?)\r\n    // xhr.onreadystatechange\r\n\r\n    xhr.send();\r\n\r\n    return xhr;\r\n};\r\n\r\nmodule.exports = XHRLoader;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Creates an XHRSettings Object with default values.\r\n *\r\n * @function Phaser.Loader.XHRSettings\r\n * @since 3.0.0\r\n *\r\n * @param {XMLHttpRequestResponseType} [responseType=''] - The responseType, such as 'text'.\r\n * @param {boolean} [async=true] - Should the XHR request use async or not?\r\n * @param {string} [user=''] - Optional username for the XHR request.\r\n * @param {string} [password=''] - Optional password for the XHR request.\r\n * @param {number} [timeout=0] - Optional XHR timeout value.\r\n * @param {boolean} [withCredentials=false] - Optional XHR withCredentials value.\r\n *\r\n * @return {Phaser.Types.Loader.XHRSettingsObject} The XHRSettings object as used by the Loader.\r\n */\r\nvar XHRSettings = function (responseType, async, user, password, timeout, withCredentials)\r\n{\r\n    if (responseType === undefined) { responseType = ''; }\r\n    if (async === undefined) { async = true; }\r\n    if (user === undefined) { user = ''; }\r\n    if (password === undefined) { password = ''; }\r\n    if (timeout === undefined) { timeout = 0; }\r\n    if (withCredentials === undefined) { withCredentials = false; }\r\n\r\n    // Before sending a request, set the xhr.responseType to \"text\",\r\n    // \"arraybuffer\", \"blob\", or \"document\", depending on your data needs.\r\n    // Note, setting xhr.responseType = '' (or omitting) will default the response to \"text\".\r\n\r\n    return {\r\n\r\n        //  Ignored by the Loader, only used by File.\r\n        responseType: responseType,\r\n\r\n        async: async,\r\n\r\n        //  credentials\r\n        user: user,\r\n        password: password,\r\n\r\n        //  timeout in ms (0 = no timeout)\r\n        timeout: timeout,\r\n\r\n        //  setRequestHeader\r\n        headers: undefined,\r\n        header: undefined,\r\n        headerValue: undefined,\r\n        requestedWith: false,\r\n\r\n        //  overrideMimeType\r\n        overrideMimeType: undefined,\r\n\r\n        //  withCredentials\r\n        withCredentials: withCredentials\r\n\r\n    };\r\n};\r\n\r\nmodule.exports = XHRSettings;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FILE_CONST = {\r\n\r\n    /**\r\n     * The Loader is idle.\r\n     * \r\n     * @name Phaser.Loader.LOADER_IDLE\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_IDLE: 0,\r\n\r\n    /**\r\n     * The Loader is actively loading.\r\n     * \r\n     * @name Phaser.Loader.LOADER_LOADING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_LOADING: 1,\r\n\r\n    /**\r\n     * The Loader is processing files is has loaded.\r\n     * \r\n     * @name Phaser.Loader.LOADER_PROCESSING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_PROCESSING: 2,\r\n\r\n    /**\r\n     * The Loader has completed loading and processing.\r\n     * \r\n     * @name Phaser.Loader.LOADER_COMPLETE\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_COMPLETE: 3,\r\n\r\n    /**\r\n     * The Loader is shutting down.\r\n     * \r\n     * @name Phaser.Loader.LOADER_SHUTDOWN\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_SHUTDOWN: 4,\r\n\r\n    /**\r\n     * The Loader has been destroyed.\r\n     * \r\n     * @name Phaser.Loader.LOADER_DESTROYED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_DESTROYED: 5,\r\n\r\n    /**\r\n     * File is in the load queue but not yet started\r\n     * \r\n     * @name Phaser.Loader.FILE_PENDING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_PENDING: 10,\r\n\r\n    /**\r\n     * File has been started to load by the loader (onLoad called)\r\n     * \r\n     * @name Phaser.Loader.FILE_LOADING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_LOADING: 11,\r\n\r\n    /**\r\n     * File has loaded successfully, awaiting processing    \r\n     * \r\n     * @name Phaser.Loader.FILE_LOADED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_LOADED: 12,\r\n\r\n    /**\r\n     * File failed to load\r\n     * \r\n     * @name Phaser.Loader.FILE_FAILED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_FAILED: 13,\r\n\r\n    /**\r\n     * File is being processed (onProcess callback)\r\n     * \r\n     * @name Phaser.Loader.FILE_PROCESSING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_PROCESSING: 14,\r\n\r\n    /**\r\n     * The File has errored somehow during processing.\r\n     * \r\n     * @name Phaser.Loader.FILE_ERRORED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_ERRORED: 16,\r\n\r\n    /**\r\n     * File has finished processing.\r\n     * \r\n     * @name Phaser.Loader.FILE_COMPLETE\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_COMPLETE: 17,\r\n\r\n    /**\r\n     * File has been destroyed\r\n     * \r\n     * @name Phaser.Loader.FILE_DESTROYED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_DESTROYED: 18,\r\n\r\n    /**\r\n     * File was populated from local data and doesn't need an HTTP request\r\n     * \r\n     * @name Phaser.Loader.FILE_POPULATED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_POPULATED: 19\r\n\r\n};\r\n\r\nmodule.exports = FILE_CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar LoaderEvents = require('../events');\r\n\r\n/**\r\n * @classdesc\r\n * A single Animation JSON File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#animation method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#animation.\r\n *\r\n * @class AnimationJSONFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n */\r\nvar AnimationJSONFile = new Class({\r\n\r\n    Extends: JSONFile,\r\n\r\n    initialize:\r\n\r\n    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object\r\n    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing\r\n\r\n    function AnimationJSONFile (loader, key, url, xhrSettings, dataKey)\r\n    {\r\n        JSONFile.call(this, loader, key, url, xhrSettings, dataKey);\r\n\r\n        this.type = 'animationJSON';\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AnimationJSONFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        //  We need to hook into this event:\r\n        this.loader.once(LoaderEvents.POST_PROCESS, this.onLoadComplete, this);\r\n\r\n        //  But the rest is the same as a normal JSON file\r\n        JSONFile.prototype.onProcess.call(this);\r\n    },\r\n\r\n    /**\r\n     * Called at the end of the load process, after the Loader has finished all files in its queue.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AnimationJSONFile#onLoadComplete\r\n     * @since 3.7.0\r\n     */\r\n    onLoadComplete: function ()\r\n    {\r\n        this.loader.systems.anims.fromJSON(this.data);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an Animation JSON Data file, or array of Animation JSON files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.animation('baddieAnims', 'files/BaddieAnims.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the JSON Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.animation({\r\n *     key: 'baddieAnims',\r\n *     url: 'files/BaddieAnims.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.JSONFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be passed to the global Animation Managers `fromJSON` method.\r\n * This will parse all of the JSON data and create animation data from it. This process happens at the very end\r\n * of the Loader, once every other file in the load queue has finished. The reason for this is to allow you to load\r\n * both animation data and the images it relies upon in the same load call.\r\n *\r\n * Once the animation data has been parsed you will be able to play animations using that data.\r\n * Please see the Animation Manager `fromJSON` method for more details about the format and playback.\r\n *\r\n * You can also access the raw animation data from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.animation('baddieAnims', 'files/BaddieAnims.json');\r\n * // and later in your game ...\r\n * var data = this.cache.json.get('baddieAnims');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the JSON Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,\r\n * rather than the whole file. For example, if your JSON data had a structure like this:\r\n *\r\n * ```json\r\n * {\r\n *     \"level1\": {\r\n *         \"baddies\": {\r\n *             \"aliens\": {},\r\n *             \"boss\": {}\r\n *         }\r\n *     },\r\n *     \"level2\": {},\r\n *     \"level3\": {}\r\n * }\r\n * ```\r\n *\r\n * And if you only wanted to create animations from the `boss` data, then you could pass `level1.baddies.boss`as the `dataKey`.\r\n *\r\n * Note: The ability to load this type of file will only be available if the JSON File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#animation\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig|Phaser.Types.Loader.FileTypes.JSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {string} [dataKey] - When the Animation JSON file loads only this property will be stored in the Cache and used to create animation data.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('animation', function (key, url, dataKey, xhrSettings)\r\n{\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            this.addFile(new AnimationJSONFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new AnimationJSONFile(this, key, url, xhrSettings, dataKey));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = AnimationJSONFile;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar FileTypesManager = require('../FileTypesManager');\nvar GetFastValue = require('../../utils/object/GetFastValue');\nvar ImageFile = require('./ImageFile.js');\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\nvar JSONFile = require('./JSONFile.js');\nvar MultiFile = require('../MultiFile.js');\n\n/**\n * @classdesc\n * A single JSON based Texture Atlas File suitable for loading by the Loader.\n *\n * These are created when you use the Phaser.Loader.LoaderPlugin#atlas method and are not typically created directly.\n *\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#atlas.\n *\n * https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-for-phaser3?source=photonstorm\n *\n * @class AsepriteFile\n * @extends Phaser.Loader.MultiFile\n * @memberof Phaser.Loader.FileTypes\n * @constructor\n * @since 3.50.0\n *\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\n * @param {(string|Phaser.Types.Loader.FileTypes.AsepriteFileConfig)} key - The key to use for this file, or a file configuration object.\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n * @param {object|string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\n */\nvar AsepriteFile = new Class({\n\n    Extends: MultiFile,\n\n    initialize:\n\n    function AsepriteFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\n    {\n        var image;\n        var data;\n\n        if (IsPlainObject(key))\n        {\n            var config = key;\n\n            key = GetFastValue(config, 'key');\n\n            image = new ImageFile(loader, {\n                key: key,\n                url: GetFastValue(config, 'textureURL'),\n                extension: GetFastValue(config, 'textureExtension', 'png'),\n                normalMap: GetFastValue(config, 'normalMap'),\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\n            });\n\n            data = new JSONFile(loader, {\n                key: key,\n                url: GetFastValue(config, 'atlasURL'),\n                extension: GetFastValue(config, 'atlasExtension', 'json'),\n                xhrSettings: GetFastValue(config, 'atlasXhrSettings')\n            });\n        }\n        else\n        {\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\n            data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);\n        }\n\n        if (image.linkFile)\n        {\n            //  Image has a normal map\n            MultiFile.call(this, loader, 'atlasjson', key, [ image, data, image.linkFile ]);\n        }\n        else\n        {\n            MultiFile.call(this, loader, 'atlasjson', key, [ image, data ]);\n        }\n    },\n\n    /**\n     * Adds this file to its target cache upon successful loading and processing.\n     *\n     * @method Phaser.Loader.FileTypes.AsepriteFile#addToCache\n     * @since 3.7.0\n     */\n    addToCache: function ()\n    {\n        if (this.isReadyToProcess())\n        {\n            var image = this.files[0];\n            var json = this.files[1];\n            var normalMap = (this.files[2]) ? this.files[2].data : null;\n\n            this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);\n\n            json.addToCache();\n\n            this.complete = true;\n        }\n    }\n\n});\n\n/**\n * Aseprite is a powerful animated sprite editor and pixel art tool.\n *\n * You can find more details at https://www.aseprite.org/\n *\n * Adds a JSON based Aseprite Animation, or array of animations, to the current load queue.\n *\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\n *\n * ```javascript\n * function preload ()\n * {\n *     this.load.aseprite('gladiator', 'images/Gladiator.png', 'images/Gladiator.json');\n * }\n * ```\n *\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\n * loaded.\n *\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\n *\n * To export a compatible JSON file in Aseprite, please do the following:\n *\n * 1. Go to \"File - Export Sprite Sheet\"\n *\n * 2. On the **Layout** tab:\n * 2a. Set the \"Sheet type\" to \"Packed\"\n * 2b. Set the \"Constraints\" to \"None\"\n * 2c. Check the \"Merge Duplicates\" checkbox\n *\n * 3. On the **Sprite** tab:\n * 3a. Set \"Layers\" to \"Visible layers\"\n * 3b. Set \"Frames\" to \"All frames\", unless you only wish to export a sub-set of tags\n *\n * 4. On the **Borders** tab:\n * 4a. Check the \"Trim Sprite\" and \"Trim Cells\" options\n * 4b. Ensure \"Border Padding\", \"Spacing\" and \"Inner Padding\" are all > 0 (1 is usually enough)\n *\n * 5. On the **Output** tab:\n * 5a. Check \"Output File\", give your image a name and make sure you choose \"png files\" as the file type\n * 5b. Check \"JSON Data\" and give your json file a name\n * 5c. The JSON Data type can be either a Hash or Array, Phaser doesn't mind.\n * 5d. Make sure \"Tags\" is checked in the Meta options\n * 5e. In the \"Item Filename\" input box, make sure it says just \"{frame}\" and nothing more.\n *\n * 6. Click export\n *\n * This was tested with Aseprite 1.2.25.\n *\n * This will export a png and json file which you can load using the Aseprite Loader, i.e.:\n *\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\n *\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\n * then remove it from the Texture Manager first, before loading a new one.\n *\n * Instead of passing arguments you can pass a configuration object, such as:\n *\n * ```javascript\n * this.load.aseprite({\n *     key: 'gladiator',\n *     textureURL: 'images/Gladiator.png',\n *     atlasURL: 'images/Gladiator.json'\n * });\n * ```\n *\n * See the documentation for `Phaser.Types.Loader.FileTypes.AsepriteFileConfig` for more details.\n *\n * Instead of passing a URL for the JSON data you can also pass in a well formed JSON object instead.\n *\n * Once loaded, you can call this method from within a Scene with the 'atlas' key:\n *\n * ```javascript\n * this.anims.createFromAseprite('paladin');\n * ```\n *\n * Any animations defined in the JSON will now be available to use in Phaser and you play them\n * via their Tag name. For example, if you have an animation called 'War Cry' on your Aseprite timeline,\n * you can play it in Phaser using that Tag name:\n *\n * ```javascript\n * this.add.sprite(400, 300).play('War Cry');\n * ```\n *\n * When calling this method you can optionally provide an array of tag names, and only those animations\n * will be created. For example:\n *\n * ```javascript\n * this.anims.createFromAseprite('paladin', [ 'step', 'War Cry', 'Magnum Break' ]);\n * ```\n *\n * This will only create the 3 animations defined. Note that the tag names are case-sensitive.\n *\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\n * this is what you would use to retrieve the image from the Texture Manager.\n *\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n *\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\n *\n * Note: The ability to load this type of file will only be available if the Aseprite File type has been built into Phaser.\n * It is available in the default build but can be excluded from custom builds.\n *\n * @method Phaser.Loader.LoaderPlugin#aseprite\n * @fires Phaser.Loader.LoaderPlugin#ADD\n * @since 3.50.0\n *\n * @param {(string|Phaser.Types.Loader.FileTypes.AsepriteFileConfig|Phaser.Types.Loader.FileTypes.AsepriteFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n * @param {object|string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\n *\n * @return {this} The Loader instance.\n */\nFileTypesManager.register('aseprite', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\n{\n    var multifile;\n\n    //  Supports an Object file definition in the key argument\n    //  Or an array of objects in the key argument\n    //  Or a single entry where all arguments have been defined\n\n    if (Array.isArray(key))\n    {\n        for (var i = 0; i < key.length; i++)\n        {\n            multifile = new AsepriteFile(this, key[i]);\n\n            this.addFile(multifile.files);\n        }\n    }\n    else\n    {\n        multifile = new AsepriteFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);\n\n        this.addFile(multifile.files);\n    }\n\n    return this;\n});\n\nmodule.exports = AsepriteFile;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar MultiFile = require('../MultiFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single JSON based Texture Atlas File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#atlas method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#atlas.\r\n *\r\n * https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-for-phaser3?source=photonstorm\r\n *\r\n * @class AtlasJSONFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {object|string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar AtlasJSONFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function AtlasJSONFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n    {\r\n        var image;\r\n        var data;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            image = new ImageFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'textureURL'),\r\n                extension: GetFastValue(config, 'textureExtension', 'png'),\r\n                normalMap: GetFastValue(config, 'normalMap'),\r\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\r\n            });\r\n\r\n            data = new JSONFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'atlasURL'),\r\n                extension: GetFastValue(config, 'atlasExtension', 'json'),\r\n                xhrSettings: GetFastValue(config, 'atlasXhrSettings')\r\n            });\r\n        }\r\n        else\r\n        {\r\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n            data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);\r\n        }\r\n\r\n        if (image.linkFile)\r\n        {\r\n            //  Image has a normal map\r\n            MultiFile.call(this, loader, 'atlasjson', key, [ image, data, image.linkFile ]);\r\n        }\r\n        else\r\n        {\r\n            MultiFile.call(this, loader, 'atlasjson', key, [ image, data ]);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AtlasJSONFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var image = this.files[0];\r\n            var json = this.files[1];\r\n            var normalMap = (this.files[2]) ? this.files[2].data : null;\r\n\r\n            this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);\r\n\r\n            json.pendingDestroy();\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON based Texture Atlas, or array of atlases, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.atlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the atlas data to be provided in a JSON file, using either the JSON Hash or JSON Array format.\r\n * These files are created by software such as Texture Packer, Shoebox and Adobe Flash / Animate.\r\n * If you are using Texture Packer and have enabled multi-atlas support, then please use the Phaser Multi Atlas loader\r\n * instead of this one.\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.atlas({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     atlasURL: 'images/MainMenu.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig` for more details.\r\n *\r\n * Instead of passing a URL for the atlas JSON data you can also pass in a well formed JSON object instead.\r\n *\r\n * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.atlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'mainmenu', 'background');\r\n * ```\r\n *\r\n * To get a list of all available frames within an atlas please consult your Texture Atlas software.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.atlas('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.json');\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.atlas({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     normalMap: 'images/MainMenu-n.png',\r\n *     atlasURL: 'images/MainMenu.json'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Atlas JSON File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#atlas\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig|Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {object|string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('atlas', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new AtlasJSONFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new AtlasJSONFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = AtlasJSONFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile.js');\r\nvar XMLFile = require('./XMLFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single XML based Texture Atlas File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#atlasXML method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#atlasXML.\r\n *\r\n * @class AtlasXMLFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas xml file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar AtlasXMLFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function AtlasXMLFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n    {\r\n        var image;\r\n        var data;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            image = new ImageFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'textureURL'),\r\n                extension: GetFastValue(config, 'textureExtension', 'png'),\r\n                normalMap: GetFastValue(config, 'normalMap'),\r\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\r\n            });\r\n\r\n            data = new XMLFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'atlasURL'),\r\n                extension: GetFastValue(config, 'atlasExtension', 'xml'),\r\n                xhrSettings: GetFastValue(config, 'atlasXhrSettings')\r\n            });\r\n        }\r\n        else\r\n        {\r\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n            data = new XMLFile(loader, key, atlasURL, atlasXhrSettings);\r\n        }\r\n\r\n        if (image.linkFile)\r\n        {\r\n            //  Image has a normal map\r\n            MultiFile.call(this, loader, 'atlasxml', key, [ image, data, image.linkFile ]);\r\n        }\r\n        else\r\n        {\r\n            MultiFile.call(this, loader, 'atlasxml', key, [ image, data ]);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AtlasXMLFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var image = this.files[0];\r\n            var xml = this.files[1];\r\n            var normalMap = (this.files[2]) ? this.files[2].data : null;\r\n\r\n            this.loader.textureManager.addAtlasXML(image.key, image.data, xml.data, normalMap);\r\n\r\n            xml.pendingDestroy();\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an XML based Texture Atlas, or array of atlases, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.atlasXML('mainmenu', 'images/MainMenu.png', 'images/MainMenu.xml');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the atlas data to be provided in an XML file format.\r\n * These files are created by software such as Shoebox and Adobe Flash / Animate.\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.atlasXML({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     atlasURL: 'images/MainMenu.xml'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig` for more details.\r\n *\r\n * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.atlasXML('mainmenu', 'images/MainMenu.png', 'images/MainMenu.xml');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'mainmenu', 'background');\r\n * ```\r\n *\r\n * To get a list of all available frames within an atlas please consult your Texture Atlas software.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.atlasXML('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.xml');\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.atlasXML({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     normalMap: 'images/MainMenu-n.png',\r\n *     atlasURL: 'images/MainMenu.xml'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Atlas XML File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#atlasXML\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.7.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig|Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas xml file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('atlasXML', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new AtlasXMLFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new AtlasXMLFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = AtlasXMLFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar HTML5AudioFile = require('./HTML5AudioFile');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Audio File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#audio method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#audio.\r\n *\r\n * @class AudioFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {any} [urlConfig] - The absolute or relative URL to load this file from in a config object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {AudioContext} [audioContext] - The AudioContext this file will use to process itself.\r\n */\r\nvar AudioFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    //  URL is an object created by AudioFile.findAudioURL\r\n    function AudioFile (loader, key, urlConfig, xhrSettings, audioContext)\r\n    {\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            audioContext = GetFastValue(config, 'context', audioContext);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'audio',\r\n            cache: loader.cacheManager.audio,\r\n            extension: urlConfig.type,\r\n            responseType: 'arraybuffer',\r\n            key: key,\r\n            url: urlConfig.url,\r\n            xhrSettings: xhrSettings,\r\n            config: { context: audioContext }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AudioFile#onProcess\r\n     * @since 3.0.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        var _this = this;\r\n\r\n        // interesting read https://github.com/WebAudio/web-audio-api/issues/1305\r\n        this.config.context.decodeAudioData(this.xhrLoader.response,\r\n            function (audioBuffer)\r\n            {\r\n                _this.data = audioBuffer;\r\n\r\n                _this.onProcessComplete();\r\n            },\r\n            function (e)\r\n            {\r\n                // eslint-disable-next-line no-console\r\n                console.error('Error decoding audio: ' + _this.key + ' - ', e ? e.message : null);\r\n\r\n                _this.onProcessError();\r\n            }\r\n        );\r\n\r\n        this.config.context = null;\r\n    }\r\n\r\n});\r\n\r\nAudioFile.create = function (loader, key, urls, config, xhrSettings)\r\n{\r\n    var game = loader.systems.game;\r\n    var audioConfig = game.config.audio;\r\n    var deviceAudio = game.device.audio;\r\n\r\n    //  url may be inside key, which may be an object\r\n    if (IsPlainObject(key))\r\n    {\r\n        urls = GetFastValue(key, 'url', []);\r\n        config = GetFastValue(key, 'config', {});\r\n    }\r\n\r\n    var urlConfig = AudioFile.getAudioURL(game, urls);\r\n\r\n    if (!urlConfig)\r\n    {\r\n        return null;\r\n    }\r\n\r\n    // https://developers.google.com/web/updates/2012/02/HTML5-audio-and-the-Web-Audio-API-are-BFFs\r\n    // var stream = GetFastValue(config, 'stream', false);\r\n\r\n    if (deviceAudio.webAudio && !audioConfig.disableWebAudio)\r\n    {\r\n        return new AudioFile(loader, key, urlConfig, xhrSettings, game.sound.context);\r\n    }\r\n    else\r\n    {\r\n        return new HTML5AudioFile(loader, key, urlConfig, config);\r\n    }\r\n};\r\n\r\nAudioFile.getAudioURL = function (game, urls)\r\n{\r\n    if (!Array.isArray(urls))\r\n    {\r\n        urls = [ urls ];\r\n    }\r\n\r\n    for (var i = 0; i < urls.length; i++)\r\n    {\r\n        var url = GetFastValue(urls[i], 'url', urls[i]);\r\n\r\n        if (url.indexOf('blob:') === 0 || url.indexOf('data:') === 0)\r\n        {\r\n            return {\r\n                url: url,\r\n                type: ''\r\n            };\r\n        }\r\n\r\n        var audioType = url.match(/\\.([a-zA-Z0-9]+)($|\\?)/);\r\n\r\n        audioType = GetFastValue(urls[i], 'type', (audioType) ? audioType[1] : '').toLowerCase();\r\n\r\n        if (game.device.audio[audioType])\r\n        {\r\n            return {\r\n                url: url,\r\n                type: audioType\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Adds an Audio or HTML5Audio file, or array of audio files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.audio('title', [ 'music/Title.ogg', 'music/Title.mp3', 'music/Title.m4a' ]);\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Audio Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Audio Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Audio Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.audio({\r\n *     key: 'title',\r\n *     url: [ 'music/Title.ogg', 'music/Title.mp3', 'music/Title.m4a' ]\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.AudioFileConfig` for more details.\r\n *\r\n * The URLs can be relative or absolute. If the URLs are relative the `Loader.baseURL` and `Loader.path` values will be prepended to them.\r\n *\r\n * Due to different browsers supporting different audio file types you should usually provide your audio files in a variety of formats.\r\n * ogg, mp3 and m4a are the most common. If you provide an array of URLs then the Loader will determine which _one_ file to load based on\r\n * browser support.\r\n *\r\n * If audio has been disabled in your game, either via the game config, or lack of support from the device, then no audio will be loaded.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Audio File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#audio\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioFileConfig|Phaser.Types.Loader.FileTypes.AudioFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(string|string[])} [urls] - The absolute or relative URL to load the audio files from.\r\n * @param {any} [config] - An object containing an `instances` property for HTML5Audio. Defaults to 1.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('audio', function (key, urls, config, xhrSettings)\r\n{\r\n    var game = this.systems.game;\r\n    var audioConfig = game.config.audio;\r\n    var deviceAudio = game.device.audio;\r\n\r\n    if (audioConfig.noAudio || (!deviceAudio.webAudio && !deviceAudio.audioData))\r\n    {\r\n        //  Sounds are disabled, so skip loading audio\r\n        return this;\r\n    }\r\n\r\n    var audioFile;\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            audioFile = AudioFile.create(this, key[i]);\r\n\r\n            if (audioFile)\r\n            {\r\n                this.addFile(audioFile);\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        audioFile = AudioFile.create(this, key, urls, config, xhrSettings);\r\n\r\n        if (audioFile)\r\n        {\r\n            this.addFile(audioFile);\r\n        }\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = AudioFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AudioFile = require('./AudioFile.js');\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar MultiFile = require('../MultiFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * An Audio Sprite File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#audioSprite method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#audioSprite.\r\n *\r\n * @class AudioSpriteFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} jsonURL - The absolute or relative URL to load the json file from. Or a well formed JSON object to use instead.\r\n * @param {{(string|string[])}} [audioURL] - The absolute or relative URL to load the audio file from. If empty it will be obtained by parsing the JSON file.\r\n * @param {any} [audioConfig] - The audio configuration options.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [audioXhrSettings] - An XHR Settings configuration object for the audio file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [jsonXhrSettings] - An XHR Settings configuration object for the json file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar AudioSpriteFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function AudioSpriteFile (loader, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings)\r\n    {\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            jsonURL = GetFastValue(config, 'jsonURL');\r\n            audioURL = GetFastValue(config, 'audioURL');\r\n            audioConfig = GetFastValue(config, 'audioConfig');\r\n            audioXhrSettings = GetFastValue(config, 'audioXhrSettings');\r\n            jsonXhrSettings = GetFastValue(config, 'jsonXhrSettings');\r\n        }\r\n\r\n        var data;\r\n\r\n        //  No url? then we're going to do a json load and parse it from that\r\n        if (!audioURL)\r\n        {\r\n            data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);\r\n\r\n            MultiFile.call(this, loader, 'audiosprite', key, [ data ]);\r\n\r\n            this.config.resourceLoad = true;\r\n            this.config.audioConfig = audioConfig;\r\n            this.config.audioXhrSettings = audioXhrSettings;\r\n        }\r\n        else\r\n        {\r\n            var audio = AudioFile.create(loader, key, audioURL, audioConfig, audioXhrSettings);\r\n\r\n            if (audio)\r\n            {\r\n                data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);\r\n\r\n                MultiFile.call(this, loader, 'audiosprite', key, [ audio, data ]);\r\n\r\n                this.config.resourceLoad = false;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AudioSpriteFile#onFileComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n\r\n            if (this.config.resourceLoad && file.type === 'json' && file.data.hasOwnProperty('resources'))\r\n            {\r\n                //  Inspect the data for the files to now load\r\n                var urls = file.data.resources;\r\n\r\n                var audioConfig = GetFastValue(this.config, 'audioConfig');\r\n                var audioXhrSettings = GetFastValue(this.config, 'audioXhrSettings');\r\n\r\n                var audio = AudioFile.create(this.loader, file.key, urls, audioConfig, audioXhrSettings);\r\n\r\n                if (audio)\r\n                {\r\n                    this.addToMultiFile(audio);\r\n\r\n                    this.loader.addFile(audio);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AudioSpriteFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var fileA = this.files[0];\r\n            var fileB = this.files[1];\r\n\r\n            fileA.addToCache();\r\n            fileB.addToCache();\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON based Audio Sprite, or array of audio sprites, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.audioSprite('kyobi', 'kyobi.json', [\r\n *         'kyobi.ogg',\r\n *         'kyobi.mp3',\r\n *         'kyobi.m4a'\r\n *     ]);\r\n * }\r\n * ```\r\n *\r\n * Audio Sprites are a combination of audio files and a JSON configuration.\r\n * The JSON follows the format of that created by https://github.com/tonistiigi/audiosprite\r\n *\r\n * If the JSON file includes a 'resource' object then you can let Phaser parse it and load the audio\r\n * files automatically based on its content. To do this exclude the audio URLs from the load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.audioSprite('kyobi', 'kyobi.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Audio Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Audio Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Audio Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.audioSprite({\r\n *     key: 'kyobi',\r\n *     jsonURL: 'audio/Kyobi.json',\r\n *     audioURL: [\r\n *         'audio/Kyobi.ogg',\r\n *         'audio/Kyobi.mp3',\r\n *         'audio/Kyobi.m4a'\r\n *     ]\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig` for more details.\r\n *\r\n * Instead of passing a URL for the audio JSON data you can also pass in a well formed JSON object instead.\r\n *\r\n * Once the audio has finished loading you can use it create an Audio Sprite by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.audioSprite('kyobi', 'kyobi.json');\r\n * // and later in your game ...\r\n * var music = this.sound.addAudioSprite('kyobi');\r\n * music.play('title');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * Due to different browsers supporting different audio file types you should usually provide your audio files in a variety of formats.\r\n * ogg, mp3 and m4a are the most common. If you provide an array of URLs then the Loader will determine which _one_ file to load based on\r\n * browser support.\r\n *\r\n * If audio has been disabled in your game, either via the game config, or lack of support from the device, then no audio will be loaded.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Audio Sprite File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#audioSprite\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig|Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig[])} key - The key to use for this file, or a file configuration object, or an array of objects.\r\n * @param {string} jsonURL - The absolute or relative URL to load the json file from. Or a well formed JSON object to use instead.\r\n * @param {(string|string[])} [audioURL] - The absolute or relative URL to load the audio file from. If empty it will be obtained by parsing the JSON file.\r\n * @param {any} [audioConfig] - The audio configuration options.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [audioXhrSettings] - An XHR Settings configuration object for the audio file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [jsonXhrSettings] - An XHR Settings configuration object for the json file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader.\r\n */\r\nFileTypesManager.register('audioSprite', function (key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings)\r\n{\r\n    var game = this.systems.game;\r\n    var gameAudioConfig = game.config.audio;\r\n    var deviceAudio = game.device.audio;\r\n\r\n    if ((gameAudioConfig && gameAudioConfig.noAudio) || (!deviceAudio.webAudio && !deviceAudio.audioData))\r\n    {\r\n        //  Sounds are disabled, so skip loading audio\r\n        return this;\r\n    }\r\n\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new AudioSpriteFile(this, key[i]);\r\n\r\n            if (multifile.files)\r\n            {\r\n                this.addFile(multifile.files);\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new AudioSpriteFile(this, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings);\r\n\r\n        if (multifile.files)\r\n        {\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n\r\n    return this;\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Binary File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#binary method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#binary.\r\n *\r\n * @class BinaryFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.BinaryFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.bin`, i.e. if `key` was \"alien\" then the URL will be \"alien.bin\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {any} [dataType] - Optional type to cast the binary file to once loaded. For example, `Uint8Array`.\r\n */\r\nvar BinaryFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function BinaryFile (loader, key, url, xhrSettings, dataType)\r\n    {\r\n        var extension = 'bin';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            dataType = GetFastValue(config, 'dataType', dataType);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'binary',\r\n            cache: loader.cacheManager.binary,\r\n            extension: extension,\r\n            responseType: 'arraybuffer',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: { dataType: dataType }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.BinaryFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        var ctor = this.config.dataType;\r\n\r\n        this.data = (ctor) ? new ctor(this.xhrLoader.response) : this.xhrLoader.response;\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Binary file, or array of Binary files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.binary('doom', 'files/Doom.wad');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Binary Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Binary Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Binary Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.binary({\r\n *     key: 'doom',\r\n *     url: 'files/Doom.wad',\r\n *     dataType: Uint8Array\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.BinaryFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.binary('doom', 'files/Doom.wad');\r\n * // and later in your game ...\r\n * var data = this.cache.binary.get('doom');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Data` the final key will be `LEVEL1.Data` and\r\n * this is what you would use to retrieve the text from the Binary Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"doom\"\r\n * and no URL is given then the Loader will set the URL to be \"doom.bin\". It will always add `.bin` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Binary File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#binary\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.BinaryFileConfig|Phaser.Types.Loader.FileTypes.BinaryFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.bin`, i.e. if `key` was \"alien\" then the URL will be \"alien.bin\".\r\n * @param {any} [dataType] - Optional type to cast the binary file to once loaded. For example, `Uint8Array`.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('binary', function (key, url, dataType, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new BinaryFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new BinaryFile(this, key, url, xhrSettings, dataType));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = BinaryFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile.js');\r\nvar ParseXMLBitmapFont = require('../../gameobjects/bitmaptext/ParseXMLBitmapFont.js');\r\nvar XMLFile = require('./XMLFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single Bitmap Font based File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#bitmapFont method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#bitmapFont.\r\n *\r\n * @class BitmapFontFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.BitmapFontFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the font image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [fontDataURL] - The absolute or relative URL to load the font xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the font image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [fontDataXhrSettings] - An XHR Settings configuration object for the font data xml file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar BitmapFontFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function BitmapFontFile (loader, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings)\r\n    {\r\n        var image;\r\n        var data;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            image = new ImageFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'textureURL'),\r\n                extension: GetFastValue(config, 'textureExtension', 'png'),\r\n                normalMap: GetFastValue(config, 'normalMap'),\r\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\r\n            });\r\n\r\n            data = new XMLFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'fontDataURL'),\r\n                extension: GetFastValue(config, 'fontDataExtension', 'xml'),\r\n                xhrSettings: GetFastValue(config, 'fontDataXhrSettings')\r\n            });\r\n        }\r\n        else\r\n        {\r\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n            data = new XMLFile(loader, key, fontDataURL, fontDataXhrSettings);\r\n        }\r\n\r\n        if (image.linkFile)\r\n        {\r\n            //  Image has a normal map\r\n            MultiFile.call(this, loader, 'bitmapfont', key, [ image, data, image.linkFile ]);\r\n        }\r\n        else\r\n        {\r\n            MultiFile.call(this, loader, 'bitmapfont', key, [ image, data ]);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.BitmapFontFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var image = this.files[0];\r\n            var xml = this.files[1];\r\n\r\n            image.addToCache();\r\n            xml.pendingDestroy();\r\n\r\n            var texture = image.cache.get(image.key);\r\n\r\n            var data = ParseXMLBitmapFont(xml.data, image.cache.getFrame(image.key), 0, 0, texture);\r\n\r\n            this.loader.cacheManager.bitmapFont.add(image.key, { data: data, texture: image.key, frame: null });\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an XML based Bitmap Font, or array of fonts, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.bitmapFont('goldenFont', 'images/GoldFont.png', 'images/GoldFont.xml');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the font data to be provided in an XML file format.\r\n * These files are created by software such as the [Angelcode Bitmap Font Generator](http://www.angelcode.com/products/bmfont/),\r\n * [Littera](http://kvazars.com/littera/) or [Glyph Designer](https://71squared.com/glyphdesigner)\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.bitmapFont({\r\n *     key: 'goldenFont',\r\n *     textureURL: 'images/GoldFont.png',\r\n *     fontDataURL: 'images/GoldFont.xml'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.BitmapFontFileConfig` for more details.\r\n *\r\n * Once the atlas has finished loading you can use key of it when creating a Bitmap Text Game Object:\r\n *\r\n * ```javascript\r\n * this.load.bitmapFont('goldenFont', 'images/GoldFont.png', 'images/GoldFont.xml');\r\n * // and later in your game ...\r\n * this.add.bitmapText(x, y, 'goldenFont', 'Hello World');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use when creating a Bitmap Text object.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.bitmapFont('goldenFont', [ 'images/GoldFont.png', 'images/GoldFont-n.png' ], 'images/GoldFont.xml');\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.bitmapFont({\r\n *     key: 'goldenFont',\r\n *     textureURL: 'images/GoldFont.png',\r\n *     normalMap: 'images/GoldFont-n.png',\r\n *     fontDataURL: 'images/GoldFont.xml'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Bitmap Font File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#bitmapFont\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.BitmapFontFileConfig|Phaser.Types.Loader.FileTypes.BitmapFontFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the font image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [fontDataURL] - The absolute or relative URL to load the font xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the font image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [fontDataXhrSettings] - An XHR Settings configuration object for the font data xml file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('bitmapFont', function (key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new BitmapFontFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new BitmapFontFile(this, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = BitmapFontFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single CSS File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#css method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#css.\r\n *\r\n * @class CSSFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.17.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.CSSFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar CSSFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function CSSFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'css';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'script',\r\n            cache: false,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.CSSFile#onProcess\r\n     * @since 3.17.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = document.createElement('style');\r\n        this.data.defer = false;\r\n        this.data.innerHTML = this.xhrLoader.responseText;\r\n\r\n        document.head.appendChild(this.data);\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a CSS file, or array of CSS files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.css('headers', 'styles/headers.css');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.css({\r\n *     key: 'headers',\r\n *     url: 'styles/headers.css'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.CSSFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be converted into a style DOM element\r\n * via `document.createElement('style')`. It will have its `defer` property set to false and then the\r\n * resulting element will be appended to `document.head`. The CSS styles are then applied to the current document.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.css\". It will always add `.css` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the CSS File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#css\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.17.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.CSSFileConfig|Phaser.Types.Loader.FileTypes.CSSFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.css`, i.e. if `key` was \"alien\" then the URL will be \"alien.css\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('css', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new CSSFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new CSSFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = CSSFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2021 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AtlasJSONFile = require('./AtlasJSONFile');\r\nvar BinaryFile = require('./BinaryFile');\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile');\r\nvar JSONFile = require('./JSONFile');\r\nvar KTXParser = require('../../textures/parsers/KTXParser');\r\nvar Merge = require('../../utils/object/Merge');\r\nvar MultiAtlasFile = require('./MultiAtlasFile');\r\nvar MultiFile = require('../MultiFile');\r\nvar PVRParser = require('../../textures/parsers/PVRParser');\r\n\r\n/**\r\n * @classdesc\r\n * A Compressed Texture File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#texture method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#texture.\r\n *\r\n * @class CompressedTextureFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.60.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {string} key - The key to use for this file.\r\n * @param {Phaser.Types.Loader.FileTypes.CompressedTextureFileEntry} entry - The compressed texture file entry to load.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar CompressedTextureFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function CompressedTextureFile (loader, key, entry, xhrSettings)\r\n    {\r\n        if (entry.multiAtlasURL)\r\n        {\r\n            var multi = new JSONFile(loader, {\r\n                key: key,\r\n                url: entry.multiAtlasURL,\r\n                xhrSettings: xhrSettings,\r\n                config: entry\r\n            });\r\n\r\n            MultiFile.call(this, loader, 'texture', key, [ multi ]);\r\n        }\r\n        else\r\n        {\r\n            var extension = entry.textureURL.substr(entry.textureURL.length - 3);\r\n\r\n            if (!entry.type)\r\n            {\r\n                entry.type = (extension.toLowerCase() === 'ktx') ? 'KTX' : 'PVR';\r\n            }\r\n\r\n            var image = new BinaryFile(loader, {\r\n                key: key,\r\n                url: entry.textureURL,\r\n                extension: extension,\r\n                xhrSettings: xhrSettings,\r\n                config: entry\r\n            });\r\n\r\n            if (entry.atlasURL)\r\n            {\r\n                var data = new JSONFile(loader, {\r\n                    key: key,\r\n                    url: entry.atlasURL,\r\n                    xhrSettings: xhrSettings,\r\n                    config: entry\r\n                });\r\n\r\n                MultiFile.call(this, loader, 'texture', key, [ image, data ]);\r\n            }\r\n            else\r\n            {\r\n                MultiFile.call(this, loader, 'texture', key, [ image ]);\r\n            }\r\n        }\r\n\r\n        this.config = entry;\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.CompressedTextureFile#onFileComplete\r\n     * @since 3.60.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n\r\n            if (!this.config.multiAtlasURL)\r\n            {\r\n                return;\r\n            }\r\n\r\n            if (file.type === 'json' && file.data.hasOwnProperty('textures'))\r\n            {\r\n                //  Inspect the data for the files to now load\r\n                var textures = file.data.textures;\r\n\r\n                var config = this.config;\r\n                var loader = this.loader;\r\n\r\n                var currentBaseURL = loader.baseURL;\r\n                var currentPath = loader.path;\r\n                var currentPrefix = loader.prefix;\r\n\r\n                var baseURL = GetFastValue(config, 'multiBaseURL', this.baseURL);\r\n                var path = GetFastValue(config, 'multiPath', this.path);\r\n                var prefix = GetFastValue(config, 'prefix', this.prefix);\r\n                var textureXhrSettings = GetFastValue(config, 'textureXhrSettings');\r\n\r\n                if (baseURL)\r\n                {\r\n                    loader.setBaseURL(baseURL);\r\n                }\r\n\r\n                if (path)\r\n                {\r\n                    loader.setPath(path);\r\n                }\r\n\r\n                if (prefix)\r\n                {\r\n                    loader.setPrefix(prefix);\r\n                }\r\n\r\n                for (var i = 0; i < textures.length; i++)\r\n                {\r\n                    //  \"image\": \"texture-packer-multi-atlas-0.png\",\r\n                    var textureURL = textures[i].image;\r\n\r\n                    var key = 'CMA' + this.multiKeyIndex + '_' + textureURL;\r\n\r\n                    var image = new BinaryFile(loader, key, textureURL, textureXhrSettings);\r\n\r\n                    this.addToMultiFile(image);\r\n\r\n                    loader.addFile(image);\r\n\r\n                    //  \"normalMap\": \"texture-packer-multi-atlas-0_n.png\",\r\n                    if (textures[i].normalMap)\r\n                    {\r\n                        var normalMap = new BinaryFile(loader, key, textures[i].normalMap, textureXhrSettings);\r\n\r\n                        normalMap.type = 'normalMap';\r\n\r\n                        image.setLink(normalMap);\r\n\r\n                        this.addToMultiFile(normalMap);\r\n\r\n                        loader.addFile(normalMap);\r\n                    }\r\n                }\r\n\r\n                //  Reset the loader settings\r\n                loader.setBaseURL(currentBaseURL);\r\n                loader.setPath(currentPath);\r\n                loader.setPrefix(currentPrefix);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.CompressedTextureFile#addToCache\r\n     * @since 3.60.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var entry = this.config;\r\n\r\n            if (entry.multiAtlasURL)\r\n            {\r\n                this.addMultiToCache();\r\n            }\r\n            else\r\n            {\r\n                var renderer = this.loader.systems.renderer;\r\n                var textureManager = this.loader.textureManager;\r\n                var textureData;\r\n\r\n                var image = this.files[0];\r\n                var json = this.files[1];\r\n\r\n                if (entry.type === 'PVR')\r\n                {\r\n                    textureData = PVRParser(image.data);\r\n                }\r\n                else if (entry.type === 'KTX')\r\n                {\r\n                    textureData = KTXParser(image.data);\r\n                }\r\n\r\n                if (textureData && renderer.supportsCompressedTexture(entry.format, textureData.internalFormat))\r\n                {\r\n                    textureData.format = renderer.getCompressedTextureName(entry.format, textureData.internalFormat);\r\n\r\n                    var atlasData = (json && json.data) ? json.data : null;\r\n\r\n                    textureManager.addCompressedTexture(image.key, textureData, atlasData);\r\n                }\r\n\r\n                if (json)\r\n                {\r\n                    json.pendingDestroy();\r\n                }\r\n            }\r\n\r\n            this.complete = true;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds all of the multi-file entties to their target caches upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.CompressedTextureFile#addMultiToCache\r\n     * @since 3.60.0\r\n     */\r\n    addMultiToCache: function ()\r\n    {\r\n        var entry = this.config;\r\n        var json = this.files[0];\r\n\r\n        var data = [];\r\n        var images = [];\r\n        var normalMaps = [];\r\n\r\n        var renderer = this.loader.systems.renderer;\r\n        var textureManager = this.loader.textureManager;\r\n        var textureData;\r\n\r\n        for (var i = 1; i < this.files.length; i++)\r\n        {\r\n            var file = this.files[i];\r\n\r\n            if (file.type === 'normalMap')\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var pos = file.key.indexOf('_');\r\n            var key = file.key.substr(pos + 1);\r\n\r\n            var image = file.data;\r\n\r\n            //  Now we need to find out which json entry this mapped to\r\n            for (var t = 0; t < json.data.textures.length; t++)\r\n            {\r\n                var item = json.data.textures[t];\r\n\r\n                if (item.image === key)\r\n                {\r\n                    if (entry.type === 'PVR')\r\n                    {\r\n                        textureData = PVRParser(image);\r\n                    }\r\n                    else if (entry.type === 'KTX')\r\n                    {\r\n                        textureData = KTXParser(image);\r\n                    }\r\n\r\n                    if (textureData && renderer.supportsCompressedTexture(entry.format, textureData.internalFormat))\r\n                    {\r\n                        textureData.format = renderer.getCompressedTextureName(entry.format, textureData.internalFormat);\r\n\r\n                        images.push(textureData);\r\n\r\n                        data.push(item);\r\n\r\n                        if (file.linkFile)\r\n                        {\r\n                            normalMaps.push(file.linkFile.data);\r\n                        }\r\n                    }\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (normalMaps.length === 0)\r\n        {\r\n            normalMaps = undefined;\r\n        }\r\n\r\n        textureManager.addAtlasJSONArray(this.key, images, data, normalMaps);\r\n\r\n        this.complete = true;\r\n\r\n        for (i = 0; i < this.files.length; i++)\r\n        {\r\n            this.files[i].pendingDestroy();\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Compressed Texture file to the current load queue. This feature is WebGL only.\r\n *\r\n * This method takes a key and a configuration object, which lists the different formats\r\n * and files associated with them.\r\n *\r\n * The texture format object should be ordered in GPU priority order, with IMG as the last entry.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * preload ()\r\n * {\r\n *     this.load.texture('yourPic', {\r\n *         ASTC: { type: 'PVR', textureURL: 'pic-astc-4x4.pvr' },\r\n *         PVRTC: { type: 'PVR', textureURL: 'pic-pvrtc-4bpp-rgba.pvr' },\r\n *         S3TC: { type: 'PVR', textureURL: 'pic-dxt5.pvr' },\r\n *         IMG: { textureURL: 'pic.png' }\r\n *     });\r\n * ```\r\n *\r\n * If you wish to load a texture atlas, provide the `atlasURL` property:\r\n *\r\n * ```javascript\r\n * preload ()\r\n * {\r\n *     const path = 'assets/compressed';\r\n *\r\n *     this.load.texture('yourAtlas', {\r\n *         'ASTC': { type: 'PVR', textureURL: `${path}/textures-astc-4x4.pvr`, atlasURL: `${path}/textures.json` },\r\n *         'PVRTC': { type: 'PVR', textureURL: `${path}/textures-pvrtc-4bpp-rgba.pvr`, atlasURL: `${path}/textures-pvrtc-4bpp-rgba.json` },\r\n *         'S3TC': { type: 'PVR', textureURL: `${path}/textures-dxt5.pvr`, atlasURL: `${path}/textures-dxt5.json` },\r\n *         'IMG': { textureURL: `${path}/textures.png`, atlasURL: `${path}/textures.json` }\r\n *     });\r\n * }\r\n * ```\r\n *\r\n * If you wish to load a Multi Atlas, as exported from Texture Packer Pro, use the `multiAtlasURL` property instead:\r\n *\r\n * ```javascript\r\n * preload ()\r\n * {\r\n *     const path = 'assets/compressed';\r\n *\r\n *     this.load.texture('yourAtlas', {\r\n *         'ASTC': { type: 'PVR', atlasURL: `${path}/textures.json` },\r\n *         'PVRTC': { type: 'PVR', atlasURL: `${path}/textures-pvrtc-4bpp-rgba.json` },\r\n *         'S3TC': { type: 'PVR', atlasURL: `${path}/textures-dxt5.json` },\r\n *         'IMG': { atlasURL: `${path}/textures.json` }\r\n *     });\r\n * }\r\n * ```\r\n *\r\n * When loading a Multi Atlas you do not need to specify the `textureURL` property as it will be read from the JSON file.\r\n *\r\n * The number of formats you provide to this function is up to you, but you should ensure you\r\n * cover the primary platforms where appropriate.\r\n *\r\n * The 'IMG' entry is a fallback to a JPG or PNG, should the browser be unable to load any of the other\r\n * formats presented to this function. You should really always include this, although it is optional.\r\n *\r\n * Phaser supports loading both the PVR and KTX container formats. Within those, it can parse\r\n * the following texture compression formats:\r\n *\r\n * ETC\r\n * ETC1\r\n * ATC\r\n * ASTC\r\n * BPTC\r\n * RGTC\r\n * PVRTC\r\n * S3TC\r\n * S3TCSRGB\r\n *\r\n * For more information about the benefits of compressed textures please see the\r\n * following articles:\r\n *\r\n * Texture Compression in 2020 (https://aras-p.info/blog/2020/12/08/Texture-Compression-in-2020/)\r\n * Compressed GPU Texture Formats (https://themaister.net/blog/2020/08/12/compressed-gpu-texture-formats-a-review-and-compute-shader-decoders-part-1/)\r\n *\r\n * To create compressed texture files use a 3rd party application such as:\r\n *\r\n * Texture Packer (https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-for-phaser3?utm_source=ad&utm_medium=banner&utm_campaign=phaser-2018-10-16)\r\n * PVRTexTool (https://developer.imaginationtech.com/pvrtextool/) - available for Windows, macOS and Linux.\r\n * Mali Texture Compression Tool (https://developer.arm.com/tools-and-software/graphics-and-gaming/mali-texture-compression-tool)\r\n * ASTC Encoder (https://github.com/ARM-software/astc-encoder)\r\n *\r\n * ASTCs must have a Channel Type of Unsigned Normalized Bytes (UNorm) and a Linear RGB Color Space.\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Data` the final key will be `LEVEL1.Data` and\r\n * this is what you would use to retrieve the text from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * Unlike other file loaders in Phaser, the URLs must include the file extension.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Compressed Texture File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#texture\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.60.0\r\n *\r\n * @param {string} key - The key to use for this file within the Texture Manager.\r\n * @param {Phaser.Types.Loader.FileTypes.CompressedTextureFileConfig} urls - The compressed texture configuration object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('texture', function (key, urls, xhrSettings)\r\n{\r\n    var entry = {\r\n        format: null,\r\n        type: null,\r\n        textureURL: null,\r\n        atlasURL: null,\r\n        multiAtlasURL: null,\r\n        multiPath: null,\r\n        multiBaseURL: null\r\n    };\r\n\r\n    var renderer = this.systems.renderer;\r\n\r\n    for (var textureBaseFormat in urls)\r\n    {\r\n        if (renderer.supportsCompressedTexture(textureBaseFormat))\r\n        {\r\n            var urlEntry = urls[textureBaseFormat];\r\n\r\n            if (typeof urlEntry === 'string')\r\n            {\r\n                entry.textureURL = urlEntry;\r\n            }\r\n            else\r\n            {\r\n                entry = Merge(urlEntry, entry);\r\n            }\r\n\r\n            entry.format = textureBaseFormat.toUpperCase();\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!entry)\r\n    {\r\n        console.warn('No supported texture format or IMG fallback', key);\r\n    }\r\n    else if (entry.format === 'IMG')\r\n    {\r\n        if (entry.multiAtlasURL)\r\n        {\r\n            this.addFile(new MultiAtlasFile(this, key, entry.multiAtlasURL, entry.multiPath, entry.multiBaseURL, xhrSettings));\r\n        }\r\n        else if (entry.atlasURL)\r\n        {\r\n            this.addFile(new AtlasJSONFile(this, key, entry.textureURL, entry.atlasURL, xhrSettings));\r\n        }\r\n        else\r\n        {\r\n            this.addFile(new ImageFile(this, key, entry.textureURL, xhrSettings));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        var texture = new CompressedTextureFile(this, key, entry, xhrSettings);\r\n\r\n        this.addFile(texture.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = CompressedTextureFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar Shader = require('../../display/shader/BaseShader');\r\n\r\n/**\r\n * @classdesc\r\n * A single GLSL File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#glsl method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#glsl.\r\n *\r\n * @class GLSLFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.GLSLFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {string} [shaderType='fragment'] - The type of shader. Either `fragment` for a fragment shader, or `vertex` for a vertex shader. This is ignored if you load a shader bundle.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar GLSLFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function GLSLFile (loader, key, url, shaderType, xhrSettings)\r\n    {\r\n        var extension = 'glsl';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            shaderType = GetFastValue(config, 'shaderType', 'fragment');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n        else if (shaderType === undefined)\r\n        {\r\n            shaderType = 'fragment';\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'glsl',\r\n            cache: loader.cacheManager.shader,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            config: {\r\n                shaderType: shaderType\r\n            },\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#addToCache\r\n     * @since 3.17.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var data = this.data.split('\\n');\r\n\r\n        //  Check to see if this is a shader bundle, or raw glsl file.\r\n        var block = this.extractBlock(data, 0);\r\n\r\n        if (block)\r\n        {\r\n            while (block)\r\n            {\r\n                var key = this.getShaderName(block.header);\r\n                var shaderType = this.getShaderType(block.header);\r\n                var uniforms = this.getShaderUniforms(block.header);\r\n                var shaderSrc = block.shader;\r\n\r\n                if (this.cache.has(key))\r\n                {\r\n                    var shader = this.cache.get(key);\r\n\r\n                    if (shaderType === 'fragment')\r\n                    {\r\n                        shader.fragmentSrc = shaderSrc;\r\n                    }\r\n                    else\r\n                    {\r\n                        shader.vertexSrc = shaderSrc;\r\n                    }\r\n\r\n                    if (!shader.uniforms)\r\n                    {\r\n                        shader.uniforms = uniforms;\r\n                    }\r\n                }\r\n                else if (shaderType === 'fragment')\r\n                {\r\n                    this.cache.add(key, new Shader(key, shaderSrc, '', uniforms));\r\n                }\r\n                else\r\n                {\r\n                    this.cache.add(key, new Shader(key, '', shaderSrc, uniforms));\r\n                }\r\n\r\n                block = this.extractBlock(data, block.offset);\r\n            }\r\n        }\r\n        else if (this.config.shaderType === 'fragment')\r\n        {\r\n            //  Single shader\r\n            this.cache.add(this.key, new Shader(this.key, this.data));\r\n        }\r\n        else\r\n        {\r\n            this.cache.add(this.key, new Shader(this.key, '', this.data));\r\n        }\r\n\r\n        this.pendingDestroy();\r\n    },\r\n\r\n    /**\r\n     * Returns the name of the shader from the header block.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#getShaderName\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string[]} headerSource - The header data.\r\n     *\r\n     * @return {string} The shader name.\r\n     */\r\n    getShaderName: function (headerSource)\r\n    {\r\n        for (var i = 0; i < headerSource.length; i++)\r\n        {\r\n            var line = headerSource[i].trim();\r\n\r\n            if (line.substring(0, 5) === 'name:')\r\n            {\r\n                return line.substring(5).trim();\r\n            }\r\n        }\r\n\r\n        return this.key;\r\n    },\r\n\r\n    /**\r\n     * Returns the type of the shader from the header block.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#getShaderType\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string[]} headerSource - The header data.\r\n     *\r\n     * @return {string} The shader type. Either 'fragment' or 'vertex'.\r\n     */\r\n    getShaderType: function (headerSource)\r\n    {\r\n        for (var i = 0; i < headerSource.length; i++)\r\n        {\r\n            var line = headerSource[i].trim();\r\n\r\n            if (line.substring(0, 5) === 'type:')\r\n            {\r\n                return line.substring(5).trim();\r\n            }\r\n        }\r\n\r\n        return this.config.shaderType;\r\n    },\r\n\r\n    /**\r\n     * Returns the shader uniforms from the header block.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#getShaderUniforms\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string[]} headerSource - The header data.\r\n     *\r\n     * @return {any} The shader uniforms object.\r\n     */\r\n    getShaderUniforms: function (headerSource)\r\n    {\r\n        var uniforms = {};\r\n\r\n        for (var i = 0; i < headerSource.length; i++)\r\n        {\r\n            var line = headerSource[i].trim();\r\n\r\n            if (line.substring(0, 8) === 'uniform.')\r\n            {\r\n                var pos = line.indexOf(':');\r\n\r\n                if (pos)\r\n                {\r\n                    var key = line.substring(8, pos);\r\n\r\n                    try\r\n                    {\r\n                        uniforms[key] = JSON.parse(line.substring(pos + 1));\r\n                    }\r\n                    catch (e)\r\n                    {\r\n                        console.warn('Invalid uniform JSON: ' + key);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return uniforms;\r\n    },\r\n\r\n    /**\r\n     * Processes the shader file and extracts the relevant data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#extractBlock\r\n     * @private\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string[]} data - The array of shader data to process.\r\n     * @param {number} offset - The offset to start processing from.\r\n     *\r\n     * @return {any} The processed shader block, or null.\r\n     */\r\n    extractBlock: function (data, offset)\r\n    {\r\n        var headerStart = -1;\r\n        var headerEnd = -1;\r\n        var blockEnd = -1;\r\n        var headerOpen = false;\r\n        var captureSource = false;\r\n        var headerSource = [];\r\n        var shaderSource = [];\r\n\r\n        for (var i = offset; i < data.length; i++)\r\n        {\r\n            var line = data[i].trim();\r\n\r\n            if (line === '---')\r\n            {\r\n                if (headerStart === -1)\r\n                {\r\n                    headerStart = i;\r\n                    headerOpen = true;\r\n                }\r\n                else if (headerOpen)\r\n                {\r\n                    headerEnd = i;\r\n                    headerOpen = false;\r\n                    captureSource = true;\r\n                }\r\n                else\r\n                {\r\n                    //  We've hit another --- delimiter, break out\r\n                    captureSource = false;\r\n                    break;\r\n                }\r\n            }\r\n            else if (headerOpen)\r\n            {\r\n                headerSource.push(line);\r\n            }\r\n            else if (captureSource)\r\n            {\r\n                shaderSource.push(line);\r\n                blockEnd = i;\r\n            }\r\n        }\r\n\r\n        if (!headerOpen && headerEnd !== -1)\r\n        {\r\n            return { header: headerSource, shader: shaderSource.join('\\n'), offset: blockEnd };\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a GLSL file, or array of GLSL files, to the current load queue.\r\n * In Phaser 3 GLSL files are just plain Text files at the current moment in time.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.glsl('plasma', 'shaders/Plasma.glsl');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Shader Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Shader Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Shader Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.glsl({\r\n *     key: 'plasma',\r\n *     shaderType: 'fragment',\r\n *     url: 'shaders/Plasma.glsl'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.GLSLFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.glsl('plasma', 'shaders/Plasma.glsl');\r\n * // and later in your game ...\r\n * var data = this.cache.shader.get('plasma');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `FX.` and the key was `Plasma` the final key will be `FX.Plasma` and\r\n * this is what you would use to retrieve the text from the Shader Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"plasma\"\r\n * and no URL is given then the Loader will set the URL to be \"plasma.glsl\". It will always add `.glsl` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the GLSL File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#glsl\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.GLSLFileConfig|Phaser.Types.Loader.FileTypes.GLSLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.glsl`, i.e. if `key` was \"alien\" then the URL will be \"alien.glsl\".\r\n * @param {string} [shaderType='fragment'] - The type of shader. Either `fragment` for a fragment shader, or `vertex` for a vertex shader. This is ignored if you load a shader bundle.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('glsl', function (key, url, shaderType, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new GLSLFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new GLSLFile(this, key, url, shaderType, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = GLSLFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Events = require('../events');\r\nvar File = require('../File');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetURL = require('../GetURL');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Audio File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#audio method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#audio.\r\n *\r\n * @class HTML5AudioFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [urlConfig] - The absolute or relative URL to load this file from.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar HTML5AudioFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function HTML5AudioFile (loader, key, urlConfig, audioConfig)\r\n    {\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            audioConfig = GetFastValue(config, 'config', audioConfig);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'audio',\r\n            cache: loader.cacheManager.audio,\r\n            extension: urlConfig.type,\r\n            key: key,\r\n            url: urlConfig.url,\r\n            config: audioConfig\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        //  New properties specific to this class\r\n        this.locked = 'ontouchstart' in window;\r\n        this.loaded = false;\r\n        this.filesLoaded = 0;\r\n        this.filesTotal = 0;\r\n    },\r\n\r\n    /**\r\n     * Called when the file finishes loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTML5AudioFile#onLoad\r\n     * @since 3.0.0\r\n     */\r\n    onLoad: function ()\r\n    {\r\n        if (this.loaded)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.loaded = true;\r\n\r\n        this.loader.nextFile(this, true);\r\n    },\r\n\r\n    /**\r\n     * Called if the file errors while loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTML5AudioFile#onError\r\n     * @since 3.0.0\r\n     */\r\n    onError: function ()\r\n    {\r\n        for (var i = 0; i < this.data.length; i++)\r\n        {\r\n            var audio = this.data[i];\r\n\r\n            audio.oncanplaythrough = null;\r\n            audio.onerror = null;\r\n        }\r\n\r\n        this.loader.nextFile(this, false);\r\n    },\r\n\r\n    /**\r\n     * Called during the file load progress. Is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTML5AudioFile#onProgress\r\n     * @fires Phaser.Loader.Events#FILE_PROGRESS\r\n     * @since 3.0.0\r\n     */\r\n    onProgress: function (event)\r\n    {\r\n        var audio = event.target;\r\n\r\n        audio.oncanplaythrough = null;\r\n        audio.onerror = null;\r\n\r\n        this.filesLoaded++;\r\n\r\n        this.percentComplete = Math.min((this.filesLoaded / this.filesTotal), 1);\r\n\r\n        this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);\r\n\r\n        if (this.filesLoaded === this.filesTotal)\r\n        {\r\n            this.onLoad();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the Loader, starts the actual file downloading.\r\n     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.\r\n     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTML5AudioFile#load\r\n     * @since 3.0.0\r\n     */\r\n    load: function ()\r\n    {\r\n        this.data = [];\r\n\r\n        var instances = (this.config && this.config.instances) || 1;\r\n\r\n        this.filesTotal = instances;\r\n        this.filesLoaded = 0;\r\n        this.percentComplete = 0;\r\n\r\n        for (var i = 0; i < instances; i++)\r\n        {\r\n            var audio = new Audio();\r\n\r\n            if (!audio.dataset)\r\n            {\r\n                audio.dataset = {};\r\n            }\r\n\r\n            audio.dataset.name = this.key + ('0' + i).slice(-2);\r\n            audio.dataset.used = 'false';\r\n\r\n            if (this.locked)\r\n            {\r\n                audio.dataset.locked = 'true';\r\n            }\r\n            else\r\n            {\r\n                audio.dataset.locked = 'false';\r\n\r\n                audio.preload = 'auto';\r\n                audio.oncanplaythrough = this.onProgress.bind(this);\r\n                audio.onerror = this.onError.bind(this);\r\n            }\r\n\r\n            this.data.push(audio);\r\n        }\r\n\r\n        for (i = 0; i < this.data.length; i++)\r\n        {\r\n            audio = this.data[i];\r\n            audio.src = GetURL(this, this.loader.baseURL);\r\n\r\n            if (!this.locked)\r\n            {\r\n                audio.load();\r\n            }\r\n        }\r\n\r\n        if (this.locked)\r\n        {\r\n            //  This is super-dangerous but works. Race condition potential high.\r\n            //  Is there another way?\r\n            setTimeout(this.onLoad.bind(this));\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = HTML5AudioFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single HTML File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#html method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#html.\r\n *\r\n * @class HTMLFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.12.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.HTMLFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was \"alien\" then the URL will be \"alien.html\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar HTMLFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function HTMLFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'html';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'text',\r\n            cache: loader.cacheManager.html,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTMLFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an HTML file, or array of HTML files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.html('story', 'files/LoginForm.html');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global HTML Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the HTML Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the HTML Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.html({\r\n *     key: 'login',\r\n *     url: 'files/LoginForm.html'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.HTMLFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.html('login', 'files/LoginForm.html');\r\n * // and later in your game ...\r\n * var data = this.cache.html.get('login');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the html from the HTML Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.html\". It will always add `.html` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the HTML File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#html\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.12.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.HTMLFileConfig|Phaser.Types.Loader.FileTypes.HTMLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was \"alien\" then the URL will be \"alien.html\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('html', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new HTMLFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new HTMLFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = HTMLFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single HTML File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#htmlTexture method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#htmlTexture.\r\n *\r\n * @class HTMLTextureFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.12.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {number} [width] - The width of the texture the HTML will be rendered to.\r\n * @param {number} [height] - The height of the texture the HTML will be rendered to.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar HTMLTextureFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function HTMLTextureFile (loader, key, url, width, height, xhrSettings)\r\n    {\r\n        if (width === undefined) { width = 512; }\r\n        if (height === undefined) { height = 512; }\r\n\r\n        var extension = 'html';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            width = GetFastValue(config, 'width', width);\r\n            height = GetFastValue(config, 'height', height);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'html',\r\n            cache: loader.textureManager,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                width: width,\r\n                height: height\r\n            }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTMLTextureFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        var w = this.config.width;\r\n        var h = this.config.height;\r\n\r\n        var data = [];\r\n\r\n        data.push('<svg width=\"' + w + 'px\" height=\"' + h + 'px\" viewBox=\"0 0 ' + w + ' ' + h + '\" xmlns=\"http://www.w3.org/2000/svg\">');\r\n        data.push('<foreignObject width=\"100%\" height=\"100%\">');\r\n        data.push('<body xmlns=\"http://www.w3.org/1999/xhtml\">');\r\n        data.push(this.xhrLoader.responseText);\r\n        data.push('</body>');\r\n        data.push('</foreignObject>');\r\n        data.push('</svg>');\r\n\r\n        var svg = [ data.join('\\n') ];\r\n        var _this = this;\r\n\r\n        try\r\n        {\r\n            var blob = new window.Blob(svg, { type: 'image/svg+xml;charset=utf-8' });\r\n        }\r\n        catch (e)\r\n        {\r\n            _this.state = CONST.FILE_ERRORED;\r\n\r\n            _this.onProcessComplete();\r\n\r\n            return;\r\n        }\r\n\r\n        this.data = new Image();\r\n\r\n        this.data.crossOrigin = this.crossOrigin;\r\n\r\n        this.data.onload = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessError();\r\n        };\r\n\r\n        File.createObjectURL(this.data, blob, 'image/svg+xml');\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTMLTextureFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture = this.cache.addImage(this.key, this.data);\r\n\r\n        this.pendingDestroy(texture);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an HTML File, or array of HTML Files, to the current load queue. When the files are loaded they\r\n * will be rendered to textures and stored in the Texture Manager.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.htmlTexture('instructions', 'content/intro.html', 256, 512);\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.htmlTexture({\r\n *     key: 'instructions',\r\n *     url: 'content/intro.html',\r\n *     width: 256,\r\n *     height: 512\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.htmlTexture('instructions', 'content/intro.html', 256, 512);\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'instructions');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.html\". It will always add `.html` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * The width and height are the size of the texture to which the HTML will be rendered. It's not possible to determine these\r\n * automatically, so you will need to provide them, either as arguments or in the file config object.\r\n * When the HTML file has loaded a new SVG element is created with a size and viewbox set to the width and height given.\r\n * The SVG file has a body tag added to it, with the HTML file contents included. It then calls `window.Blob` on the SVG,\r\n * and if successful is added to the Texture Manager, otherwise it fails processing. The overall quality of the rendered\r\n * HTML depends on your browser, and some of them may not even support the svg / blob process used. Be aware that there are\r\n * limitations on what HTML can be inside an SVG. You can find out more details in this\r\n * [Mozilla MDN entry](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Drawing_DOM_objects_into_a_canvas).\r\n *\r\n * Note: The ability to load this type of file will only be available if the HTMLTextureFile File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#htmlTexture\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.12.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig|Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was \"alien\" then the URL will be \"alien.html\".\r\n * @param {number} [width=512] - The width of the texture the HTML will be rendered to.\r\n * @param {number} [height=512] - The height of the texture the HTML will be rendered to.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('htmlTexture', function (key, url, width, height, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new HTMLTextureFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new HTMLTextureFile(this, key, url, width, height, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = HTMLTextureFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar GetURL = require('../GetURL');\r\n\r\n/**\r\n * @classdesc\r\n * A single Image File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#image method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#image.\r\n *\r\n * @class ImageFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ImageFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {Phaser.Types.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object. Only provided for, and used by, Sprite Sheets.\r\n */\r\nvar ImageFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function ImageFile (loader, key, url, xhrSettings, frameConfig)\r\n    {\r\n        var extension = 'png';\r\n        var normalMapURL;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            normalMapURL = GetFastValue(config, 'normalMap');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            frameConfig = GetFastValue(config, 'frameConfig');\r\n        }\r\n\r\n        if (Array.isArray(url))\r\n        {\r\n            normalMapURL = url[1];\r\n            url = url[0];\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'image',\r\n            cache: loader.textureManager,\r\n            extension: extension,\r\n            responseType: 'blob',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: frameConfig\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        //  Do we have a normal map to load as well?\r\n        if (normalMapURL)\r\n        {\r\n            var normalMap = new ImageFile(loader, this.key, normalMapURL, xhrSettings, frameConfig);\r\n\r\n            normalMap.type = 'normalMap';\r\n\r\n            this.setLink(normalMap);\r\n\r\n            loader.addFile(normalMap);\r\n        }\r\n\r\n        this.useImageElementLoad = loader.imageLoadType === 'HTMLImageElement';\r\n\r\n        if (this.useImageElementLoad)\r\n        {\r\n            this.load = this.loadImage;\r\n            this.onProcess = this.onProcessImage;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ImageFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = new Image();\r\n\r\n        this.data.crossOrigin = this.crossOrigin;\r\n\r\n        var _this = this;\r\n\r\n        this.data.onload = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessError();\r\n        };\r\n\r\n        File.createObjectURL(this.data, this.xhrLoader.response, 'image/png');\r\n    },\r\n\r\n    /**\r\n     * Handles image load processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ImageFile#onProcessImage\r\n     * @private\r\n     * @since 3.60.0\r\n     */\r\n    onProcessImage: function ()\r\n    {\r\n        var result = this.state;\r\n\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        if (result === CONST.FILE_LOADED)\r\n        {\r\n            this.onProcessComplete();\r\n        }\r\n        else\r\n        {\r\n            this.onProcessError();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Loads the image using either XHR or an Image tag.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ImageFile#loadImage\r\n     * @private\r\n     * @since 3.60.0\r\n     */\r\n    loadImage: function ()\r\n    {\r\n        this.state = CONST.FILE_LOADING;\r\n\r\n        this.src = GetURL(this, this.loader.baseURL);\r\n\r\n        if (this.src.indexOf('data:') === 0)\r\n        {\r\n            console.warn('Local data URIs are not supported: ' + this.key);\r\n        }\r\n        else\r\n        {\r\n            this.data = new Image();\r\n\r\n            this.data.crossOrigin = this.crossOrigin;\r\n\r\n            var _this = this;\r\n\r\n            this.data.onload = function ()\r\n            {\r\n                _this.state = CONST.FILE_LOADED;\r\n\r\n                _this.loader.nextFile(_this, true);\r\n            };\r\n\r\n            this.data.onerror = function ()\r\n            {\r\n                _this.loader.nextFile(_this, false);\r\n            };\r\n\r\n            this.data.src = this.src;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ImageFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture;\r\n        var linkFile = this.linkFile;\r\n\r\n        if (linkFile && linkFile.state === CONST.FILE_COMPLETE)\r\n        {\r\n            if (this.type === 'image')\r\n            {\r\n                texture = this.cache.addImage(this.key, this.data, linkFile.data);\r\n            }\r\n            else\r\n            {\r\n                texture = this.cache.addImage(linkFile.key, linkFile.data, this.data);\r\n            }\r\n\r\n            this.pendingDestroy(texture);\r\n\r\n            linkFile.pendingDestroy(texture);\r\n        }\r\n        else if (!linkFile)\r\n        {\r\n            texture = this.cache.addImage(this.key, this.data);\r\n\r\n            this.pendingDestroy(texture);\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an Image, or array of Images, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.image('logo', 'images/phaserLogo.png');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n * If you try to load an animated gif only the first frame will be rendered. Browsers do not natively support playback\r\n * of animated gifs to Canvas elements.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.image({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.ImageFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.image('logo', 'images/AtariLogo.png');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'logo');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.image('logo', [ 'images/AtariLogo.png', 'images/AtariLogo-n.png' ]);\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.image({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png',\r\n *     normalMap: 'images/AtariLogo-n.png'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * In Phaser 3.60 a new property was added that allows you to control how images are loaded. By default, images are loaded via XHR as Blobs.\r\n * However, you can set `loader.imageLoadType: \"HTMLImageElement\"` in the Game Configuration and instead, the Loader will load all images\r\n * via the Image tag instead.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Image File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#image\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ImageFileConfig|Phaser.Types.Loader.FileTypes.ImageFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('image', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new ImageFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new ImageFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = ImageFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single JSON File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#json method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#json.\r\n *\r\n * @class JSONFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {(object|string)} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, can be a fully formed JSON Object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n */\r\nvar JSONFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object\r\n    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing\r\n\r\n    function JSONFile (loader, key, url, xhrSettings, dataKey)\r\n    {\r\n        var extension = 'json';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            dataKey = GetFastValue(config, 'dataKey', dataKey);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'json',\r\n            cache: loader.cacheManager.json,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: dataKey\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        if (IsPlainObject(url))\r\n        {\r\n            //  Object provided instead of a URL, so no need to actually load it (populate data with value)\r\n            if (dataKey)\r\n            {\r\n                this.data = GetValue(url, dataKey);\r\n            }\r\n            else\r\n            {\r\n                this.data = url;\r\n            }\r\n\r\n            this.state = CONST.FILE_POPULATED;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.JSONFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        if (this.state !== CONST.FILE_POPULATED)\r\n        {\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            try\r\n            {\r\n                var json = JSON.parse(this.xhrLoader.responseText);\r\n            }\r\n            catch (e)\r\n            {\r\n                this.onProcessError();\r\n\r\n                throw e;\r\n            }\r\n\r\n            var key = this.config;\r\n\r\n            if (typeof key === 'string')\r\n            {\r\n                this.data = GetValue(json, key, json);\r\n            }\r\n            else\r\n            {\r\n                this.data = json;\r\n            }\r\n        }\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON file, or array of JSON files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.json('wavedata', 'files/AlienWaveData.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the JSON Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.json({\r\n *     key: 'wavedata',\r\n *     url: 'files/AlienWaveData.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.JSONFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.json('wavedata', 'files/AlienWaveData.json');\r\n * // and later in your game ...\r\n * var data = this.cache.json.get('wavedata');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the JSON Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,\r\n * rather than the whole file. For example, if your JSON data had a structure like this:\r\n *\r\n * ```json\r\n * {\r\n *     \"level1\": {\r\n *         \"baddies\": {\r\n *             \"aliens\": {},\r\n *             \"boss\": {}\r\n *         }\r\n *     },\r\n *     \"level2\": {},\r\n *     \"level3\": {}\r\n * }\r\n * ```\r\n *\r\n * And you only wanted to store the `boss` data in the Cache, then you could pass `level1.baddies.boss`as the `dataKey`.\r\n *\r\n * Note: The ability to load this type of file will only be available if the JSON File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#json\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig|Phaser.Types.Loader.FileTypes.JSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(object|string)} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, can be a fully formed JSON Object.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('json', function (key, url, dataKey, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new JSONFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = JSONFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar MultiFile = require('../MultiFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single Multi Texture Atlas File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#multiatlas method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#multiatlas.\r\n *\r\n * @class MultiAtlasFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig)} key - The key of the file. Must be unique within both the Loader and the Texture Manager. Or a config object.\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the multi atlas json file from.\r\n * @param {string} [path] - Optional path to use when loading the textures defined in the atlas data.\r\n * @param {string} [baseURL] - Optional Base URL to use when loading the textures defined in the atlas data.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - Extra XHR Settings specifically for the atlas json file.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - Extra XHR Settings specifically for the texture files.\r\n */\r\nvar MultiAtlasFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function MultiAtlasFile (loader, key, atlasURL, path, baseURL, atlasXhrSettings, textureXhrSettings)\r\n    {\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            if (GetFastValue(config, 'url', false))\r\n            {\r\n                atlasURL = GetFastValue(config, 'url');\r\n            }\r\n            else\r\n            {\r\n                atlasURL = GetFastValue(config, 'atlasURL');\r\n            }\r\n\r\n            atlasXhrSettings = GetFastValue(config, 'xhrSettings');\r\n            path = GetFastValue(config, 'path');\r\n            baseURL = GetFastValue(config, 'baseURL');\r\n            textureXhrSettings = GetFastValue(config, 'textureXhrSettings');\r\n        }\r\n\r\n        var data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);\r\n\r\n        MultiFile.call(this, loader, 'multiatlas', key, [ data ]);\r\n\r\n        this.config.path = path;\r\n        this.config.baseURL = baseURL;\r\n        this.config.textureXhrSettings = textureXhrSettings;\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.MultiAtlasFile#onFileComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n\r\n            if (file.type === 'json' && file.data.hasOwnProperty('textures'))\r\n            {\r\n                //  Inspect the data for the files to now load\r\n                var textures = file.data.textures;\r\n\r\n                var config = this.config;\r\n                var loader = this.loader;\r\n\r\n                var currentBaseURL = loader.baseURL;\r\n                var currentPath = loader.path;\r\n                var currentPrefix = loader.prefix;\r\n\r\n                var baseURL = GetFastValue(config, 'baseURL', this.baseURL);\r\n                var path = GetFastValue(config, 'path', this.path);\r\n                var prefix = GetFastValue(config, 'prefix', this.prefix);\r\n                var textureXhrSettings = GetFastValue(config, 'textureXhrSettings');\r\n\r\n                loader.setBaseURL(baseURL);\r\n                loader.setPath(path);\r\n                loader.setPrefix(prefix);\r\n\r\n                for (var i = 0; i < textures.length; i++)\r\n                {\r\n                    //  \"image\": \"texture-packer-multi-atlas-0.png\",\r\n                    var textureURL = textures[i].image;\r\n\r\n                    var key = 'MA' + this.multiKeyIndex + '_' + textureURL;\r\n\r\n                    var image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n\r\n                    this.addToMultiFile(image);\r\n\r\n                    loader.addFile(image);\r\n\r\n                    //  \"normalMap\": \"texture-packer-multi-atlas-0_n.png\",\r\n                    if (textures[i].normalMap)\r\n                    {\r\n                        var normalMap = new ImageFile(loader, key, textures[i].normalMap, textureXhrSettings);\r\n\r\n                        normalMap.type = 'normalMap';\r\n\r\n                        image.setLink(normalMap);\r\n\r\n                        this.addToMultiFile(normalMap);\r\n\r\n                        loader.addFile(normalMap);\r\n                    }\r\n                }\r\n\r\n                //  Reset the loader settings\r\n                loader.setBaseURL(currentBaseURL);\r\n                loader.setPath(currentPath);\r\n                loader.setPrefix(currentPrefix);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.MultiAtlasFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var fileJSON = this.files[0];\r\n\r\n            var data = [];\r\n            var images = [];\r\n            var normalMaps = [];\r\n\r\n            for (var i = 1; i < this.files.length; i++)\r\n            {\r\n                var file = this.files[i];\r\n\r\n                if (file.type === 'normalMap')\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                var pos = file.key.indexOf('_');\r\n                var key = file.key.substr(pos + 1);\r\n\r\n                var image = file.data;\r\n\r\n                //  Now we need to find out which json entry this mapped to\r\n                for (var t = 0; t < fileJSON.data.textures.length; t++)\r\n                {\r\n                    var item = fileJSON.data.textures[t];\r\n\r\n                    if (item.image === key)\r\n                    {\r\n                        images.push(image);\r\n\r\n                        data.push(item);\r\n\r\n                        if (file.linkFile)\r\n                        {\r\n                            normalMaps.push(file.linkFile.data);\r\n                        }\r\n\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (normalMaps.length === 0)\r\n            {\r\n                normalMaps = undefined;\r\n            }\r\n\r\n            this.loader.textureManager.addAtlasJSONArray(this.key, images, data, normalMaps);\r\n\r\n            this.complete = true;\r\n\r\n            for (i = 0; i < this.files.length; i++)\r\n            {\r\n                this.files[i].pendingDestroy();\r\n            }\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Multi Texture Atlas, or array of multi atlases, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.multiatlas('level1', 'images/Level1.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the atlas data to be provided in a JSON file as exported from the application Texture Packer,\r\n * version 4.6.3 or above, where you have made sure to use the Phaser 3 Export option.\r\n *\r\n * The way it works internally is that you provide a URL to the JSON file. Phaser then loads this JSON, parses it and\r\n * extracts which texture files it also needs to load to complete the process. If the JSON also defines normal maps,\r\n * Phaser will load those as well.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.multiatlas({\r\n *     key: 'level1',\r\n *     atlasURL: 'images/Level1.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig` for more details.\r\n *\r\n * Instead of passing a URL for the atlas JSON data you can also pass in a well formed JSON object instead.\r\n *\r\n * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.multiatlas('level1', 'images/Level1.json');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'level1', 'background');\r\n * ```\r\n *\r\n * To get a list of all available frames within an atlas please consult your Texture Atlas software.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Multi Atlas File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#multiatlas\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.7.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig|Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {string} [path] - Optional path to use when loading the textures defined in the atlas data.\r\n * @param {string} [baseURL] - Optional Base URL to use when loading the textures defined in the atlas data.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('multiatlas', function (key, atlasURL, path, baseURL, atlasXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new MultiAtlasFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new MultiAtlasFile(this, key, atlasURL, path, baseURL, atlasXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = MultiAtlasFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile.js');\r\nvar ScriptFile = require('./ScriptFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A Multi Script File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#scripts method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#scripts.\r\n *\r\n * @class MultiScriptFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.17.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.MultiScriptFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string[]} [url] - An array of absolute or relative URLs to load the script files from. They are processed in the order given in the array.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object for the script files. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar MultiScriptFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function MultiScriptFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n        var files = [];\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        if (!Array.isArray(url))\r\n        {\r\n            url = [ url ];\r\n        }\r\n\r\n        for (var i = 0; i < url.length; i++)\r\n        {\r\n            var scriptFile = new ScriptFile(loader, {\r\n                key: key + '_' + i.toString(),\r\n                url: url[i],\r\n                extension: extension,\r\n                xhrSettings: xhrSettings\r\n            });\r\n\r\n            //  Override the default onProcess function\r\n            scriptFile.onProcess = function ()\r\n            {\r\n                this.onProcessComplete();\r\n            };\r\n\r\n            files.push(scriptFile);\r\n        }\r\n\r\n        MultiFile.call(this, loader, 'scripts', key, files);\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.MultiScriptFile#addToCache\r\n     * @since 3.17.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            for (var i = 0; i < this.files.length; i++)\r\n            {\r\n                var file = this.files[i];\r\n\r\n                file.data = document.createElement('script');\r\n                file.data.language = 'javascript';\r\n                file.data.type = 'text/javascript';\r\n                file.data.defer = false;\r\n                file.data.text = file.xhrLoader.responseText;\r\n\r\n                document.head.appendChild(file.data);\r\n            }\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an array of Script files to the current load queue.\r\n *\r\n * The difference between this and the `ScriptFile` file type is that you give an array of scripts to this method,\r\n * and the scripts are then processed _exactly_ in that order. This allows you to load a bunch of scripts that\r\n * may have dependencies on each other without worrying about the async nature of traditional script loading.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.scripts('PostProcess', [\r\n *         'libs/shaders/CopyShader.js',\r\n *         'libs/postprocessing/EffectComposer.js',\r\n *         'libs/postprocessing/RenderPass.js',\r\n *         'libs/postprocessing/MaskPass.js',\r\n *         'libs/postprocessing/ShaderPass.js',\r\n *         'libs/postprocessing/AfterimagePass.js'\r\n *    ]);\r\n * }\r\n * ```\r\n *\r\n * In the code above the script files will all be loaded in parallel but only processed (i.e. invoked) in the exact\r\n * order given in the array.\r\n *\r\n * The files are **not** loaded right away. They are added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the files are queued\r\n * it means you cannot use the files immediately after calling this method, but must wait for the files to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.scripts({\r\n *     key: 'PostProcess',\r\n *     url: [\r\n *         'libs/shaders/CopyShader.js',\r\n *         'libs/postprocessing/EffectComposer.js',\r\n *         'libs/postprocessing/RenderPass.js',\r\n *         'libs/postprocessing/MaskPass.js',\r\n *         'libs/postprocessing/ShaderPass.js',\r\n *         'libs/postprocessing/AfterimagePass.js'\r\n *        ]\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.MultiScriptFileConfig` for more details.\r\n *\r\n * Once all the files have finished loading they will automatically be converted into a script element\r\n * via `document.createElement('script')`. They will have their language set to JavaScript, `defer` set to\r\n * false and then the resulting element will be appended to `document.head`. Any code then in the\r\n * script will be executed. This is done in the exact order the files are specified in the url array.\r\n *\r\n * The URLs can be relative or absolute. If the URLs are relative the `Loader.baseURL` and `Loader.path` values will be prepended to them.\r\n *\r\n * Note: The ability to load this type of file will only be available if the MultiScript File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#scripts\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.17.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.MultiScriptFileConfig|Phaser.Types.Loader.FileTypes.MultiScriptFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string[]} [url] - An array of absolute or relative URLs to load the script files from. They are processed in the order given in the array.\r\n * @param {string} [extension='js'] - The default file extension to use if no url is provided.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for these files.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('scripts', function (key, url, xhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new MultiScriptFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new MultiScriptFile(this, key, url, xhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = MultiScriptFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile');\r\nvar ParseObj = require('../../geom/mesh/ParseObj');\r\nvar ParseObjMaterial = require('../../geom/mesh/ParseObjMaterial');\r\nvar TextFile = require('./TextFile');\r\n\r\n/**\r\n * @classdesc\r\n * A single Wavefront OBJ File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#obj method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#obj.\r\n *\r\n * @class OBJFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.OBJFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [objURL] - The absolute or relative URL to load the obj file from. If undefined or `null` it will be set to `<key>.obj`, i.e. if `key` was \"alien\" then the URL will be \"alien.obj\".\r\n * @param {string} [matURL] - The absolute or relative URL to load the material file from. If undefined or `null` it will be set to `<key>.mat`, i.e. if `key` was \"alien\" then the URL will be \"alien.mat\".\r\n * @param {boolean} [flipUV] - Flip the UV coordinates stored in the model data?\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for these files.\r\n */\r\nvar OBJFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function OBJFile (loader, key, objURL, matURL, flipUV, xhrSettings)\r\n    {\r\n        var obj;\r\n        var mat;\r\n\r\n        var cache = loader.cacheManager.obj;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            obj = new TextFile(loader, {\r\n                key: key,\r\n                type: 'obj',\r\n                cache: cache,\r\n                url: GetFastValue(config, 'url'),\r\n                extension: GetFastValue(config, 'extension', 'obj'),\r\n                xhrSettings: GetFastValue(config, 'xhrSettings'),\r\n                config: {\r\n                    flipUV: GetFastValue(config, 'flipUV', flipUV)\r\n                }\r\n            });\r\n\r\n            matURL = GetFastValue(config, 'matURL');\r\n\r\n            if (matURL)\r\n            {\r\n                mat = new TextFile(loader, {\r\n                    key: key,\r\n                    type: 'mat',\r\n                    cache: cache,\r\n                    url: matURL,\r\n                    extension: GetFastValue(config, 'matExtension', 'mat'),\r\n                    xhrSettings: GetFastValue(config, 'xhrSettings')\r\n                });\r\n            }\r\n        }\r\n        else\r\n        {\r\n            obj = new TextFile(loader, {\r\n                key: key,\r\n                url: objURL,\r\n                type: 'obj',\r\n                cache: cache,\r\n                extension: 'obj',\r\n                xhrSettings: xhrSettings,\r\n                config: {\r\n                    flipUV: flipUV\r\n                }\r\n            });\r\n\r\n            if (matURL)\r\n            {\r\n                mat = new TextFile(loader, {\r\n                    key: key,\r\n                    url: matURL,\r\n                    type: 'mat',\r\n                    cache: cache,\r\n                    extension: 'mat',\r\n                    xhrSettings: xhrSettings\r\n                });\r\n            }\r\n        }\r\n\r\n        MultiFile.call(this, loader, 'obj', key, [ obj, mat ]);\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.OBJFile#addToCache\r\n     * @since 3.50.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var obj = this.files[0];\r\n            var mat = this.files[1];\r\n\r\n            var objData = ParseObj(obj.data, obj.config.flipUV);\r\n\r\n            if (mat)\r\n            {\r\n                objData.materials = ParseObjMaterial(mat.data);\r\n            }\r\n\r\n            obj.cache.add(obj.key, objData);\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Wavefront OBJ file, or array of OBJ files, to the current load queue.\r\n *\r\n * Note: You should ensure your 3D package has triangulated the OBJ file prior to export.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.obj('ufo', 'files/spaceship.obj');\r\n * }\r\n * ```\r\n *\r\n * You can optionally also load a Wavefront Material file as well, by providing the 3rd parameter:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.obj('ufo', 'files/spaceship.obj', 'files/spaceship.mtl');\r\n * }\r\n * ```\r\n *\r\n * If given, the material will be parsed and stored along with the obj data in the cache.\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global OBJ Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the OBJ Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the OBJ Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.obj({\r\n *     key: 'ufo',\r\n *     url: 'files/spaceship.obj',\r\n *     matURL: 'files/spaceship.mtl',\r\n *     flipUV: true\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.OBJFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.obj('ufo', 'files/spaceship.obj');\r\n * // and later in your game ...\r\n * var data = this.cache.obj.get('ufo');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the obj from the OBJ Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.obj\". It will always add `.obj` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the OBJ File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#obj\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.50.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.OBJFileConfig|Phaser.Types.Loader.FileTypes.OBJFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [objURL] - The absolute or relative URL to load the obj file from. If undefined or `null` it will be set to `<key>.obj`, i.e. if `key` was \"alien\" then the URL will be \"alien.obj\".\r\n * @param {string} [matURL] - Optional absolute or relative URL to load the obj material file from.\r\n * @param {boolean} [flipUV] - Flip the UV coordinates stored in the model data?\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('obj', function (key, objURL, matURL, flipUVs, xhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new OBJFile(this, key[i]);\r\n\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new OBJFile(this, key, objURL, matURL, flipUVs, xhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = OBJFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar JSONFile = require('./JSONFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single JSON Pack File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#pack method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#pack.\r\n *\r\n * @class PackFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.PackFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n */\r\nvar PackFile = new Class({\r\n\r\n    Extends: JSONFile,\r\n\r\n    initialize:\r\n\r\n    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object\r\n    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing\r\n\r\n    function PackFile (loader, key, url, xhrSettings, dataKey)\r\n    {\r\n        JSONFile.call(this, loader, key, url, xhrSettings, dataKey);\r\n\r\n        this.type = 'packfile';\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.PackFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        if (this.state !== CONST.FILE_POPULATED)\r\n        {\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            this.data = JSON.parse(this.xhrLoader.responseText);\r\n        }\r\n\r\n        //  Let's pass the pack file data over to the Loader ...\r\n        this.loader.addPack(this.data, this.config);\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON File Pack, or array of packs, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.pack('level1', 'data/Level1Files.json');\r\n * }\r\n * ```\r\n *\r\n * A File Pack is a JSON file (or object) that contains details about other files that should be added into the Loader.\r\n * Here is a small example:\r\n *\r\n * ```json\r\n * {\r\n *    \"test1\": {\r\n *        \"files\": [\r\n *            {\r\n *                \"type\": \"image\",\r\n *                \"key\": \"taikodrummaster\",\r\n *                \"url\": \"assets/pics/taikodrummaster.jpg\"\r\n *            },\r\n *            {\r\n *                \"type\": \"image\",\r\n *                \"key\": \"sukasuka-chtholly\",\r\n *                \"url\": \"assets/pics/sukasuka-chtholly.png\"\r\n *            }\r\n *        ]\r\n *    },\r\n *    \"meta\": {\r\n *        \"generated\": \"1401380327373\",\r\n *        \"app\": \"Phaser 3 Asset Packer\",\r\n *        \"url\": \"https://phaser.io\",\r\n *        \"version\": \"1.0\",\r\n *        \"copyright\": \"Photon Storm Ltd. 2018\"\r\n *    }\r\n * }\r\n * ```\r\n *\r\n * The pack can be split into sections. In the example above you'll see a section called `test1. You can tell\r\n * the `load.pack` method to parse only a particular section of a pack. The pack is stored in the JSON Cache,\r\n * so you can pass it to the Loader to process additional sections as needed in your game, or you can just load\r\n * them all at once without specifying anything.\r\n *\r\n * The pack file can contain an entry for any type of file that Phaser can load. The object structures exactly\r\n * match that of the file type configs, and all properties available within the file type configs can be used\r\n * in the pack file too.\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the JSON Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.pack({\r\n *     key: 'level1',\r\n *     url: 'data/Level1Files.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.PackFileConfig` for more details.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the JSON Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,\r\n * rather than the whole file. For example, if your JSON data had a structure like this:\r\n *\r\n * ```json\r\n * {\r\n *     \"level1\": {\r\n *         \"baddies\": {\r\n *             \"aliens\": {},\r\n *             \"boss\": {}\r\n *         }\r\n *     },\r\n *     \"level2\": {},\r\n *     \"level3\": {}\r\n * }\r\n * ```\r\n *\r\n * And you only wanted to store the `boss` data in the Cache, then you could pass `level1.baddies.boss`as the `dataKey`.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Pack File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#pack\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.7.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.PackFileConfig|Phaser.Types.Loader.FileTypes.PackFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('pack', function (key, url, packKey, xhrSettings)\r\n{\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            this.addFile(new PackFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new PackFile(this, key, url, xhrSettings, packKey));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = PackFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Plugin Script File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#plugin method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#plugin.\r\n *\r\n * @class PluginFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.PluginFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {boolean} [start=false] - Automatically start the plugin after loading?\r\n * @param {string} [mapping] - If this plugin is to be injected into the Scene, this is the property key used.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar PluginFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function PluginFile (loader, key, url, start, mapping, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            start = GetFastValue(config, 'start');\r\n            mapping = GetFastValue(config, 'mapping');\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'plugin',\r\n            cache: false,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                start: start,\r\n                mapping: mapping\r\n            }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        // If the url variable refers to a class, add the plugin directly\r\n        if (typeof url === 'function')\r\n        {\r\n            this.data = url;\r\n\r\n            this.state = CONST.FILE_POPULATED;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.PluginFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        var pluginManager = this.loader.systems.plugins;\r\n        var config = this.config;\r\n\r\n        var start = GetFastValue(config, 'start', false);\r\n        var mapping = GetFastValue(config, 'mapping', null);\r\n\r\n        if (this.state === CONST.FILE_POPULATED)\r\n        {\r\n            pluginManager.install(this.key, this.data, start, mapping);\r\n        }\r\n        else\r\n        {\r\n            //  Plugin added via a js file\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            this.data = document.createElement('script');\r\n            this.data.language = 'javascript';\r\n            this.data.type = 'text/javascript';\r\n            this.data.defer = false;\r\n            this.data.text = this.xhrLoader.responseText;\r\n\r\n            document.head.appendChild(this.data);\r\n\r\n            var plugin = pluginManager.install(this.key, window[this.key], start, mapping);\r\n\r\n            if (start || mapping)\r\n            {\r\n                //  Install into the current Scene Systems and Scene\r\n                this.loader.systems[mapping] = plugin;\r\n                this.loader.scene[mapping] = plugin;\r\n            }\r\n        }\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Plugin Script file, or array of plugin files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.plugin('modplayer', 'plugins/ModPlayer.js');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.plugin({\r\n *     key: 'modplayer',\r\n *     url: 'plugins/ModPlayer.js'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.PluginFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be converted into a script element\r\n * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to\r\n * false and then the resulting element will be appended to `document.head`. Any code then in the\r\n * script will be executed. It will then be passed to the Phaser PluginCache.register method.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.js\". It will always add `.js` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Plugin File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#plugin\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.PluginFileConfig|Phaser.Types.Loader.FileTypes.PluginFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(string|function)} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\". Or, a plugin function.\r\n * @param {boolean} [start] - Automatically start the plugin after loading?\r\n * @param {string} [mapping] - If this plugin is to be injected into the Scene, this is the property key used.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('plugin', function (key, url, start, mapping, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new PluginFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new PluginFile(this, key, url, start, mapping, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = PluginFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single SVG File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#svg method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#svg.\r\n *\r\n * @class SVGFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SVGFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.svg`, i.e. if `key` was \"alien\" then the URL will be \"alien.svg\".\r\n * @param {Phaser.Types.Loader.FileTypes.SVGSizeConfig} [svgConfig] - The svg size configuration object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar SVGFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function SVGFile (loader, key, url, svgConfig, xhrSettings)\r\n    {\r\n        var extension = 'svg';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            svgConfig = GetFastValue(config, 'svgConfig', {});\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'svg',\r\n            cache: loader.textureManager,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                width: GetFastValue(svgConfig, 'width'),\r\n                height: GetFastValue(svgConfig, 'height'),\r\n                scale: GetFastValue(svgConfig, 'scale')\r\n            }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SVGFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        var text = this.xhrLoader.responseText;\r\n        var svg = [ text ];\r\n        var width = this.config.width;\r\n        var height = this.config.height;\r\n        var scale = this.config.scale;\r\n\r\n        resize: if (width && height || scale)\r\n        {\r\n            var xml = null;\r\n            var parser = new DOMParser();\r\n            xml = parser.parseFromString(text, 'text/xml');\r\n            var svgXML = xml.getElementsByTagName('svg')[0];\r\n\r\n            var hasViewBox = svgXML.hasAttribute('viewBox');\r\n            var svgWidth = parseFloat(svgXML.getAttribute('width'));\r\n            var svgHeight = parseFloat(svgXML.getAttribute('height'));\r\n\r\n            if (!hasViewBox && svgWidth && svgHeight)\r\n            {\r\n                //  If there's no viewBox attribute, set one\r\n                svgXML.setAttribute('viewBox', '0  0 ' + svgWidth + ' ' + svgHeight);\r\n            }\r\n            else if (hasViewBox && !svgWidth && !svgHeight)\r\n            {\r\n                //  Get the w/h from the viewbox\r\n                var viewBox = svgXML.getAttribute('viewBox').split(/\\s+|,/);\r\n\r\n                svgWidth = viewBox[2];\r\n                svgHeight = viewBox[3];\r\n            }\r\n\r\n            if (scale)\r\n            {\r\n                if (svgWidth && svgHeight)\r\n                {\r\n                    width = svgWidth * scale;\r\n                    height = svgHeight * scale;\r\n                }\r\n                else\r\n                {\r\n                    break resize;\r\n                }\r\n            }\r\n\r\n            svgXML.setAttribute('width', width.toString() + 'px');\r\n            svgXML.setAttribute('height', height.toString() + 'px');\r\n\r\n            svg = [ (new XMLSerializer()).serializeToString(svgXML) ];\r\n        }\r\n\r\n        try\r\n        {\r\n            var blob = new window.Blob(svg, { type: 'image/svg+xml;charset=utf-8' });\r\n        }\r\n        catch (e)\r\n        {\r\n            this.onProcessError();\r\n\r\n            return;\r\n        }\r\n\r\n        this.data = new Image();\r\n\r\n        this.data.crossOrigin = this.crossOrigin;\r\n\r\n        var _this = this;\r\n        var retry = false;\r\n\r\n        this.data.onload = function ()\r\n        {\r\n            if (!retry)\r\n            {\r\n                File.revokeObjectURL(_this.data);\r\n            }\r\n\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            //  Safari 8 re-try\r\n            if (!retry)\r\n            {\r\n                retry = true;\r\n\r\n                File.revokeObjectURL(_this.data);\r\n\r\n                _this.data.src = 'data:image/svg+xml,' + encodeURIComponent(svg.join(''));\r\n            }\r\n            else\r\n            {\r\n                _this.onProcessError();\r\n            }\r\n        };\r\n\r\n        File.createObjectURL(this.data, blob, 'image/svg+xml');\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SVGFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture = this.cache.addImage(this.key, this.data);\r\n\r\n        this.pendingDestroy(texture);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an SVG File, or array of SVG Files, to the current load queue. When the files are loaded they\r\n * will be rendered to bitmap textures and stored in the Texture Manager.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.svg('morty', 'images/Morty.svg');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.svg({\r\n *     key: 'morty',\r\n *     url: 'images/Morty.svg'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.SVGFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.svg('morty', 'images/Morty.svg');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'morty');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.html\". It will always add `.html` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can optionally pass an SVG Resize Configuration object when you load an SVG file. By default the SVG will be rendered to a texture\r\n * at the same size defined in the SVG file attributes. However, this isn't always desirable. You may wish to resize the SVG (either down\r\n * or up) to improve texture clarity, or reduce texture memory consumption. You can either specify an exact width and height to resize\r\n * the SVG to:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.svg('morty', 'images/Morty.svg', { width: 300, height: 600 });\r\n * }\r\n * ```\r\n *\r\n * Or when using a configuration object:\r\n *\r\n * ```javascript\r\n * this.load.svg({\r\n *     key: 'morty',\r\n *     url: 'images/Morty.svg',\r\n *     svgConfig: {\r\n *         width: 300,\r\n *         height: 600\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * Alternatively, you can just provide a scale factor instead:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.svg('morty', 'images/Morty.svg', { scale: 2.5 });\r\n * }\r\n * ```\r\n *\r\n * Or when using a configuration object:\r\n *\r\n * ```javascript\r\n * this.load.svg({\r\n *     key: 'morty',\r\n *     url: 'images/Morty.svg',\r\n *     svgConfig: {\r\n *         scale: 2.5\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * If scale, width and height values are all given, the scale has priority and the width and height values are ignored.\r\n *\r\n * Note: The ability to load this type of file will only be available if the SVG File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#svg\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SVGFileConfig|Phaser.Types.Loader.FileTypes.SVGFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.svg`, i.e. if `key` was \"alien\" then the URL will be \"alien.svg\".\r\n * @param {Phaser.Types.Loader.FileTypes.SVGSizeConfig} [svgConfig] - The svg size configuration object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('svg', function (key, url, svgConfig, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new SVGFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new SVGFile(this, key, url, svgConfig, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = SVGFile;\r\n\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * An external Scene JavaScript File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#sceneFile method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#sceneFile.\r\n *\r\n * @class SceneFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.16.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SceneFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar SceneFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function SceneFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'text',\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SceneFile#onProcess\r\n     * @since 3.16.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SceneFile#addToCache\r\n     * @since 3.16.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var code = this.data.concat('(function(){\\n' + 'return new ' + this.key + '();\\n' + '}).call(this);');\r\n\r\n        //  Stops rollup from freaking out during build\r\n        var eval2 = eval;\r\n\r\n        this.loader.sceneManager.add(this.key, eval2(code));\r\n\r\n        this.complete = true;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an external Scene file, or array of Scene files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.sceneFile('Level1', 'src/Level1.js');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Scene Manager upon a successful load.\r\n *\r\n * For a Scene File it's vitally important that the key matches the class name in the JavaScript file.\r\n *\r\n * For example here is the source file:\r\n *\r\n * ```javascript\r\n * class ExternalScene extends Phaser.Scene {\r\n *\r\n *     constructor ()\r\n *     {\r\n *         super('myScene');\r\n *     }\r\n *\r\n * }\r\n * ```\r\n *\r\n * Because the class is called `ExternalScene` that is the exact same key you must use when loading it:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.sceneFile('ExternalScene', 'src/yourScene.js');\r\n * }\r\n * ```\r\n *\r\n * The key that is used within the Scene Manager can either be set to the same, or you can override it in the Scene\r\n * constructor, as we've done in the example above, where the Scene key was changed to `myScene`.\r\n *\r\n * The key should be unique both in terms of files being loaded and Scenes already present in the Scene Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Scene Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.sceneFile({\r\n *     key: 'Level1',\r\n *     url: 'src/Level1.js'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.SceneFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will be added to the Scene Manager.\r\n *\r\n * ```javascript\r\n * this.load.sceneFile('Level1', 'src/Level1.js');\r\n * // and later in your game ...\r\n * this.scene.start('Level1');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `WORLD1.` and the key was `Story` the final key will be `WORLD1.Story` and\r\n * this is what you would use to retrieve the text from the Scene Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.js\". It will always add `.js` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Scene File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#sceneFile\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.16.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SceneFileConfig|Phaser.Types.Loader.FileTypes.SceneFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('sceneFile', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new SceneFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new SceneFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = SceneFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Scene Plugin Script File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#scenePlugin method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#scenePlugin.\r\n *\r\n * @class ScenePluginFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.8.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ScenePluginFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {string} [systemKey] - If this plugin is to be added to Scene.Systems, this is the property key for it.\r\n * @param {string} [sceneKey] - If this plugin is to be added to the Scene, this is the property key for it.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar ScenePluginFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function ScenePluginFile (loader, key, url, systemKey, sceneKey, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            systemKey = GetFastValue(config, 'systemKey');\r\n            sceneKey = GetFastValue(config, 'sceneKey');\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'scenePlugin',\r\n            cache: false,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                systemKey: systemKey,\r\n                sceneKey: sceneKey\r\n            }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        // If the url variable refers to a class, add the plugin directly\r\n        if (typeof url === 'function')\r\n        {\r\n            this.data = url;\r\n\r\n            this.state = CONST.FILE_POPULATED;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ScenePluginFile#onProcess\r\n     * @since 3.8.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        var pluginManager = this.loader.systems.plugins;\r\n        var config = this.config;\r\n\r\n        var key = this.key;\r\n        var systemKey = GetFastValue(config, 'systemKey', key);\r\n        var sceneKey = GetFastValue(config, 'sceneKey', key);\r\n\r\n        if (this.state === CONST.FILE_POPULATED)\r\n        {\r\n            pluginManager.installScenePlugin(systemKey, this.data, sceneKey, this.loader.scene, true);\r\n        }\r\n        else\r\n        {\r\n            //  Plugin added via a js file\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            this.data = document.createElement('script');\r\n            this.data.language = 'javascript';\r\n            this.data.type = 'text/javascript';\r\n            this.data.defer = false;\r\n            this.data.text = this.xhrLoader.responseText;\r\n\r\n            document.head.appendChild(this.data);\r\n\r\n            pluginManager.installScenePlugin(systemKey, window[this.key], sceneKey, this.loader.scene, true);\r\n        }\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Scene Plugin Script file, or array of plugin files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.scenePlugin('ModPlayer', 'plugins/ModPlayer.js', 'modPlayer', 'mods');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.scenePlugin({\r\n *     key: 'modplayer',\r\n *     url: 'plugins/ModPlayer.js'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.ScenePluginFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be converted into a script element\r\n * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to\r\n * false and then the resulting element will be appended to `document.head`. Any code then in the\r\n * script will be executed. It will then be passed to the Phaser PluginCache.register method.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.js\". It will always add `.js` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Script File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#scenePlugin\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.8.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ScenePluginFileConfig|Phaser.Types.Loader.FileTypes.ScenePluginFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(string|function)} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\". Or, set to a plugin function.\r\n * @param {string} [systemKey] - If this plugin is to be added to Scene.Systems, this is the property key for it.\r\n * @param {string} [sceneKey] - If this plugin is to be added to the Scene, this is the property key for it.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('scenePlugin', function (key, url, systemKey, sceneKey, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new ScenePluginFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new ScenePluginFile(this, key, url, systemKey, sceneKey, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = ScenePluginFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Script File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#script method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#script.\r\n *\r\n * @class ScriptFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ScriptFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar ScriptFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function ScriptFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'script',\r\n            cache: false,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ScriptFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = document.createElement('script');\r\n        this.data.language = 'javascript';\r\n        this.data.type = 'text/javascript';\r\n        this.data.defer = false;\r\n        this.data.text = this.xhrLoader.responseText;\r\n\r\n        document.head.appendChild(this.data);\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Script file, or array of Script files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.script('aliens', 'lib/aliens.js');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.script({\r\n *     key: 'aliens',\r\n *     url: 'lib/aliens.js'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.ScriptFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be converted into a script element\r\n * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to\r\n * false and then the resulting element will be appended to `document.head`. Any code then in the\r\n * script will be executed.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.js\". It will always add `.js` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Script File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#script\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ScriptFileConfig|Phaser.Types.Loader.FileTypes.ScriptFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('script', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new ScriptFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new ScriptFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = ScriptFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar ImageFile = require('./ImageFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single Sprite Sheet Image File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#spritesheet method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#spritesheet.\r\n *\r\n * @class SpriteSheetFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar SpriteSheetFile = new Class({\r\n\r\n    Extends: ImageFile,\r\n\r\n    initialize:\r\n\r\n    function SpriteSheetFile (loader, key, url, frameConfig, xhrSettings)\r\n    {\r\n        ImageFile.call(this, loader, key, url, xhrSettings, frameConfig);\r\n\r\n        this.type = 'spritesheet';\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SpriteSheetFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture = this.cache.addSpriteSheet(this.key, this.data, this.config);\r\n\r\n        this.pendingDestroy(texture);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Sprite Sheet Image, or array of Sprite Sheet Images, to the current load queue.\r\n *\r\n * The term 'Sprite Sheet' in Phaser means a fixed-size sheet. Where every frame in the sheet is the exact same size,\r\n * and you reference those frames using numbers, not frame names. This is not the same thing as a Texture Atlas, where\r\n * the frames are packed in a way where they take up the least amount of space, and are referenced by their names,\r\n * not numbers. Some articles and software use the term 'Sprite Sheet' to mean Texture Atlas, so please be aware of\r\n * what sort of file you're actually trying to load.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.spritesheet('bot', 'images/robot.png', { frameWidth: 32, frameHeight: 38 });\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n * \r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n * If you try to load an animated gif only the first frame will be rendered. Browsers do not natively support playback\r\n * of animated gifs to Canvas elements.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n * \r\n * ```javascript\r\n * this.load.spritesheet({\r\n *     key: 'bot',\r\n *     url: 'images/robot.png',\r\n *     frameConfig: {\r\n *         frameWidth: 32,\r\n *         frameHeight: 38,\r\n *         startFrame: 0,\r\n *         endFrame: 8\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n * \r\n * ```javascript\r\n * this.load.spritesheet('bot', 'images/robot.png', { frameWidth: 32, frameHeight: 38 });\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'bot', 0);\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `PLAYER.` and the key was `Running` the final key will be `PLAYER.Running` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n * \r\n * ```javascript\r\n * this.load.spritesheet('logo', [ 'images/AtariLogo.png', 'images/AtariLogo-n.png' ], { frameWidth: 256, frameHeight: 80 });\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n * \r\n * ```javascript\r\n * this.load.spritesheet({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png',\r\n *     normalMap: 'images/AtariLogo-n.png',\r\n *     frameConfig: {\r\n *         frameWidth: 256,\r\n *         frameHeight: 80\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n * \r\n * Note: The ability to load this type of file will only be available if the Sprite Sheet File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#spritesheet\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig|Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object. At a minimum it should have a `frameWidth` property.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('spritesheet', function (key, url, frameConfig, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new SpriteSheetFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new SpriteSheetFile(this, key, url, frameConfig, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = SpriteSheetFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Text File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#text method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#text.\r\n *\r\n * @class TextFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TextFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar TextFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function TextFile (loader, key, url, xhrSettings)\r\n    {\r\n        var type = 'text';\r\n        var extension = 'txt';\r\n        var cache = loader.cacheManager.text;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            type = GetFastValue(config, 'type', type);\r\n            cache = GetFastValue(config, 'cache', cache);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: type,\r\n            cache: cache,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TextFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Text file, or array of Text files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.text('story', 'files/IntroStory.txt');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Text Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Text Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Text Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.text({\r\n *     key: 'story',\r\n *     url: 'files/IntroStory.txt'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.TextFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.text('story', 'files/IntroStory.txt');\r\n * // and later in your game ...\r\n * var data = this.cache.text.get('story');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the text from the Text Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.txt\". It will always add `.txt` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Text File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#text\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TextFileConfig|Phaser.Types.Loader.FileTypes.TextFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('text', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new TextFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new TextFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = TextFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar TILEMAP_FORMATS = require('../../tilemaps/Formats');\r\n\r\n/**\r\n * @classdesc\r\n * A single Tilemap CSV File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#tilemapCSV method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#tilemapCSV.\r\n *\r\n * @class TilemapCSVFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.csv`, i.e. if `key` was \"alien\" then the URL will be \"alien.csv\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar TilemapCSVFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function TilemapCSVFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'csv';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'tilemapCSV',\r\n            cache: loader.cacheManager.tilemap,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        this.tilemapFormat = TILEMAP_FORMATS.CSV;\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TilemapCSVFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TilemapCSVFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var tiledata = { format: this.tilemapFormat, data: this.data };\r\n\r\n        this.cache.add(this.key, tiledata);\r\n\r\n        this.pendingDestroy(tiledata);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a CSV Tilemap file, or array of CSV files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.tilemapCSV('level1', 'maps/Level1.csv');\r\n * }\r\n * ```\r\n *\r\n * Tilemap CSV data can be created in a text editor, or a 3rd party app that exports as CSV.\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Text Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.tilemapCSV({\r\n *     key: 'level1',\r\n *     url: 'maps/Level1.csv'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.tilemapCSV('level1', 'maps/Level1.csv');\r\n * // and later in your game ...\r\n * var map = this.make.tilemap({ key: 'level1' });\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the text from the Tilemap Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"level\"\r\n * and no URL is given then the Loader will set the URL to be \"level.csv\". It will always add `.csv` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Tilemap CSV File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#tilemapCSV\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig|Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.csv`, i.e. if `key` was \"alien\" then the URL will be \"alien.csv\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('tilemapCSV', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new TilemapCSVFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new TilemapCSVFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = TilemapCSVFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar TILEMAP_FORMATS = require('../../tilemaps/Formats');\r\n\r\n/**\r\n * @classdesc\r\n * A single Impact.js Tilemap JSON File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#tilemapImpact method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#tilemapImpact.\r\n *\r\n * @class TilemapImpactFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar TilemapImpactFile = new Class({\r\n\r\n    Extends: JSONFile,\r\n\r\n    initialize:\r\n\r\n    function TilemapImpactFile (loader, key, url, xhrSettings)\r\n    {\r\n        JSONFile.call(this, loader, key, url, xhrSettings);\r\n\r\n        this.type = 'tilemapJSON';\r\n\r\n        this.cache = loader.cacheManager.tilemap;\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TilemapImpactFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var tiledata = { format: TILEMAP_FORMATS.WELTMEISTER, data: this.data };\r\n\r\n        this.cache.add(this.key, tiledata);\r\n\r\n        this.pendingDestroy(tiledata);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an Impact.js Tilemap file, or array of map files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.tilemapImpact('level1', 'maps/Level1.json');\r\n * }\r\n * ```\r\n *\r\n * Impact Tilemap data is created the Impact.js Map Editor called Weltmeister.\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Text Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.tilemapImpact({\r\n *     key: 'level1',\r\n *     url: 'maps/Level1.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.tilemapImpact('level1', 'maps/Level1.json');\r\n * // and later in your game ...\r\n * var map = this.make.tilemap({ key: 'level1' });\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the text from the Tilemap Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"level\"\r\n * and no URL is given then the Loader will set the URL to be \"level.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Tilemap Impact File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#tilemapImpact\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.7.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig|Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('tilemapImpact', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new TilemapImpactFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new TilemapImpactFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = TilemapImpactFile;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar FileTypesManager = require('../FileTypesManager');\nvar JSONFile = require('./JSONFile.js');\nvar TILEMAP_FORMATS = require('../../tilemaps/Formats');\n\n/**\n * @classdesc\n * A single Tiled Tilemap JSON File suitable for loading by the Loader.\n *\n * These are created when you use the Phaser.Loader.LoaderPlugin#tilemapTiledJSON method and are not typically created directly.\n *\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#tilemapTiledJSON.\n *\n * @class TilemapJSONFile\n * @extends Phaser.Loader.File\n * @memberof Phaser.Loader.FileTypes\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig)} key - The key to use for this file, or a file configuration object.\n * @param {object|string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\n */\nvar TilemapJSONFile = new Class({\n\n    Extends: JSONFile,\n\n    initialize:\n\n    function TilemapJSONFile (loader, key, url, xhrSettings)\n    {\n        JSONFile.call(this, loader, key, url, xhrSettings);\n\n        this.type = 'tilemapJSON';\n\n        this.cache = loader.cacheManager.tilemap;\n    },\n\n    /**\n     * Adds this file to its target cache upon successful loading and processing.\n     *\n     * @method Phaser.Loader.FileTypes.TilemapJSONFile#addToCache\n     * @since 3.7.0\n     */\n    addToCache: function ()\n    {\n        var tiledata = { format: TILEMAP_FORMATS.TILED_JSON, data: this.data };\n\n        this.cache.add(this.key, tiledata);\n\n        this.pendingDestroy(tiledata);\n    }\n\n});\n\n/**\n * Adds a Tiled JSON Tilemap file, or array of map files, to the current load queue.\n *\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\n *\n * ```javascript\n * function preload ()\n * {\n *     this.load.tilemapTiledJSON('level1', 'maps/Level1.json');\n * }\n * ```\n *\n * The Tilemap data is created using the Tiled Map Editor and selecting JSON as the export format.\n *\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\n * loaded.\n *\n * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.\n * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\n * then remove it from the Text Cache first, before loading a new one.\n *\n * Instead of passing arguments you can pass a configuration object, such as:\n *\n * ```javascript\n * this.load.tilemapTiledJSON({\n *     key: 'level1',\n *     url: 'maps/Level1.json'\n * });\n * ```\n *\n * See the documentation for `Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig` for more details.\n *\n * Once the file has finished loading you can access it from its Cache using its key:\n *\n * ```javascript\n * this.load.tilemapTiledJSON('level1', 'maps/Level1.json');\n * // and later in your game ...\n * var map = this.make.tilemap({ key: 'level1' });\n * ```\n *\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\n * this is what you would use to retrieve the text from the Tilemap Cache.\n *\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n *\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"level\"\n * and no URL is given then the Loader will set the URL to be \"level.json\". It will always add `.json` as the extension, although\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\n *\n * Note: The ability to load this type of file will only be available if the Tilemap JSON File type has been built into Phaser.\n * It is available in the default build but can be excluded from custom builds.\n *\n * @method Phaser.Loader.LoaderPlugin#tilemapTiledJSON\n * @fires Phaser.Loader.LoaderPlugin#ADD\n * @since 3.0.0\n *\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig|Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\n * @param {object|string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\n *\n * @return {this} The Loader instance.\n */\nFileTypesManager.register('tilemapTiledJSON', function (key, url, xhrSettings)\n{\n    if (Array.isArray(key))\n    {\n        for (var i = 0; i < key.length; i++)\n        {\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\n            this.addFile(new TilemapJSONFile(this, key[i]));\n        }\n    }\n    else\n    {\n        this.addFile(new TilemapJSONFile(this, key, url, xhrSettings));\n    }\n\n    return this;\n});\n\nmodule.exports = TilemapJSONFile;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile.js');\r\nvar TextFile = require('./TextFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single text file based Unity Texture Atlas File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#unityAtlas method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#unityAtlas.\r\n *\r\n * @class UnityAtlasFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas data file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas data file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar UnityAtlasFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function UnityAtlasFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n    {\r\n        var image;\r\n        var data;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            image = new ImageFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'textureURL'),\r\n                extension: GetFastValue(config, 'textureExtension', 'png'),\r\n                normalMap: GetFastValue(config, 'normalMap'),\r\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\r\n            });\r\n\r\n            data = new TextFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'atlasURL'),\r\n                extension: GetFastValue(config, 'atlasExtension', 'txt'),\r\n                xhrSettings: GetFastValue(config, 'atlasXhrSettings')\r\n            });\r\n        }\r\n        else\r\n        {\r\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n            data = new TextFile(loader, key, atlasURL, atlasXhrSettings);\r\n        }\r\n\r\n        if (image.linkFile)\r\n        {\r\n            //  Image has a normal map\r\n            MultiFile.call(this, loader, 'unityatlas', key, [ image, data, image.linkFile ]);\r\n        }\r\n        else\r\n        {\r\n            MultiFile.call(this, loader, 'unityatlas', key, [ image, data ]);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.UnityAtlasFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var image = this.files[0];\r\n            var text = this.files[1];\r\n            var normalMap = (this.files[2]) ? this.files[2].data : null;\r\n\r\n            this.loader.textureManager.addUnityAtlas(image.key, image.data, text.data, normalMap);\r\n\r\n            text.pendingDestroy();\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Unity YAML based Texture Atlas, or array of atlases, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.unityAtlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.txt');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the atlas data to be provided in a YAML formatted text file as exported from Unity.\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.unityAtlas({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     atlasURL: 'images/MainMenu.txt'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig` for more details.\r\n *\r\n * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.unityAtlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'mainmenu', 'background');\r\n * ```\r\n *\r\n * To get a list of all available frames within an atlas please consult your Texture Atlas software.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.unityAtlas('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.txt');\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.unityAtlas({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     normalMap: 'images/MainMenu-n.png',\r\n *     atlasURL: 'images/MainMenu.txt'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Unity Atlas File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#unityAtlas\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig|Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas data file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas data file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('unityAtlas', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new UnityAtlasFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new UnityAtlasFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = UnityAtlasFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetURL = require('../GetURL');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Video File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#video method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#video.\r\n *\r\n * @class VideoFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.20.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.VideoFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {any} [urlConfig] - The absolute or relative URL to load this file from in a config object.\r\n * @param {string} [loadEvent] - The load event to listen for when _not_ loading as a blob. Either 'loadeddata', 'canplay' or 'canplaythrough'.\r\n * @param {boolean} [asBlob] - Load the video as a data blob, or via the Video element?\r\n * @param {boolean} [noAudio] - Does the video have an audio track? If not you can enable auto-playing on it.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar VideoFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    //  URL is an object created by VideoFile.getVideoURL\r\n    function VideoFile (loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings)\r\n    {\r\n        if (loadEvent === undefined) { loadEvent = 'loadeddata'; }\r\n        if (asBlob === undefined) { asBlob = false; }\r\n        if (noAudio === undefined) { noAudio = false; }\r\n\r\n        if (loadEvent !== 'loadeddata' && loadEvent !== 'canplay' && loadEvent !== 'canplaythrough')\r\n        {\r\n            loadEvent = 'loadeddata';\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'video',\r\n            cache: loader.cacheManager.video,\r\n            extension: urlConfig.type,\r\n            responseType: 'blob',\r\n            key: key,\r\n            url: urlConfig.url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                loadEvent: loadEvent,\r\n                asBlob: asBlob,\r\n                noAudio: noAudio\r\n            }\r\n        };\r\n\r\n        this.onLoadCallback = this.onVideoLoadHandler.bind(this);\r\n        this.onErrorCallback = this.onVideoErrorHandler.bind(this);\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#onProcess\r\n     * @since 3.20.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        if (!this.config.asBlob)\r\n        {\r\n            this.onProcessComplete();\r\n\r\n            return;\r\n        }\r\n\r\n        //  Load Video as blob\r\n\r\n        var video = this.createVideoElement();\r\n\r\n        this.data = video;\r\n\r\n        var _this = this;\r\n\r\n        this.data.onloadeddata = function ()\r\n        {\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessError();\r\n        };\r\n\r\n        File.createObjectURL(video, this.xhrLoader.response, '');\r\n\r\n        video.load();\r\n    },\r\n\r\n    /**\r\n     * Creates a Video Element within the DOM.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#createVideoElement\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @return {HTMLVideoElement} The newly created Video element.\r\n     */\r\n    createVideoElement: function ()\r\n    {\r\n        var video = document.createElement('video');\r\n\r\n        video.controls = false;\r\n        video.crossOrigin = this.loader.crossOrigin;\r\n\r\n        if (this.config.noAudio)\r\n        {\r\n            video.muted = true;\r\n            video.defaultMuted = true;\r\n\r\n            video.setAttribute('autoplay', 'autoplay');\r\n        }\r\n\r\n        video.setAttribute('playsinline', 'playsinline');\r\n        video.setAttribute('preload', 'auto');\r\n\r\n        return video;\r\n    },\r\n\r\n    /**\r\n     * Internal load event callback.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#onVideoLoadHandler\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.\r\n     */\r\n    onVideoLoadHandler: function (event)\r\n    {\r\n        var video = event.target;\r\n\r\n        video.removeEventListener(this.config.loadEvent, this.onLoadCallback, true);\r\n        video.removeEventListener('error', this.onErrorCallback, true);\r\n\r\n        this.data = video;\r\n\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, true);\r\n    },\r\n\r\n    /**\r\n     * Internal load error event callback.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#onVideoErrorHandler\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.\r\n     */\r\n    onVideoErrorHandler: function (event)\r\n    {\r\n        var video = event.target;\r\n\r\n        if (video)\r\n        {\r\n            video.removeEventListener(this.config.loadEvent, this.onLoadCallback, true);\r\n            video.removeEventListener('error', this.onErrorCallback, true);\r\n        }\r\n\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, false);\r\n    },\r\n\r\n    /**\r\n     * Called by the Loader, starts the actual file downloading.\r\n     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.\r\n     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#load\r\n     * @since 3.20.0\r\n     */\r\n    load: function ()\r\n    {\r\n        var loadEvent = this.config.loadEvent;\r\n\r\n        if (this.config.asBlob)\r\n        {\r\n            File.prototype.load.call(this);\r\n        }\r\n        else\r\n        {\r\n            this.percentComplete = 0;\r\n\r\n            var video = this.createVideoElement();\r\n\r\n            video.addEventListener(loadEvent, this.onLoadCallback, true);\r\n            video.addEventListener('error', this.onErrorCallback, true);\r\n\r\n            video.src = GetURL(this, this.loader.baseURL);\r\n\r\n            video.load();\r\n        }\r\n    }\r\n\r\n});\r\n\r\nVideoFile.create = function (loader, key, urls, loadEvent, asBlob, noAudio, xhrSettings)\r\n{\r\n    var game = loader.systems.game;\r\n\r\n    //  url may be inside key, which may be an object\r\n    if (IsPlainObject(key))\r\n    {\r\n        urls = GetFastValue(key, 'url', []);\r\n        loadEvent = GetFastValue(key, 'loadEvent', 'loadeddata');\r\n        asBlob = GetFastValue(key, 'asBlob', false);\r\n        noAudio = GetFastValue(key, 'noAudio', false);\r\n        xhrSettings = GetFastValue(key, 'xhrSettings');\r\n        key = GetFastValue(key, 'key');\r\n    }\r\n\r\n    var urlConfig = VideoFile.getVideoURL(game, urls);\r\n    \r\n    if (urlConfig)\r\n    {\r\n        return new VideoFile(loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings);\r\n    }\r\n};\r\n\r\nVideoFile.getVideoURL = function (game, urls)\r\n{\r\n    if (!Array.isArray(urls))\r\n    {\r\n        urls = [ urls ];\r\n    }\r\n\r\n    for (var i = 0; i < urls.length; i++)\r\n    {\r\n        var url = GetFastValue(urls[i], 'url', urls[i]);\r\n\r\n        if (url.indexOf('blob:') === 0)\r\n        {\r\n            return {\r\n                url: url,\r\n                type: ''\r\n            };\r\n        }\r\n\r\n        var videoType;\r\n\r\n        if (url.indexOf('data:') === 0)\r\n        {\r\n            videoType = url.split(',')[0].match(/\\/(.*?);/);\r\n        }\r\n        else\r\n        {\r\n            videoType = url.match(/\\.([a-zA-Z0-9]+)($|\\?)/);\r\n        }\r\n\r\n        videoType = GetFastValue(urls[i], 'type', (videoType) ? videoType[1] : '').toLowerCase();\r\n\r\n        if (game.device.video[videoType])\r\n        {\r\n            return {\r\n                url: url,\r\n                type: videoType\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Adds a Video file, or array of video files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.video('intro', [ 'video/level1.mp4', 'video/level1.webm', 'video/level1.mov' ]);\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Video Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Video Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Video Cache first, before loading a new one.\r\n  *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.video({\r\n *     key: 'intro',\r\n *     url: [ 'video/level1.mp4', 'video/level1.webm', 'video/level1.mov' ],\r\n *     asBlob: false,\r\n *     noAudio: true\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.VideoFileConfig` for more details.\r\n *\r\n * The URLs can be relative or absolute. If the URLs are relative the `Loader.baseURL` and `Loader.path` values will be prepended to them.\r\n *\r\n * Due to different browsers supporting different video file types you should usually provide your video files in a variety of formats.\r\n * mp4, mov and webm are the most common. If you provide an array of URLs then the Loader will determine which _one_ file to load based on\r\n * browser support, starting with the first in the array and progressing to the end.\r\n *\r\n * Unlike most asset-types, videos do not _need_ to be preloaded. You can create a Video Game Object and then call its `loadURL` method,\r\n * to load a video at run-time, rather than in advance.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Video File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#video\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.20.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.VideoFileConfig|Phaser.Types.Loader.FileTypes.VideoFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(string|string[])} [urls] - The absolute or relative URL to load the video files from.\r\n * @param {string} [loadEvent='loadeddata'] - The load event to listen for when _not_ loading as a blob. Either `loadeddata`, `canplay` or `canplaythrough`.\r\n * @param {boolean} [asBlob=false] - Load the video as a data blob, or stream it via the Video element?\r\n * @param {boolean} [noAudio=false] - Does the video have an audio track? If not you can enable auto-playing on it.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('video', function (key, urls, loadEvent, asBlob, noAudio, xhrSettings)\r\n{\r\n    var videoFile;\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            videoFile = VideoFile.create(this, key[i]);\r\n\r\n            if (videoFile)\r\n            {\r\n                this.addFile(videoFile);\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        videoFile = VideoFile.create(this, key, urls, loadEvent, asBlob, noAudio, xhrSettings);\r\n\r\n        if (videoFile)\r\n        {\r\n            this.addFile(videoFile);\r\n        }\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = VideoFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar ParseXML = require('../../dom/ParseXML');\r\n\r\n/**\r\n * @classdesc\r\n * A single XML File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#xml method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#xml.\r\n *\r\n * @class XMLFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.XMLFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar XMLFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function XMLFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'xml';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'xml',\r\n            cache: loader.cacheManager.xml,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.XMLFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = ParseXML(this.xhrLoader.responseText);\r\n\r\n        if (this.data)\r\n        {\r\n            this.onProcessComplete();\r\n        }\r\n        else\r\n        {\r\n            this.onProcessError();\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an XML file, or array of XML files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.xml('wavedata', 'files/AlienWaveData.xml');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n * \r\n * The key must be a unique String. It is used to add the file to the global XML Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the XML Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the XML Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n * \r\n * ```javascript\r\n * this.load.xml({\r\n *     key: 'wavedata',\r\n *     url: 'files/AlienWaveData.xml'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.XMLFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n * \r\n * ```javascript\r\n * this.load.xml('wavedata', 'files/AlienWaveData.xml');\r\n * // and later in your game ...\r\n * var data = this.cache.xml.get('wavedata');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the XML Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.xml\". It will always add `.xml` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the XML File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#xml\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.XMLFileConfig|Phaser.Types.Loader.FileTypes.XMLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('xml', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new XMLFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new XMLFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = XMLFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Loader.FileTypes\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    AnimationJSONFile: require('./AnimationJSONFile'),\r\n    AsepriteFile: require('./AsepriteFile'),\r\n    AtlasJSONFile: require('./AtlasJSONFile'),\r\n    AtlasXMLFile: require('./AtlasXMLFile'),\r\n    AudioFile: require('./AudioFile'),\r\n    AudioSpriteFile: require('./AudioSpriteFile'),\r\n    BinaryFile: require('./BinaryFile'),\r\n    BitmapFontFile: require('./BitmapFontFile'),\r\n    CompressedTextureFile: require('./CompressedTextureFile'),\r\n    CSSFile: require('./CSSFile'),\r\n    GLSLFile: require('./GLSLFile'),\r\n    HTML5AudioFile: require('./HTML5AudioFile'),\r\n    HTMLFile: require('./HTMLFile'),\r\n    HTMLTextureFile: require('./HTMLTextureFile'),\r\n    ImageFile: require('./ImageFile'),\r\n    JSONFile: require('./JSONFile'),\r\n    MultiAtlasFile: require('./MultiAtlasFile'),\r\n    MultiScriptFile: require('./MultiScriptFile'),\r\n    OBJFile: require('./OBJFile'),\r\n    PackFile: require('./PackFile'),\r\n    PluginFile: require('./PluginFile'),\r\n    SceneFile: require('./SceneFile'),\r\n    ScenePluginFile: require('./ScenePluginFile'),\r\n    ScriptFile: require('./ScriptFile'),\r\n    SpriteSheetFile: require('./SpriteSheetFile'),\r\n    SVGFile: require('./SVGFile'),\r\n    TextFile: require('./TextFile'),\r\n    TilemapCSVFile: require('./TilemapCSVFile'),\r\n    TilemapImpactFile: require('./TilemapImpactFile'),\r\n    TilemapJSONFile: require('./TilemapJSONFile'),\r\n    UnityAtlasFile: require('./UnityAtlasFile'),\r\n    VideoFile: require('./VideoFile'),\r\n    XMLFile: require('./XMLFile')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Extend = require('../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.Loader\r\n */\r\n\r\nvar Loader = {\r\n\r\n    Events: require('./events'),\r\n\r\n    FileTypes: require('./filetypes'),\r\n\r\n    File: require('./File'),\r\n    FileTypesManager: require('./FileTypesManager'),\r\n    GetURL: require('./GetURL'),\r\n    LoaderPlugin: require('./LoaderPlugin'),\r\n    MergeXHRSettings: require('./MergeXHRSettings'),\r\n    MultiFile: require('./MultiFile'),\r\n    XHRLoader: require('./XHRLoader'),\r\n    XHRSettings: require('./XHRSettings')\r\n\r\n};\r\n\r\n//   Merge in the consts\r\nLoader = Extend(false, Loader, CONST);\r\n\r\nmodule.exports = Loader;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Formats\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * CSV Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.CSV\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    CSV: 0,\r\n\r\n    /**\r\n     * Tiled JSON Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.TILED_JSON\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    TILED_JSON: 1,\r\n\r\n    /**\r\n     * 2D Array Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.ARRAY_2D\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    ARRAY_2D: 2,\r\n\r\n    /**\r\n     * Weltmeister (Impact.js) Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.WELTMEISTER\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    WELTMEISTER: 3\r\n\r\n};\r\n"],"names":["getValue","node","attribute","parseInt","getAttribute","module","exports","xml","frame","xSpacing","ySpacing","texture","undefined","textureX","cutX","textureY","cutY","textureWidth","source","width","textureHeight","height","sourceIndex","data","info","getElementsByTagName","common","font","size","lineHeight","chars","letters","adjustForTrim","trimmed","top","left","i","length","charCode","letter","String","fromCharCode","gx","gy","gw","gh","x","y","u0","v0","u1","v1","centerX","Math","floor","centerY","xOffset","yOffset","xAdvance","kerning","charFrame","add","setUVs","kernings","kern","first","second","amount","Class","CONST","Events","GetFastValue","GetURL","MergeXHRSettings","XHRLoader","XHRSettings","File","initialize","loader","fileConfig","this","cache","type","key","loadKey","prefix","Error","url","path","match","src","xhrSettings","xhrLoader","state","FILE_POPULATED","FILE_PENDING","bytesTotal","bytesLoaded","percentComplete","crossOrigin","config","multiFile","linkFile","setLink","fileB","resetXHR","onload","onerror","onprogress","load","nextFile","FILE_LOADING","baseURL","indexOf","console","warn","xhr","onLoad","event","localFileOk","responseURL","target","status","success","readyState","FILE_LOADED","onError","onProgress","lengthComputable","loaded","total","min","emit","FILE_PROGRESS","onProcess","FILE_PROCESSING","onProcessComplete","FILE_COMPLETE","onFileComplete","fileProcessComplete","onProcessError","error","FILE_ERRORED","onFileFailed","hasCacheConflict","exists","addToCache","pendingDestroy","FILE_KEY_COMPLETE","flagForRemoval","destroy","createObjectURL","image","blob","defaultType","URL","reader","FileReader","removeAttribute","result","split","readAsDataURL","revokeObjectURL","file","CustomSet","EventEmitter","FileTypesManager","PluginCache","SceneEvents","LoaderPlugin","Extends","scene","call","gameConfig","sys","game","sceneConfig","settings","systems","cacheManager","textureManager","textures","sceneManager","install","setBaseURL","loaderBaseURL","setPath","loaderPath","setPrefix","loaderPrefix","maxParallelDownloads","loaderMaxParallelDownloads","loaderResponseType","loaderAsync","loaderUser","loaderPassword","loaderTimeout","loaderWithCredentials","loaderCrossOrigin","imageLoadType","loaderImageLoadType","totalToLoad","progress","list","inflight","queue","_deleteQueue","totalFailed","totalComplete","LOADER_IDLE","multiKeyIndex","events","once","BOOT","boot","on","START","pluginStart","DESTROY","SHUTDOWN","shutdown","substr","concat","setCORS","addFile","Array","isArray","item","keyExists","set","ADD","isLoading","updateProgress","keyConflict","iterate","addPack","pack","packKey","hasOwnProperty","currentBaseURL","currentPath","currentPrefix","Object","prototype","files","LOADER_LOADING","LOADER_PROCESSING","isReady","LOADER_COMPLETE","start","loadComplete","clear","checkLoadQueue","UPDATE","update","PROGRESS","each","delete","FILE_LOAD","FILE_LOAD_ERROR","isReadyToProcess","POST_PROCESS","off","iterateLocal","COMPLETE","saveJSON","filename","save","JSON","stringify","filetype","Blob","a","document","createElement","download","textContent","href","click","reset","LOADER_SHUTDOWN","LOADER_DESTROYED","register","Extend","global","local","output","setting","MultiFile","finalFiles","forEach","push","complete","pending","failed","addToMultiFile","globalXHRSettings","XMLHttpRequest","open","async","user","password","responseType","timeout","headers","setRequestHeader","header","headerValue","requestedWith","overrideMimeType","withCredentials","bind","send","FILE_FAILED","FILE_DESTROYED","JSONFile","LoaderEvents","AnimationJSONFile","dataKey","onLoadComplete","anims","fromJSON","ImageFile","IsPlainObject","AsepriteFile","textureURL","atlasURL","textureXhrSettings","atlasXhrSettings","extension","normalMap","json","addAtlas","multifile","AtlasJSONFile","XMLFile","AtlasXMLFile","addAtlasXML","HTML5AudioFile","AudioFile","urlConfig","audioContext","audio","context","_this","decodeAudioData","response","audioBuffer","e","message","create","urls","audioConfig","deviceAudio","device","getAudioURL","webAudio","disableWebAudio","sound","audioType","toLowerCase","audioFile","noAudio","audioData","AudioSpriteFile","jsonURL","audioURL","audioXhrSettings","jsonXhrSettings","resourceLoad","resources","fileA","gameAudioConfig","BinaryFile","dataType","binary","ctor","ParseXMLBitmapFont","BitmapFontFile","fontDataURL","fontDataXhrSettings","get","getFrame","bitmapFont","CSSFile","defer","innerHTML","responseText","head","appendChild","KTXParser","Merge","MultiAtlasFile","PVRParser","CompressedTextureFile","entry","multiAtlasURL","multi","addMultiToCache","textureData","renderer","supportsCompressedTexture","format","internalFormat","getCompressedTextureName","atlasData","addCompressedTexture","images","normalMaps","pos","t","addAtlasJSONArray","multiPath","multiBaseURL","textureBaseFormat","urlEntry","toUpperCase","Shader","GLSLFile","shaderType","shader","block","extractBlock","getShaderName","getShaderType","uniforms","getShaderUniforms","shaderSrc","has","fragmentSrc","vertexSrc","offset","headerSource","line","trim","substring","parse","headerStart","headerEnd","blockEnd","headerOpen","captureSource","shaderSource","join","locked","window","filesLoaded","filesTotal","oncanplaythrough","instances","Audio","dataset","name","slice","used","preload","setTimeout","HTMLFile","html","HTMLTextureFile","w","h","svg","Image","addImage","frameConfig","normalMapURL","useImageElementLoad","loadImage","onProcessImage","GetValue","fileJSON","ScriptFile","MultiScriptFile","scriptFile","toString","language","text","ParseObj","ParseObjMaterial","TextFile","OBJFile","objURL","matURL","flipUV","obj","mat","objData","materials","flipUVs","PackFile","PluginFile","mapping","pluginManager","plugins","plugin","SVGFile","svgConfig","scale","resize","svgXML","DOMParser","parseFromString","hasViewBox","hasAttribute","svgWidth","parseFloat","svgHeight","setAttribute","viewBox","XMLSerializer","serializeToString","retry","encodeURIComponent","SceneFile","code","eval2","eval","ScenePluginFile","systemKey","sceneKey","installScenePlugin","SpriteSheetFile","addSpriteSheet","TILEMAP_FORMATS","TilemapCSVFile","tilemap","tilemapFormat","CSV","tiledata","TilemapImpactFile","WELTMEISTER","TilemapJSONFile","TILED_JSON","UnityAtlasFile","addUnityAtlas","VideoFile","loadEvent","asBlob","video","onLoadCallback","onVideoLoadHandler","onErrorCallback","onVideoErrorHandler","createVideoElement","onloadeddata","controls","muted","defaultMuted","removeEventListener","addEventListener","getVideoURL","videoType","videoFile","ParseXML","Loader","FileTypes","ARRAY_2D"],"sourceRoot":""}