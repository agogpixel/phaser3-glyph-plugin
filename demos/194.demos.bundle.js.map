{"version":3,"file":"194.demos.bundle.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/Formats.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/ImageCollection.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/ObjectHelper.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/ParseToTilemap.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/Tile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/Tilemap.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/TilemapCreator.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/TilemapFactory.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/TilemapLayer.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/TilemapLayerCanvasRenderer.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/TilemapLayerRender.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/TilemapLayerWebGLRenderer.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/Tileset.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/CalculateFacesAt.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/CalculateFacesWithin.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/CheckIsoBounds.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/Copy.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/CreateFromTiles.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/CullBounds.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/CullTiles.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/Fill.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/FilterTiles.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/FindByIndex.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/FindTile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/ForEachTile.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/GetCullTilesFunction.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/GetTileAt.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/GetTileAtWorldXY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/GetTileToWorldXFunction.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/GetTileToWorldXYFunction.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/GetTileToWorldYFunction.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/GetTilesWithin.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/GetTilesWithinShape.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/GetTilesWithinWorldXY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/GetWorldToTileXFunction.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/GetWorldToTileXYFunction.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/GetWorldToTileYFunction.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/HasTileAt.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/HasTileAtWorldXY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/HexagonalCullBounds.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/HexagonalCullTiles.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/HexagonalTileToWorldXY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/HexagonalTileToWorldY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/HexagonalWorldToTileXY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/HexagonalWorldToTileY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/IsInLayerBounds.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/IsometricCullTiles.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/IsometricTileToWorldXY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/IsometricWorldToTileXY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/PutTileAt.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/PutTileAtWorldXY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/PutTilesAt.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/Randomize.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/RemoveTileAt.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/RemoveTileAtWorldXY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/RenderDebug.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/ReplaceByIndex.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/RunCull.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/SetCollision.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/SetCollisionBetween.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/SetCollisionByExclusion.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/SetCollisionByProperty.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/SetCollisionFromCollisionGroup.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/SetLayerCollisionIndex.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/SetTileCollision.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/SetTileIndexCallback.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/SetTileLocationCallback.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/Shuffle.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/StaggeredCullBounds.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/StaggeredCullTiles.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/StaggeredTileToWorldXY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/StaggeredTileToWorldY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/StaggeredWorldToTileXY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/StaggeredWorldToTileY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/SwapByIndex.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/TileToWorldX.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/TileToWorldXY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/TileToWorldY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/WeightedRandomize.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/WorldToTileX.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/WorldToTileXY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/WorldToTileY.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/components/index.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/const/ORIENTATION_CONST.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/const/index.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/index.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/mapdata/LayerData.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/mapdata/MapData.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/mapdata/ObjectLayer.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/FromOrientationString.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/Parse.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/Parse2DArray.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/ParseCSV.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/impact/ParseTileLayers.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/impact/ParseTilesets.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/impact/ParseWeltmeister.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/impact/index.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/index.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/tiled/AssignTileProperties.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/tiled/Base64Decode.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/tiled/BuildTilesetIndex.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/tiled/CreateGroupLayer.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseGID.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseImageLayers.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseJSONTiled.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseObject.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseObjectLayers.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseTileLayers.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseTilesets.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseWangsets.js","webpack://@agogpixel/phaser3-glyph-plugin/./node_modules/phaser/src/tilemaps/parsers/tiled/index.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Formats\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * CSV Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.CSV\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    CSV: 0,\r\n\r\n    /**\r\n     * Tiled JSON Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.TILED_JSON\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    TILED_JSON: 1,\r\n\r\n    /**\r\n     * 2D Array Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.ARRAY_2D\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    ARRAY_2D: 2,\r\n\r\n    /**\r\n     * Weltmeister (Impact.js) Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.WELTMEISTER\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    WELTMEISTER: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * An Image Collection is a special Tile Set containing multiple images, with no slicing into each image.\r\n *\r\n * Image Collections are normally created automatically when Tiled data is loaded.\r\n *\r\n * @class ImageCollection\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n * \r\n * @param {string} name - The name of the image collection in the map data.\r\n * @param {number} firstgid - The first image index this image collection contains.\r\n * @param {number} [width=32] - Width of widest image (in pixels).\r\n * @param {number} [height=32] - Height of tallest image (in pixels).\r\n * @param {number} [margin=0] - The margin around all images in the collection (in pixels).\r\n * @param {number} [spacing=0] - The spacing between each image in the collection (in pixels).\r\n * @param {object} [properties={}] - Custom Image Collection properties.\r\n */\r\nvar ImageCollection = new Class({\r\n\r\n    initialize:\r\n\r\n    function ImageCollection (name, firstgid, width, height, margin, spacing, properties)\r\n    {\r\n        if (width === undefined || width <= 0) { width = 32; }\r\n        if (height === undefined || height <= 0) { height = 32; }\r\n        if (margin === undefined) { margin = 0; }\r\n        if (spacing === undefined) { spacing = 0; }\r\n\r\n        /**\r\n         * The name of the Image Collection.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n        */\r\n        this.name = name;\r\n\r\n        /**\r\n         * The Tiled firstgid value.\r\n         * This is the starting index of the first image index this Image Collection contains.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#firstgid\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.firstgid = firstgid | 0;\r\n\r\n        /**\r\n         * The width of the widest image (in pixels).\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageWidth\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.imageWidth = width | 0;\r\n\r\n        /**\r\n         * The height of the tallest image (in pixels).\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageHeight\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.imageHeight = height | 0;\r\n\r\n        /**\r\n         * The margin around the images in the collection (in pixels).\r\n         * Use `setSpacing` to change.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageMarge\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.imageMargin = margin | 0;\r\n\r\n        /**\r\n         * The spacing between each image in the collection (in pixels).\r\n         * Use `setSpacing` to change.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageSpacing\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.imageSpacing = spacing | 0;\r\n\r\n        /**\r\n         * Image Collection-specific properties that are typically defined in the Tiled editor.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = properties || {};\r\n\r\n        /**\r\n         * The cached images that are a part of this collection.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#images\r\n         * @type {array}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.images = [];\r\n\r\n        /**\r\n         * The total number of images in the image collection.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#total\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.total = 0;\r\n    },\r\n\r\n    /**\r\n     * Returns true if and only if this image collection contains the given image index.\r\n     *\r\n     * @method Phaser.Tilemaps.ImageCollection#containsImageIndex\r\n     * @since 3.0.0\r\n     * \r\n     * @param {number} imageIndex - The image index to search for.\r\n     * \r\n     * @return {boolean} True if this Image Collection contains the given index.\r\n     */\r\n    containsImageIndex: function (imageIndex)\r\n    {\r\n        return (imageIndex >= this.firstgid && imageIndex < (this.firstgid + this.total));\r\n    },\r\n\r\n    /**\r\n     * Add an image to this Image Collection.\r\n     *\r\n     * @method Phaser.Tilemaps.ImageCollection#addImage\r\n     * @since 3.0.0\r\n     * \r\n     * @param {number} gid - The gid of the image in the Image Collection.\r\n     * @param {string} image - The the key of the image in the Image Collection and in the cache.\r\n     *\r\n     * @return {Phaser.Tilemaps.ImageCollection} This ImageCollection object.\r\n     */\r\n    addImage: function (gid, image)\r\n    {\r\n        this.images.push({ gid: gid, image: image });\r\n        this.total++;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ImageCollection;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2021 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * The ObjectHelper helps tie objects with `gids` into the tileset\r\n * that sits behind them.\r\n *\r\n * @class ObjectHelper\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.60.0\r\n *\r\n * @param {Phaser.Tilemaps.Tileset[]} tilesets - The backing tileset data.\r\n */\r\nvar ObjectHelper = new Class({\r\n\r\n    initialize:\r\n\r\n    function ObjectHelper (tilesets)\r\n    {\r\n        /**\r\n         * The Tile GIDs array.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectHelper#gids\r\n         * @type {array}\r\n         * @since 3.60.0\r\n         */\r\n        this.gids = [];\r\n\r\n        if (tilesets !== undefined)\r\n        {\r\n            for (var t = 0; t < tilesets.length; ++t)\r\n            {\r\n                var tileset = tilesets[t];\r\n\r\n                for (var i = 0; i < tileset.total; ++i)\r\n                {\r\n                    this.gids[tileset.firstgid + i] = tileset;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The Tile GIDs array.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectHelper#_gids\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.60.0\r\n         */\r\n        this._gids = this.gids;\r\n    },\r\n\r\n    /**\r\n     * Enabled if the object helper reaches in to tilesets for data.\r\n     * Disabled if it only uses data directly on a gid object.\r\n     *\r\n     * @name Phaser.Tilemaps.ObjectHelper#enabled\r\n     * @type {boolean}\r\n     * @since 3.60.0\r\n     */\r\n    enabled: {\r\n\r\n        get: function ()\r\n        {\r\n            return !!this.gids;\r\n        },\r\n\r\n        set: function (v)\r\n        {\r\n            this.gids = v ? this._gids : undefined;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Gets the Tiled `type` field value from the object or the `gid` behind it.\r\n     *\r\n     * @method Phaser.Tilemaps.ObjectHelper#getTypeIncludingTile\r\n     * @since 3.60.0\r\n     *\r\n     * @param {Phaser.Types.Tilemaps.TiledObject} obj - The Tiled object to investigate.\r\n     *\r\n     * @return {?string} The `type` of the object, the tile behind the `gid` of the object, or `undefined`.\r\n     */\r\n    getTypeIncludingTile: function (obj)\r\n    {\r\n        if (obj.type !== undefined && obj.type !== '')\r\n        {\r\n            return obj.type;\r\n        }\r\n\r\n        if (!this.gids || obj.gid === undefined)\r\n        {\r\n            return undefined;\r\n        }\r\n\r\n        var tileset = this.gids[obj.gid];\r\n\r\n        if (!tileset)\r\n        {\r\n            return undefined;\r\n        }\r\n\r\n        var tileData = tileset.getTileData(obj.gid);\r\n\r\n        if (!tileData)\r\n        {\r\n            return undefined;\r\n        }\r\n\r\n        return tileData.type;\r\n    },\r\n\r\n    /**\r\n     * Sets the sprite texture data as specified (usually in a config) or, failing that,\r\n     * as specified in the `gid` of the object being loaded (if any).\r\n     *\r\n     * This fallback will only work if the tileset was loaded as a spritesheet matching\r\n     * the geometry of sprites fed into tiled, so that, for example: \"tile id #`3`\"\" within\r\n     * the tileset is the same as texture frame `3` from the image of the tileset.\r\n     *\r\n     * @method Phaser.Tilemaps.ObjectHelper#setTextureAndFrame\r\n     * @since 3.60.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The Game Object to modify.\r\n     * @param {string|Phaser.Textures.Texture} [key] - The texture key to set (or else the `obj.gid`'s tile is used if available).\r\n     * @param {string|number|Phaser.Textures.Frame} [frame] - The frames key to set (or else the `obj.gid`'s tile is used if available).\r\n     * @param {Phaser.Types.Tilemaps.TiledObject} [obj] - The Tiled object for fallback.\r\n     */\r\n    setTextureAndFrame: function (sprite, key, frame, obj)\r\n    {\r\n        if ((key === null) && this.gids && obj.gid !== undefined)\r\n        {\r\n            var tileset = this.gids[obj.gid];\r\n\r\n            if (tileset)\r\n            {\r\n                if (key === null && tileset.image !== undefined)\r\n                {\r\n                    key = tileset.image.key;\r\n                }\r\n\r\n                if (frame === null)\r\n                {\r\n                    // This relies on the tileset texture *also* having been loaded as a spritesheet. This isn't guaranteed!\r\n                    frame = obj.gid - tileset.firstgid;\r\n                }\r\n\r\n                // If we can't satisfy the request, probably best to null it out rather than set a whole spritesheet or something.\r\n                if (!sprite.scene.textures.getFrame(key, frame))\r\n                {\r\n                    key = null;\r\n                    frame = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        sprite.setTexture(key, frame);\r\n    },\r\n\r\n    /**\r\n     * Sets the `sprite.data` field from the tiled properties on the object and its tile (if any).\r\n     *\r\n     * @method Phaser.Tilemaps.ObjectHelper#setPropertiesFromTiledObject\r\n     * @since 3.60.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite\r\n     * @param {Phaser.Types.Tilemaps.TiledObject} obj\r\n     */\r\n    setPropertiesFromTiledObject: function (sprite, obj)\r\n    {\r\n        if (this.gids !== undefined && obj.gid !== undefined)\r\n        {\r\n            var tileset = this.gids[obj.gid];\r\n\r\n            if (tileset !== undefined)\r\n            {\r\n                this.setFromJSON(sprite, tileset.getTileProperties(obj.gid));\r\n            }\r\n        }\r\n\r\n        this.setFromJSON(sprite, obj.properties);\r\n    },\r\n\r\n    /**\r\n     * Sets the sprite data from the JSON object.\r\n     *\r\n     * @method Phaser.Tilemaps.ObjectHelper#setFromJSON\r\n     * @since 3.60.0\r\n     * @private\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The object for which to populate `data`.\r\n     * @param {(Object.<string, *>|Object[])} properties - The properties to set in either JSON object format or else a list of objects with `name` and `value` fields.\r\n     */\r\n    setFromJSON: function (sprite, properties)\r\n    {\r\n        if (!properties)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (Array.isArray(properties))\r\n        {\r\n            // Tiled objects custom properties format\r\n            properties.forEach(function (propData)\r\n            {\r\n                sprite.setData(propData.name, propData.value);\r\n            });\r\n\r\n            return;\r\n        }\r\n\r\n        for (var key in properties)\r\n        {\r\n            sprite.setData(key, properties[key]);\r\n        }\r\n    }\r\n});\r\n\r\nmodule.exports = ObjectHelper;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('./Formats');\r\nvar MapData = require('./mapdata/MapData');\r\nvar Parse = require('./parsers/Parse');\r\nvar Tilemap = require('./Tilemap');\r\n\r\n/**\r\n * Create a Tilemap from the given key or data. If neither is given, make a blank Tilemap. When\r\n * loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing from\r\n * a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map data. For\r\n * an empty map, you should specify tileWidth, tileHeight, width & height.\r\n *\r\n * @function Phaser.Tilemaps.ParseToTilemap\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Tilemap belongs.\r\n * @param {string} [key] - The key in the Phaser cache that corresponds to the loaded tilemap data.\r\n * @param {number} [tileWidth=32] - The width of a tile in pixels.\r\n * @param {number} [tileHeight=32] - The height of a tile in pixels.\r\n * @param {number} [width=10] - The width of the map in tiles.\r\n * @param {number} [height=10] - The height of the map in tiles.\r\n * @param {number[][]} [data] - Instead of loading from the cache, you can also load directly from\r\n * a 2D array of tile indexes.\r\n * @param {boolean} [insertNull=false] - Controls how empty tiles, tiles with an index of -1, in the\r\n * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.Tilemap}\r\n */\r\nvar ParseToTilemap = function (scene, key, tileWidth, tileHeight, width, height, data, insertNull)\r\n{\r\n    if (tileWidth === undefined) { tileWidth = 32; }\r\n    if (tileHeight === undefined) { tileHeight = 32; }\r\n    if (width === undefined) { width = 10; }\r\n    if (height === undefined) { height = 10; }\r\n    if (insertNull === undefined) { insertNull = false; }\r\n\r\n    var mapData = null;\r\n\r\n    if (Array.isArray(data))\r\n    {\r\n        var name = key !== undefined ? key : 'map';\r\n        mapData = Parse(name, Formats.ARRAY_2D, data, tileWidth, tileHeight, insertNull);\r\n    }\r\n    else if (key !== undefined)\r\n    {\r\n        var tilemapData = scene.cache.tilemap.get(key);\r\n\r\n        if (!tilemapData)\r\n        {\r\n            console.warn('No map data found for key ' + key);\r\n        }\r\n        else\r\n        {\r\n            mapData = Parse(key, tilemapData.format, tilemapData.data, tileWidth, tileHeight, insertNull);\r\n        }\r\n    }\r\n\r\n    if (mapData === null)\r\n    {\r\n        mapData = new MapData({\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: height\r\n        });\r\n    }\r\n\r\n    return new Tilemap(scene, mapData);\r\n};\r\n\r\nmodule.exports = ParseToTilemap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const/ORIENTATION_CONST');\r\nvar Class = require('../utils/Class');\r\nvar Components = require('../gameobjects/components');\r\nvar Rectangle = require('../geom/rectangle');\r\n\r\n/**\r\n * @classdesc\r\n * A Tile is a representation of a single tile within the Tilemap. This is a lightweight data\r\n * representation, so its position information is stored without factoring in scroll, layer\r\n * scale or layer position.\r\n *\r\n * @class Tile\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The LayerData object in the Tilemap that this tile belongs to.\r\n * @param {number} index - The unique index of this tile within the map.\r\n * @param {number} x - The x coordinate of this tile in tile coordinates.\r\n * @param {number} y - The y coordinate of this tile in tile coordinates.\r\n * @param {number} width - Width of the tile in pixels.\r\n * @param {number} height - Height of the tile in pixels.\r\n * @param {number} baseWidth - The base width a tile in the map (in pixels). Tiled maps support\r\n * multiple tileset sizes within one map, but they are still placed at intervals of the base\r\n * tile width.\r\n * @param {number} baseHeight - The base height of the tile in pixels (in pixels). Tiled maps\r\n * support multiple tileset sizes within one map, but they are still placed at intervals of the\r\n * base tile height.\r\n */\r\nvar Tile = new Class({\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.Flip,\r\n        Components.Visible\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Tile (layer, index, x, y, width, height, baseWidth, baseHeight)\r\n    {\r\n        /**\r\n         * The LayerData in the Tilemap data that this tile belongs to.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#layer\r\n         * @type {Phaser.Tilemaps.LayerData}\r\n         * @since 3.0.0\r\n         */\r\n        this.layer = layer;\r\n\r\n        /**\r\n         * The index of this tile within the map data corresponding to the tileset, or -1 if this\r\n         * represents a blank tile.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#index\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = index;\r\n\r\n        /**\r\n         * The x map coordinate of this tile in tile units.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.x = x;\r\n\r\n        /**\r\n         * The y map coordinate of this tile in tile units.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.y = y;\r\n\r\n        /**\r\n         * The width of the tile in pixels.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * The height of the tile in pixels.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = height;\r\n\r\n        /**\r\n         * The right of the tile in pixels.\r\n         *\r\n         * Set in the `updatePixelXY` method.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#right\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.right;\r\n\r\n        /**\r\n         * The bottom of the tile in pixels.\r\n         *\r\n         * Set in the `updatePixelXY` method.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#bottom\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.bottom;\r\n\r\n        /**\r\n         * The maps base width of a tile in pixels. Tiled maps support multiple tileset sizes\r\n         * within one map, but they are still placed at intervals of the base tile size.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#baseWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseWidth = (baseWidth !== undefined) ? baseWidth : width;\r\n\r\n        /**\r\n         * The maps base height of a tile in pixels. Tiled maps support multiple tileset sizes\r\n         * within one map, but they are still placed at intervals of the base tile size.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#baseHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseHeight = (baseHeight !== undefined) ? baseHeight : height;\r\n\r\n        /**\r\n         * The x coordinate of the top left of this tile in pixels. This is relative to the top left\r\n         * of the layer this tile is being rendered within. This property does NOT factor in camera\r\n         * scroll, layer scale or layer position.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#pixelX\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.pixelX = 0;\r\n\r\n        /**\r\n         * The y coordinate of the top left of this tile in pixels. This is relative to the top left\r\n         * of the layer this tile is being rendered within. This property does NOT factor in camera\r\n         * scroll, layer scale or layer position.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#pixelY\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.pixelY = 0;\r\n\r\n        this.updatePixelXY();\r\n\r\n        /**\r\n         * Tile specific properties. These usually come from Tiled.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#properties\r\n         * @type {any}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = {};\r\n\r\n        /**\r\n         * The rotation angle of this tile.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#rotation\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.rotation = 0;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the left side.\r\n         *\r\n         * This property is used by Arcade Physics only, however, you can also use it\r\n         * in your own checks.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideLeft\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideLeft = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the right side.\r\n         *\r\n         * This property is used by Arcade Physics only, however, you can also use it\r\n         * in your own checks.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideRight\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideRight = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the top side.\r\n         *\r\n         * This property is used by Arcade Physics only, however, you can also use it\r\n         * in your own checks.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideUp\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideUp = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the bottom side.\r\n         *\r\n         * This property is used by Arcade Physics only, however, you can also use it\r\n         * in your own checks.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideDown\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideDown = false;\r\n\r\n        /**\r\n         * Whether the tiles left edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceLeft\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceLeft = false;\r\n\r\n        /**\r\n         * Whether the tiles right edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceRight\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceRight = false;\r\n\r\n        /**\r\n         * Whether the tiles top edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceTop\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceTop = false;\r\n\r\n        /**\r\n         * Whether the tiles bottom edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceBottom\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceBottom = false;\r\n\r\n        /**\r\n         * Tile collision callback.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collisionCallback\r\n         * @type {function}\r\n         * @since 3.0.0\r\n         */\r\n        this.collisionCallback = undefined;\r\n\r\n        /**\r\n         * The context in which the collision callback will be called.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collisionCallbackContext\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.collisionCallbackContext = this;\r\n\r\n        /**\r\n         * The tint to apply to this tile. Note: tint is currently a single color value instead of\r\n         * the 4 corner tint component on other GameObjects.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#tint\r\n         * @type {number}\r\n         * @default\r\n         * @since 3.0.0\r\n         */\r\n        this.tint = 0xffffff;\r\n\r\n        /**\r\n         * An empty object where physics-engine specific information (e.g. bodies) may be stored.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#physics\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.physics = {};\r\n    },\r\n\r\n    /**\r\n     * Check if the given x and y world coordinates are within this Tile. This does not factor in\r\n     * camera scroll, layer scale or layer position.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#containsPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to test.\r\n     * @param {number} y - The y coordinate to test.\r\n     *\r\n     * @return {boolean} True if the coordinates are within this Tile, otherwise false.\r\n     */\r\n    containsPoint: function (x, y)\r\n    {\r\n        return !(x < this.pixelX || y < this.pixelY || x > this.right || y > this.bottom);\r\n    },\r\n\r\n    /**\r\n     * Copies the tile data & properties from the given tile to this tile. This copies everything\r\n     * except for position and interesting faces.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.Tile} tile - The tile to copy from.\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    copy: function (tile)\r\n    {\r\n        this.index = tile.index;\r\n        this.alpha = tile.alpha;\r\n        this.properties = tile.properties;\r\n        this.visible = tile.visible;\r\n        this.setFlip(tile.flipX, tile.flipY);\r\n        this.tint = tile.tint;\r\n        this.rotation = tile.rotation;\r\n        this.collideUp = tile.collideUp;\r\n        this.collideDown = tile.collideDown;\r\n        this.collideLeft = tile.collideLeft;\r\n        this.collideRight = tile.collideRight;\r\n        this.collisionCallback = tile.collisionCallback;\r\n        this.collisionCallbackContext = tile.collisionCallbackContext;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The collision group for this Tile, defined within the Tileset. This returns a reference to\r\n     * the collision group stored within the Tileset, so any modification of the returned object\r\n     * will impact all tiles that have the same index as this tile.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @return {?object} The collision group for this Tile, as defined in the Tileset, or `null` if no group was defined.\r\n     */\r\n    getCollisionGroup: function ()\r\n    {\r\n        return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null;\r\n    },\r\n\r\n    /**\r\n     * The tile data for this Tile, defined within the Tileset. This typically contains Tiled\r\n     * collision data, tile animations and terrain information. This returns a reference to the tile\r\n     * data stored within the Tileset, so any modification of the returned object will impact all\r\n     * tiles that have the same index as this tile.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getTileData\r\n     * @since 3.0.0\r\n     *\r\n     * @return {?object} The tile data for this Tile, as defined in the Tileset, or `null` if no data was defined.\r\n     */\r\n    getTileData: function ()\r\n    {\r\n        return this.tileset ? this.tileset.getTileData(this.index) : null;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the left side of the tile, factoring in the layers position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The left (x) value of this tile.\r\n     */\r\n    getLeft: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        if (tilemapLayer)\r\n        {\r\n            var point = tilemapLayer.tileToWorldXY(this.x, this.y, undefined, camera);\r\n\r\n            return point.x;\r\n        }\r\n\r\n        return this.x * this.baseWidth;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the right side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getRight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The right (x) value of this tile.\r\n     */\r\n    getRight: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        return (tilemapLayer) ? this.getLeft(camera) + this.width * tilemapLayer.scaleX : this.getLeft(camera) + this.width;\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the top side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The top (y) value of this tile.\r\n     */\r\n    getTop: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        // Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile in grid\r\n        // units is the bottom left, so the y coordinate needs to be adjusted by the difference\r\n        // between the base size and this tile's size.\r\n        return tilemapLayer\r\n            ? tilemapLayer.tileToWorldY(this.y, camera) - (this.height - this.baseHeight) * tilemapLayer.scaleY\r\n            : this.y * this.baseHeight - (this.height - this.baseHeight);\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the bottom side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n\r\n     * @method Phaser.Tilemaps.Tile#getBottom\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The bottom (y) value of this tile.\r\n     */\r\n    getBottom: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        return tilemapLayer\r\n            ? this.getTop(camera) + this.height * tilemapLayer.scaleY\r\n            : this.getTop(camera) + this.height;\r\n    },\r\n\r\n\r\n    /**\r\n     * Gets the world rectangle bounding box for the tile, factoring in the layers position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     * @param {Phaser.Geom.Rectangle} [output] - Optional Rectangle object to store the results in.\r\n     *\r\n     * @return {(Phaser.Geom.Rectangle|object)} The bounds of this Tile.\r\n     */\r\n    getBounds: function (camera, output)\r\n    {\r\n        if (output === undefined) { output = new Rectangle(); }\r\n\r\n        output.x = this.getLeft(camera);\r\n        output.y = this.getTop(camera);\r\n        output.width = this.getRight(camera) - output.x;\r\n        output.height = this.getBottom(camera) - output.y;\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the center of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCenterX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The center x position of this Tile.\r\n     */\r\n    getCenterX: function (camera)\r\n    {\r\n        return (this.getLeft(camera) + this.getRight(camera)) / 2;\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the center of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCenterY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The center y position of this Tile.\r\n     */\r\n    getCenterY: function (camera)\r\n    {\r\n        return (this.getTop(camera) + this.getBottom(camera)) / 2;\r\n    },\r\n\r\n    /**\r\n     * Check for intersection with this tile. This does not factor in camera scroll, layer scale or\r\n     * layer position.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#intersects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x axis in pixels.\r\n     * @param {number} y - The y axis in pixels.\r\n     * @param {number} right - The right point.\r\n     * @param {number} bottom - The bottom point.\r\n     *\r\n     * @return {boolean} `true` if the Tile intersects with the given dimensions, otherwise `false`.\r\n     */\r\n    intersects: function (x, y, right, bottom)\r\n    {\r\n        return !(\r\n            right <= this.pixelX || bottom <= this.pixelY ||\r\n            x >= this.right || y >= this.bottom\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Checks if the tile is interesting.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#isInteresting\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} collides - If true, will consider the tile interesting if it collides on any side.\r\n     * @param {boolean} faces - If true, will consider the tile interesting if it has an interesting face.\r\n     *\r\n     * @return {boolean} True if the Tile is interesting, otherwise false.\r\n     */\r\n    isInteresting: function (collides, faces)\r\n    {\r\n        if (collides && faces)\r\n        {\r\n            return (this.canCollide || this.hasInterestingFace);\r\n        }\r\n        else if (collides)\r\n        {\r\n            return this.collides;\r\n        }\r\n        else if (faces)\r\n        {\r\n            return this.hasInterestingFace;\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Reset collision status flags.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#resetCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces for this tile and its neighbors.\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    resetCollision: function (recalculateFaces)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        this.collideLeft = false;\r\n        this.collideRight = false;\r\n        this.collideUp = false;\r\n        this.collideDown = false;\r\n\r\n        this.faceTop = false;\r\n        this.faceBottom = false;\r\n        this.faceLeft = false;\r\n        this.faceRight = false;\r\n\r\n        if (recalculateFaces)\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n\r\n            if (tilemapLayer)\r\n            {\r\n                this.tilemapLayer.calculateFacesAt(this.x, this.y);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reset faces.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#resetFaces\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    resetFaces: function ()\r\n    {\r\n        this.faceTop = false;\r\n        this.faceBottom = false;\r\n        this.faceLeft = false;\r\n        this.faceRight = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the collision flags for each side of this tile and updates the interesting faces list.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} left - Indicating collide with any object on the left.\r\n     * @param {boolean} [right] - Indicating collide with any object on the right.\r\n     * @param {boolean} [up] - Indicating collide with any object on the top.\r\n     * @param {boolean} [down] - Indicating collide with any object on the bottom.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces for this tile and its neighbors.\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    setCollision: function (left, right, up, down, recalculateFaces)\r\n    {\r\n        if (right === undefined) { right = left; }\r\n        if (up === undefined) { up = left; }\r\n        if (down === undefined) { down = left; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        this.collideLeft = left;\r\n        this.collideRight = right;\r\n        this.collideUp = up;\r\n        this.collideDown = down;\r\n\r\n        this.faceLeft = left;\r\n        this.faceRight = right;\r\n        this.faceTop = up;\r\n        this.faceBottom = down;\r\n\r\n        if (recalculateFaces)\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n\r\n            if (tilemapLayer)\r\n            {\r\n                this.tilemapLayer.calculateFacesAt(this.x, this.y);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set a callback to be called when this tile is hit by an object. The callback must true for\r\n     * collision processing to take place.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setCollisionCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - Callback function.\r\n     * @param {object} context - Callback will be called within this context.\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    setCollisionCallback: function (callback, context)\r\n    {\r\n        if (callback === null)\r\n        {\r\n            this.collisionCallback = undefined;\r\n            this.collisionCallbackContext = undefined;\r\n        }\r\n        else\r\n        {\r\n            this.collisionCallback = callback;\r\n            this.collisionCallbackContext = context;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the size of the tile and updates its pixelX and pixelY.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileWidth - The width of the tile in pixels.\r\n     * @param {number} tileHeight - The height of the tile in pixels.\r\n     * @param {number} baseWidth - The base width a tile in the map (in pixels).\r\n     * @param {number} baseHeight - The base height of the tile in pixels (in pixels).\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    setSize: function (tileWidth, tileHeight, baseWidth, baseHeight)\r\n    {\r\n        if (tileWidth !== undefined) { this.width = tileWidth; }\r\n        if (tileHeight !== undefined) { this.height = tileHeight; }\r\n        if (baseWidth !== undefined) { this.baseWidth = baseWidth; }\r\n        if (baseHeight !== undefined) { this.baseHeight = baseHeight; }\r\n\r\n        this.updatePixelXY();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Used internally. Updates the tiles world XY position based on the current tile size.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#updatePixelXY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    updatePixelXY: function ()\r\n    {\r\n        var orientation = this.layer.orientation;\r\n\r\n        if (orientation === CONST.ORTHOGONAL)\r\n        {\r\n            //  In orthogonal mode, Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile is the\r\n            //  bottom left, while the Phaser renderer assumes the origin is the top left. The y\r\n            //  coordinate needs to be adjusted by the difference.\r\n\r\n            this.pixelX = this.x * this.baseWidth;\r\n            this.pixelY = this.y * this.baseHeight;\r\n        }\r\n        else if (orientation === CONST.ISOMETRIC)\r\n        {\r\n            //  Reminder: For the tilemap to be centered we have to move the image to the right with the camera!\r\n            //  This is crucial for wordtotile, tiletoworld to work.\r\n\r\n            this.pixelX = (this.x - this.y) * this.baseWidth * 0.5;\r\n            this.pixelY = (this.x + this.y) * this.baseHeight * 0.5;\r\n        }\r\n        else if (orientation === CONST.STAGGERED)\r\n        {\r\n            this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);\r\n            this.pixelY = this.y * (this.baseHeight / 2);\r\n        }\r\n        else if (orientation === CONST.HEXAGONAL)\r\n        {\r\n            var len = this.layer.hexSideLength;\r\n            var rowHeight = ((this.baseHeight - len) / 2 + len);\r\n\r\n            this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);\r\n            this.pixelY = this.y * rowHeight;\r\n        }\r\n\r\n        this.right = this.pixelX + this.baseWidth;\r\n        this.bottom = this.pixelY + this.baseHeight;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clean up memory.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.collisionCallback = undefined;\r\n        this.collisionCallbackContext = undefined;\r\n        this.properties = undefined;\r\n    },\r\n\r\n    /**\r\n     * True if this tile can collide on any of its faces or has a collision callback set.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#canCollide\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    canCollide: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown || (this.collisionCallback !== undefined));\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * True if this tile can collide on any of its faces.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#collides\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    collides: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * True if this tile has any interesting faces.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#hasInterestingFace\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    hasInterestingFace: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The tileset that contains this Tile. This is null if accessed from a LayerData instance\r\n     * before the tile is placed in a TilemapLayer, or if the tile has an index that doesn't correspond\r\n     * to any of the maps tilesets.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tileset\r\n     * @type {?Phaser.Tilemaps.Tileset}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    tileset: {\r\n\r\n        get: function ()\r\n        {\r\n            var tilemapLayer = this.layer.tilemapLayer;\r\n\r\n            if (tilemapLayer)\r\n            {\r\n                var tileset = tilemapLayer.gidMap[this.index];\r\n\r\n                if (tileset)\r\n                {\r\n                    return tileset;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The tilemap layer that contains this Tile. This will only return null if accessed from a\r\n     * LayerData instance before the tile is placed within a TilemapLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tilemapLayer\r\n     * @type {?Phaser.Tilemaps.TilemapLayer}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    tilemapLayer: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.layer.tilemapLayer;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The tilemap that contains this Tile. This will only return null if accessed from a LayerData\r\n     * instance before the tile is placed within a TilemapLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tilemap\r\n     * @type {?Phaser.Tilemaps.Tilemap}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    tilemap: {\r\n\r\n        get: function ()\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n\r\n            return tilemapLayer ? tilemapLayer.tilemap : null;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Tile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar DegToRad = require('../math/DegToRad');\r\nvar Formats = require('./Formats');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar LayerData = require('./mapdata/LayerData');\r\nvar ObjectHelper = require('./ObjectHelper');\r\nvar ORIENTATION = require('./const/ORIENTATION_CONST');\r\nvar Rotate = require('../math/Rotate');\r\nvar SpliceOne = require('../utils/array/SpliceOne');\r\nvar Sprite = require('../gameobjects/sprite/Sprite');\r\nvar Tile = require('./Tile');\r\nvar TilemapComponents = require('./components');\r\nvar TilemapLayer = require('./TilemapLayer');\r\nvar Tileset = require('./Tileset');\r\n\r\n/**\r\n * @callback TilemapFilterCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} value - An object found in the filtered area.\r\n * @param {number} index - The index of the object within the array.\r\n * @param {Phaser.GameObjects.GameObject[]} array - An array of all the objects found.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The object.\r\n */\r\n\r\n/**\r\n * @callback TilemapFindCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} value - An object found.\r\n * @param {number} index - The index of the object within the array.\r\n * @param {Phaser.GameObjects.GameObject[]} array - An array of all the objects found.\r\n *\r\n * @return {boolean} `true` if the callback should be invoked, otherwise `false`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Tilemap is a container for Tilemap data. This isn't a display object, rather, it holds data\r\n * about the map and allows you to add tilesets and tilemap layers to it. A map can have one or\r\n * more tilemap layers, which are the display objects that actually render the tiles.\r\n *\r\n * The Tilemap data can be parsed from a Tiled JSON file, a CSV file or a 2D array. Tiled is a free\r\n * software package specifically for creating tile maps, and is available from:\r\n * http://www.mapeditor.org\r\n *\r\n * As of Phaser 3.50.0 the Tilemap API now supports the following types of map:\r\n *\r\n * 1) Orthogonal\r\n * 2) Isometric\r\n * 3) Hexagonal\r\n * 4) Staggered\r\n *\r\n * Prior to this release, only orthogonal maps were supported.\r\n *\r\n * Another large change in 3.50 was the consolidation of Tilemap Layers. Previously, you created\r\n * either a Static or Dynamic Tilemap Layer. However, as of 3.50 the features of both have been\r\n * merged and the API simplified, so now there is just the single `TilemapLayer` class.\r\n *\r\n * A Tilemap has handy methods for getting and manipulating the tiles within a layer, allowing\r\n * you to build or modify the tilemap data at runtime.\r\n *\r\n * Note that all Tilemaps use a base tile size to calculate dimensions from, but that a\r\n * TilemapLayer may have its own unique tile size that overrides this.\r\n *\r\n * As of Phaser 3.21.0, if your tilemap includes layer groups (a feature of Tiled 1.2.0+) these\r\n * will be traversed and the following properties will impact children:\r\n *\r\n * - Opacity (blended with parent) and visibility (parent overrides child)\r\n * - Vertical and horizontal offset\r\n *\r\n * The grouping hierarchy is not preserved and all layers will be flattened into a single array.\r\n *\r\n * Group layers are parsed during Tilemap construction but are discarded after parsing so dynamic\r\n * layers will NOT continue to be affected by a parent.\r\n *\r\n * To avoid duplicate layer names, a layer that is a child of a group layer will have its parent\r\n * group name prepended with a '/'.  For example, consider a group called 'ParentGroup' with a\r\n * child called 'Layer 1'. In the Tilemap object, 'Layer 1' will have the name\r\n * 'ParentGroup/Layer 1'.\r\n *\r\n * @class Tilemap\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Tilemap belongs.\r\n * @param {Phaser.Tilemaps.MapData} mapData - A MapData instance containing Tilemap data.\r\n */\r\nvar Tilemap = new Class({\r\n\r\n    initialize:\r\n\r\n    function Tilemap (scene, mapData)\r\n    {\r\n        /**\r\n         * @name Phaser.Tilemaps.Tilemap#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The base width of a tile in pixels. Note that individual layers may have a different tile\r\n         * width.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileWidth = mapData.tileWidth;\r\n\r\n        /**\r\n         * The base height of a tile in pixels. Note that individual layers may have a different\r\n         * tile height.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileHeight = mapData.tileHeight;\r\n\r\n        /**\r\n         * The width of the map (in tiles).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = mapData.width;\r\n\r\n        /**\r\n         * The height of the map (in tiles).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = mapData.height;\r\n\r\n        /**\r\n         * The orientation of the map data (as specified in Tiled), usually 'orthogonal'.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#orientation\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.orientation = mapData.orientation;\r\n\r\n        /**\r\n         * The render (draw) order of the map data (as specified in Tiled), usually 'right-down'.\r\n         *\r\n         * The draw orders are:\r\n         *\r\n         * right-down\r\n         * left-down\r\n         * right-up\r\n         * left-up\r\n         *\r\n         * This can be changed via the `setRenderOrder` method.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#renderOrder\r\n         * @type {string}\r\n         * @since 3.12.0\r\n         */\r\n        this.renderOrder = mapData.renderOrder;\r\n\r\n        /**\r\n         * The format of the map data.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#format\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.format = mapData.format;\r\n\r\n        /**\r\n         * The version of the map data (as specified in Tiled, usually 1).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#version\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.version = mapData.version;\r\n\r\n        /**\r\n         * Map specific properties as specified in Tiled.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = mapData.properties;\r\n\r\n        /**\r\n         * The width of the map in pixels based on width * tileWidth.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#widthInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.widthInPixels = mapData.widthInPixels;\r\n\r\n        /**\r\n         * The height of the map in pixels based on height * tileHeight.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#heightInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.heightInPixels = mapData.heightInPixels;\r\n\r\n        /**\r\n         * A collection of Images, as parsed from Tiled map data.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#imageCollections\r\n         * @type {Phaser.Tilemaps.ImageCollection[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.imageCollections = mapData.imageCollections;\r\n\r\n        /**\r\n         * An array of Tiled Image Layers.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#images\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.images = mapData.images;\r\n\r\n        /**\r\n         * An array of Tilemap layer data.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#layers\r\n         * @type {Phaser.Tilemaps.LayerData[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.layers = mapData.layers;\r\n\r\n        /**\r\n         * An array of Tilesets used in the map.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tilesets\r\n         * @type {Phaser.Tilemaps.Tileset[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.tilesets = mapData.tilesets;\r\n\r\n        /**\r\n         * An array of ObjectLayer instances parsed from Tiled object layers.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#objects\r\n         * @type {Phaser.Tilemaps.ObjectLayer[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.objects = mapData.objects;\r\n\r\n        /**\r\n         * The index of the currently selected LayerData object.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#currentLayerIndex\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.currentLayerIndex = 0;\r\n\r\n        /**\r\n         * The length of the horizontal sides of the hexagon.\r\n         * Only used for hexagonal orientation Tilemaps.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#hexSideLength\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.hexSideLength = mapData.hexSideLength;\r\n\r\n        var orientation = this.orientation;\r\n\r\n        /**\r\n         * Functions used to handle world to tile, and tile to world, conversion.\r\n         * Cached here for internal use by public methods such as `worldToTileXY`, etc.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#_convert\r\n         * @private\r\n         * @type {object}\r\n         * @since 3.50.0\r\n         */\r\n        this._convert = {\r\n            WorldToTileXY: TilemapComponents.GetWorldToTileXYFunction(orientation),\r\n            WorldToTileX: TilemapComponents.GetWorldToTileXFunction(orientation),\r\n            WorldToTileY: TilemapComponents.GetWorldToTileYFunction(orientation),\r\n            TileToWorldXY: TilemapComponents.GetTileToWorldXYFunction(orientation),\r\n            TileToWorldX: TilemapComponents.GetTileToWorldXFunction(orientation),\r\n            TileToWorldY: TilemapComponents.GetTileToWorldYFunction(orientation)\r\n        };\r\n    },\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    createBlankDynamicLayer: function (name, tileset, x, y, width, height, tileWidth, tileHeight)\r\n    {\r\n        console.warn('createBlankDynamicLayer is deprecated. Use createBlankLayer');\r\n\r\n        return this.createBlankLayer(name, tileset, x, y, width, height, tileWidth, tileHeight);\r\n    },\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    createDynamicLayer: function (layerID, tileset, x, y)\r\n    {\r\n        console.warn('createDynamicLayer is deprecated. Use createLayer');\r\n\r\n        return this.createLayer(layerID, tileset, x, y);\r\n    },\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    createStaticLayer: function (layerID, tileset, x, y)\r\n    {\r\n        console.warn('createStaticLayer is deprecated. Use createLayer');\r\n\r\n        return this.createLayer(layerID, tileset, x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets the rendering (draw) order of the tiles in this map.\r\n     *\r\n     * The default is 'right-down', meaning it will order the tiles starting from the top-left,\r\n     * drawing to the right and then moving down to the next row.\r\n     *\r\n     * The draw orders are:\r\n     *\r\n     * 0 = right-down\r\n     * 1 = left-down\r\n     * 2 = right-up\r\n     * 3 = left-up\r\n     *\r\n     * Setting the render order does not change the tiles or how they are stored in the layer,\r\n     * it purely impacts the order in which they are rendered.\r\n     *\r\n     * You can provide either an integer (0 to 3), or the string version of the order.\r\n     *\r\n     * Calling this method _after_ creating Tilemap Layers will **not** automatically\r\n     * update them to use the new render order. If you call this method after creating layers, use their\r\n     * own `setRenderOrder` methods to change them as needed.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setRenderOrder\r\n     * @since 3.12.0\r\n     *\r\n     * @param {(number|string)} renderOrder - The render (draw) order value. Either an integer between 0 and 3, or a string: 'right-down', 'left-down', 'right-up' or 'left-up'.\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    setRenderOrder: function (renderOrder)\r\n    {\r\n        var orders = [ 'right-down', 'left-down', 'right-up', 'left-up' ];\r\n\r\n        if (typeof renderOrder === 'number')\r\n        {\r\n            renderOrder = orders[renderOrder];\r\n        }\r\n\r\n        if (orders.indexOf(renderOrder) > -1)\r\n        {\r\n            this.renderOrder = renderOrder;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds an image to the map to be used as a tileset. A single map may use multiple tilesets.\r\n     * Note that the tileset name can be found in the JSON file exported from Tiled, or in the Tiled\r\n     * editor.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#addTilesetImage\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} tilesetName - The name of the tileset as specified in the map data.\r\n     * @param {string} [key] - The key of the Phaser.Cache image used for this tileset. If\r\n     * `undefined` or `null` it will look for an image with a key matching the tilesetName parameter.\r\n     * @param {number} [tileWidth] - The width of the tile (in pixels) in the Tileset Image. If not\r\n     * given it will default to the map's tileWidth value, or the tileWidth specified in the Tiled\r\n     * JSON file.\r\n     * @param {number} [tileHeight] - The height of the tiles (in pixels) in the Tileset Image. If\r\n     * not given it will default to the map's tileHeight value, or the tileHeight specified in the\r\n     * Tiled JSON file.\r\n     * @param {number} [tileMargin] - The margin around the tiles in the sheet (in pixels). If not\r\n     * specified, it will default to 0 or the value specified in the Tiled JSON file.\r\n     * @param {number} [tileSpacing] - The spacing between each the tile in the sheet (in pixels).\r\n     * If not specified, it will default to 0 or the value specified in the Tiled JSON file.\r\n     * @param {number} [gid=0] - If adding multiple tilesets to a blank map, specify the starting\r\n     * GID this set will use here.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tileset} Returns the Tileset object that was created or updated, or null if it\r\n     * failed.\r\n     */\r\n    addTilesetImage: function (tilesetName, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid)\r\n    {\r\n        if (tilesetName === undefined) { return null; }\r\n        if (key === undefined || key === null) { key = tilesetName; }\r\n\r\n        if (!this.scene.sys.textures.exists(key))\r\n        {\r\n            console.warn('Invalid Tileset Image: ' + key);\r\n            return null;\r\n        }\r\n\r\n        var texture = this.scene.sys.textures.get(key);\r\n\r\n        var index = this.getTilesetIndex(tilesetName);\r\n\r\n        if (index === null && this.format === Formats.TILED_JSON)\r\n        {\r\n            console.warn('No data found for Tileset: ' + tilesetName);\r\n            return null;\r\n        }\r\n\r\n        var tileset = this.tilesets[index];\r\n\r\n        if (tileset)\r\n        {\r\n            tileset.setTileSize(tileWidth, tileHeight);\r\n            tileset.setSpacing(tileMargin, tileSpacing);\r\n            tileset.setImage(texture);\r\n\r\n            return tileset;\r\n        }\r\n\r\n        if (tileWidth === undefined) { tileWidth = this.tileWidth; }\r\n        if (tileHeight === undefined) { tileHeight = this.tileHeight; }\r\n        if (tileMargin === undefined) { tileMargin = 0; }\r\n        if (tileSpacing === undefined) { tileSpacing = 0; }\r\n        if (gid === undefined) { gid = 0; }\r\n\r\n        tileset = new Tileset(tilesetName, gid, tileWidth, tileHeight, tileMargin, tileSpacing);\r\n\r\n        tileset.setImage(texture);\r\n\r\n        this.tilesets.push(tileset);\r\n\r\n        return tileset;\r\n    },\r\n\r\n    /**\r\n     * Copies the tiles in the source rectangular area to a new destination (all specified in tile\r\n     * coordinates) within the layer. This copies all tile properties & recalculates collision\r\n     * information in the destination region.\r\n     *\r\n     * If no layer specified, the map's current layer is used. This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} srcTileX - The x coordinate of the area to copy from, in tiles, not pixels.\r\n     * @param {number} srcTileY - The y coordinate of the area to copy from, in tiles, not pixels.\r\n     * @param {number} width - The width of the area to copy, in tiles, not pixels.\r\n     * @param {number} height - The height of the area to copy, in tiles, not pixels.\r\n     * @param {number} destTileX - The x coordinate of the area to copy to, in tiles, not pixels.\r\n     * @param {number} destTileY - The y coordinate of the area to copy to, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    copy: function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer !== null)\r\n        {\r\n            TilemapComponents.Copy(\r\n                srcTileX, srcTileY,\r\n                width, height,\r\n                destTileX, destTileY,\r\n                recalculateFaces, layer\r\n            );\r\n\r\n            return this;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a new and empty Tilemap Layer. The currently selected layer in the map is set to this new layer.\r\n     *\r\n     * Prior to v3.50.0 this method was called `createBlankDynamicLayer`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createBlankLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of this layer. Must be unique within the map.\r\n     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n     * @param {number} [x=0] - The world x position where the top left of this layer will be placed.\r\n     * @param {number} [y=0] - The world y position where the top left of this layer will be placed.\r\n     * @param {number} [width] - The width of the layer in tiles. If not specified, it will default to the map's width.\r\n     * @param {number} [height] - The height of the layer in tiles. If not specified, it will default to the map's height.\r\n     * @param {number} [tileWidth] - The width of the tiles the layer uses for calculations. If not specified, it will default to the map's tileWidth.\r\n     * @param {number} [tileHeight] - The height of the tiles the layer uses for calculations. If not specified, it will default to the map's tileHeight.\r\n     *\r\n     * @return {?Phaser.Tilemaps.TilemapLayer} Returns the new layer that was created, or `null` if it failed.\r\n     */\r\n    createBlankLayer: function (name, tileset, x, y, width, height, tileWidth, tileHeight)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.width; }\r\n        if (height === undefined) { height = this.height; }\r\n        if (tileWidth === undefined) { tileWidth = this.tileWidth; }\r\n        if (tileHeight === undefined) { tileHeight = this.tileHeight; }\r\n\r\n        var index = this.getLayerIndex(name);\r\n\r\n        if (index !== null)\r\n        {\r\n            console.warn('Invalid Tilemap Layer ID: ' + name);\r\n            return null;\r\n        }\r\n\r\n        var layerData = new LayerData({\r\n            name: name,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: height,\r\n            orientation: this.orientation\r\n        });\r\n\r\n        var row;\r\n\r\n        for (var tileY = 0; tileY < height; tileY++)\r\n        {\r\n            row = [];\r\n\r\n            for (var tileX = 0; tileX < width; tileX++)\r\n            {\r\n                row.push(new Tile(layerData, -1, tileX, tileY, tileWidth, tileHeight, this.tileWidth, this.tileHeight));\r\n            }\r\n\r\n            layerData.data.push(row);\r\n        }\r\n\r\n        this.layers.push(layerData);\r\n\r\n        this.currentLayerIndex = this.layers.length - 1;\r\n\r\n        var layer = new TilemapLayer(this.scene, this, this.currentLayerIndex, tileset, x, y);\r\n\r\n        layer.setRenderOrder(this.renderOrder);\r\n\r\n        this.scene.sys.displayList.add(layer);\r\n\r\n        return layer;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Tilemap Layer that renders the LayerData associated with the given\r\n     * `layerID`. The currently selected layer in the map is set to this new layer.\r\n     *\r\n     * The `layerID` is important. If you've created your map in Tiled then you can get this by\r\n     * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and\r\n     * look at the layers[].name value. Either way it must match.\r\n     *\r\n     * Prior to v3.50.0 this method was called `createDynamicLayer`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|string)} layerID - The layer array index value, or if a string is given, the layer name from Tiled.\r\n     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n     * @param {number} [x=0] - The x position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.\r\n     * @param {number} [y=0] - The y position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.\r\n     *\r\n     * @return {?Phaser.Tilemaps.TilemapLayer} Returns the new layer was created, or null if it failed.\r\n     */\r\n    createLayer: function (layerID, tileset, x, y)\r\n    {\r\n        var index = this.getLayerIndex(layerID);\r\n\r\n        if (index === null)\r\n        {\r\n            console.warn('Invalid Tilemap Layer ID: ' + layerID);\r\n\r\n            if (typeof layerID === 'string')\r\n            {\r\n                console.warn('Valid tilelayer names:\\n\\t' + this.getTileLayerNames().join(',\\n\\t'));\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        var layerData = this.layers[index];\r\n\r\n        // Check for an associated static or dynamic tilemap layer\r\n        if (layerData.tilemapLayer)\r\n        {\r\n            console.warn('Tilemap Layer ID already exists:' + layerID);\r\n            return null;\r\n        }\r\n\r\n        this.currentLayerIndex = index;\r\n\r\n        //  Default the x/y position to match Tiled layer offset, if it exists.\r\n\r\n        if (x === undefined)\r\n        {\r\n            x = layerData.x;\r\n        }\r\n\r\n        if (y === undefined)\r\n        {\r\n            y = layerData.y;\r\n        }\r\n\r\n        var layer = new TilemapLayer(this.scene, this, index, tileset, x, y);\r\n\r\n        layer.setRenderOrder(this.renderOrder);\r\n\r\n        this.scene.sys.displayList.add(layer);\r\n\r\n        return layer;\r\n    },\r\n\r\n    /**\r\n     * This method will iterate through all of the objects defined in a Tiled Object Layer and then\r\n     * convert the matching results into Phaser Game Objects (by default, Sprites)\r\n     *\r\n     * Objects are matched on one of 4 criteria: The Object ID, the Object GID, the Object Name, or the Object Type.\r\n     *\r\n     * Within Tiled, Object IDs are unique per Object. Object GIDs, however, are shared by all objects\r\n     * using the same image. Finally, Object Names and Types are strings and the same name can be used on multiple\r\n     * Objects in Tiled, they do not have to be unique; Names are specific to Objects while Types can be inherited\r\n     * from Object GIDs using the same image.\r\n     *\r\n     * You set the configuration parameter accordingly, based on which type of criteria you wish\r\n     * to match against. For example, to convert all items on an Object Layer with a `gid` of 26:\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, {\r\n     *   gid: 26\r\n     * });\r\n     * ```\r\n     *\r\n     * Or, to convert objects with the name 'bonus':\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, {\r\n     *   name: 'bonus'\r\n     * });\r\n     * ```\r\n     *\r\n     * Or, to convert an object with a specific id:\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, {\r\n     *   id: 9\r\n     * });\r\n     * ```\r\n     *\r\n     * You should only specify either `id`, `gid`, `name`, `type`, or none of them. Do not add more than\r\n     * one criteria to your config. If you do not specify any criteria, then _all_ objects in the\r\n     * Object Layer will be converted.\r\n     *\r\n     * By default this method will convert objects into `Sprite` instances, but you can override\r\n     * this by providing your own class type:\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, {\r\n     *   gid: 26,\r\n     *   classType: Coin\r\n     * });\r\n     * ```\r\n     *\r\n     * This will convert all Objects with a gid of 26 into your custom `Coin` class. You can pass\r\n     * any class type here, but it _must_ extend `Phaser.GameObjects.GameObject` as its base class.\r\n     * Your class will always be passed 1 parameter: `scene`, which is a reference to either the Scene\r\n     * specified in the config object or, if not given, the Scene to which this Tilemap belongs. The\r\n     * class must have {@link Phaser.GameObjects.Components.Transform#setPosition} and\r\n     * {@link Phaser.GameObjects.Components.Texture#setTexture} methods.\r\n     *\r\n     * All properties from object are copied into the Game Object, so you can use this as an easy\r\n     * way to configure properties from within the map editor. For example giving an object a\r\n     * property of `alpha: 0.5` in Tiled will be reflected in the Game Object that is created.\r\n     *\r\n     * Custom object properties that do not exist as a Game Object property are set in the\r\n     * Game Objects {@link Phaser.GameObjects.GameObject#data data store}.\r\n     *\r\n     * Objects that are based on tiles (tilemap objects that are defined using the `gid` property) can be considered \"hierarchical\" by passing the third parameter `useTileset` true.\r\n     * Data such as texture, frame (assuming you've matched tileset and spritesheet geometries),\r\n     * `type` and `properties` will use the tileset information first and then override it with data set at the object level.\r\n     * For instance, a tileset which includes\r\n     * `[... a tileset of 16 elements...], [...ids 0, 1, and 2...], {id: 3, type: 'treadmill', speed:4}`\r\n     * and an object layer which includes\r\n     * `{id: 7, gid: 19, speed:5, rotation:90}`\r\n     * will be interpreted as though it were\r\n     * `{id: 7, gid:19, speed:5, rotation:90, type:'treadmill', texture:..., frame:3}`.\r\n     * You can then suppress this behavior by setting the boolean `ignoreTileset` for each `config` that should ignore\r\n     * object gid tilesets.\r\n     *\r\n     * You can set a `container` property in the config. If given, the class will be added to\r\n     * the Container instance instead of the Scene.\r\n     * You can set named texture-`key` and texture-`frame` properties, which will be set on the resultant object.\r\n     *\r\n     * Finally, you can provide an array of config objects, to convert multiple types of object in\r\n     * a single call:\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, [\r\n     *   {\r\n     *     gid: 26,\r\n     *     classType: Coin\r\n     *   },\r\n     *   {\r\n     *     id: 9,\r\n     *     classType: BossMonster\r\n     *   },\r\n     *   {\r\n     *     name: 'lava',\r\n     *     classType: LavaTile\r\n     *   },\r\n     *   {\r\n     *     type: 'endzone',\r\n     *     classType: Phaser.GameObjects.Zone\r\n     *   }\r\n     * ]);\r\n     * ```\r\n     *\r\n     * The signature of this method changed significantly in v3.60.0. Prior to this, it did not take config objects.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createFromObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} objectLayerName - The name of the Tiled object layer to create the Game Objects from.\r\n     * @param {Phaser.Types.Tilemaps.CreateFromObjectLayerConfig|Phaser.Types.Tilemaps.CreateFromObjectLayerConfig[]} config - A CreateFromObjects configuration object, or an array of them.\r\n     * @param {boolean} [useTileset=true] - True if objects that set gids should also search the underlying tile for properties and data.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} An array containing the Game Objects that were created. Empty if invalid object layer, or no matching id/gid/name was found.\r\n     */\r\n    createFromObjects: function (objectLayerName, config, useTileset)\r\n    {\r\n        if (useTileset === undefined) { useTileset = true; }\r\n\r\n        var results = [];\r\n\r\n        var objectLayer = this.getObjectLayer(objectLayerName);\r\n\r\n        if (!objectLayer)\r\n        {\r\n            console.warn('createFromObjects: Invalid objectLayerName given: ' + objectLayerName);\r\n\r\n            return results;\r\n        }\r\n\r\n        var objectHelper = new ObjectHelper(useTileset ? this.tilesets : undefined);\r\n\r\n        if (!Array.isArray(config))\r\n        {\r\n            config = [ config ];\r\n        }\r\n\r\n        var objects = objectLayer.objects;\r\n\r\n        for (var c = 0; c < config.length; c++)\r\n        {\r\n            var singleConfig = config[c];\r\n\r\n            var id = GetFastValue(singleConfig, 'id', null);\r\n            var gid = GetFastValue(singleConfig, 'gid', null);\r\n            var name = GetFastValue(singleConfig, 'name', null);\r\n            var type = GetFastValue(singleConfig, 'type', null);\r\n            objectHelper.enabled = !GetFastValue(singleConfig, 'ignoreTileset', null);\r\n\r\n            var obj;\r\n            var toConvert = [];\r\n\r\n            //  Sweep to get all the objects we want to convert in this pass\r\n            for (var s = 0; s < objects.length; s++)\r\n            {\r\n                obj = objects[s];\r\n\r\n                if (\r\n                    (id === null && gid === null && name === null && type === null) ||\r\n                    (id !== null && obj.id === id) ||\r\n                    (gid !== null && obj.gid === gid) ||\r\n                    (name !== null && obj.name === name) ||\r\n                    (type !== null && objectHelper.getTypeIncludingTile(obj) === type)\r\n                )\r\n                {\r\n                    toConvert.push(obj);\r\n                }\r\n            }\r\n\r\n            //  Now let's convert them ...\r\n\r\n            var classType = GetFastValue(singleConfig, 'classType', Sprite);\r\n            var scene = GetFastValue(singleConfig, 'scene', this.scene);\r\n            var container = GetFastValue(singleConfig, 'container', null);\r\n            var texture = GetFastValue(singleConfig, 'key', null);\r\n            var frame = GetFastValue(singleConfig, 'frame', null);\r\n\r\n            for (var i = 0; i < toConvert.length; i++)\r\n            {\r\n                obj = toConvert[i];\r\n\r\n                var sprite = new classType(scene);\r\n\r\n                sprite.setName(obj.name);\r\n                sprite.setPosition(obj.x, obj.y);\r\n                objectHelper.setTextureAndFrame(sprite, texture, frame, obj);\r\n\r\n                if (obj.width)\r\n                {\r\n                    sprite.displayWidth = obj.width;\r\n                }\r\n\r\n                if (obj.height)\r\n                {\r\n                    sprite.displayHeight = obj.height;\r\n                }\r\n\r\n                if (this.orientation === ORIENTATION.ISOMETRIC)\r\n                {\r\n                    var isometricRatio = this.tileWidth / this.tileHeight;\r\n                    var isometricPosition = {\r\n                        x: sprite.x - sprite.y,\r\n                        y: (sprite.x + sprite.y) / isometricRatio\r\n                    };\r\n\r\n                    sprite.x = isometricPosition.x;\r\n                    sprite.y = isometricPosition.y;\r\n                }\r\n\r\n                //  Origin is (0, 1) for tile objects or (0, 0) for other objects in Tiled, so find the offset that matches the Sprites origin.\r\n                //  Do not offset objects with zero dimensions (e.g. points).\r\n                var offset = {\r\n                    x: sprite.originX * obj.width,\r\n                    y: (sprite.originY - (obj.gid ? 1 : 0)) * obj.height\r\n                };\r\n\r\n                //  If the object is rotated, then the origin offset also needs to be rotated.\r\n                if (obj.rotation)\r\n                {\r\n                    var angle = DegToRad(obj.rotation);\r\n\r\n                    Rotate(offset, angle);\r\n\r\n                    sprite.rotation = angle;\r\n                }\r\n\r\n                sprite.x += offset.x;\r\n                sprite.y += offset.y;\r\n\r\n                if (obj.flippedHorizontal !== undefined || obj.flippedVertical !== undefined)\r\n                {\r\n                    sprite.setFlip(obj.flippedHorizontal, obj.flippedVertical);\r\n                }\r\n\r\n                if (!obj.visible)\r\n                {\r\n                    sprite.visible = false;\r\n                }\r\n\r\n                objectHelper.setPropertiesFromTiledObject(sprite, obj);\r\n\r\n                if (container)\r\n                {\r\n                    container.add(sprite);\r\n                }\r\n                else\r\n                {\r\n                    scene.add.existing(sprite);\r\n                }\r\n\r\n                results.push(sprite);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    },\r\n\r\n    /**\r\n     * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n     * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n     * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n     * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createFromTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n     * @param {(number|array)} replacements - The tile index, or array of indexes, to change a converted\r\n     * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a\r\n     * one-to-one mapping with the indexes array.\r\n     * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e. scene.make.sprite).\r\n     * @param {Phaser.Scene} [scene] - The Scene to create the Sprites within.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.GameObjects.Sprite[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    createFromTiles: function (indexes, replacements, spriteConfig, scene, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the\r\n     * specified index. Tiles will be set to collide if the given index is a colliding index.\r\n     * Collision information in the region will be recalculated.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#fill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} index - The tile index to fill the area with.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    fill: function (index, tileX, tileY, width, height, recalculateFaces, layer)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * For each object in the given object layer, run the given filter callback function. Any\r\n     * objects that pass the filter test (i.e. where the callback returns true) will returned as a\r\n     * new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#filterObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.ObjectLayer|string)} objectLayer - The name of an object layer (from Tiled) or an ObjectLayer instance.\r\n     * @param {TilemapFilterCallback} callback - The callback. Each object in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     *\r\n     * @return {?Phaser.Types.Tilemaps.TiledObject[]} An array of object that match the search, or null if the objectLayer given was invalid.\r\n     */\r\n    filterObjects: function (objectLayer, callback, context)\r\n    {\r\n        if (typeof objectLayer === 'string')\r\n        {\r\n            var name = objectLayer;\r\n\r\n            objectLayer = this.getObjectLayer(objectLayer);\r\n\r\n            if (!objectLayer)\r\n            {\r\n                console.warn('No object layer found with the name: ' + name);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return objectLayer.objects.filter(callback, context);\r\n    },\r\n\r\n    /**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n     * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#filterTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n     * filter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    filterTiles: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, layer);\r\n    },\r\n\r\n    /**\r\n     * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n     * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n     * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n     * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n     * the top-left.\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} index - The tile index value to search for.\r\n     * @param {number} [skip=0] - The number of times to skip a matching tile before returning.\r\n     * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the bottom-right. Otherwise it scans from the top-left.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tiles, or null if the layer given was invalid.\r\n     */\r\n    findByIndex: function (findIndex, skip, reverse, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.FindByIndex(findIndex, skip, reverse, layer);\r\n    },\r\n\r\n    /**\r\n     * Find the first object in the given object layer that satisfies the provided testing function.\r\n     * I.e. finds the first object for which `callback` returns true. Similar to\r\n     * Array.prototype.find in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.ObjectLayer|string)} objectLayer - The name of an object layer (from Tiled) or an ObjectLayer instance.\r\n     * @param {TilemapFindCallback} callback - The callback. Each object in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     *\r\n     * @return {?Phaser.Types.Tilemaps.TiledObject} An object that matches the search, or null if no object found.\r\n     */\r\n    findObject: function (objectLayer, callback, context)\r\n    {\r\n        if (typeof objectLayer === 'string')\r\n        {\r\n            var name = objectLayer;\r\n\r\n            objectLayer = this.getObjectLayer(objectLayer);\r\n\r\n            if (!objectLayer)\r\n            {\r\n                console.warn('No object layer found with the name: ' + name);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return objectLayer.objects.find(callback, context) || null;\r\n    },\r\n\r\n    /**\r\n     * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n     * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n     * true. Similar to Array.prototype.find in vanilla JS.\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findTile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The Tile layer to run the search on. If not provided will use the current layer.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tiles, or null if the layer given was invalid.\r\n     */\r\n    findTile: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);\r\n    },\r\n\r\n    /**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#forEachTile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The Tile layer to run the search on. If not provided will use the current layer.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    forEachTile: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the image layer index based on its name.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getImageIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the image to get.\r\n     *\r\n     * @return {number} The index of the image in this tilemap, or null if not found.\r\n     */\r\n    getImageIndex: function (name)\r\n    {\r\n        return this.getIndex(this.images, name);\r\n    },\r\n\r\n    /**\r\n     * Return a list of all valid imagelayer names loaded in this Tilemap.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getImageLayerNames\r\n     * @since 3.21.0\r\n     *\r\n     * @return {string[]} Array of valid imagelayer names / IDs loaded into this Tilemap.\r\n     */\r\n    getImageLayerNames: function ()\r\n    {\r\n        if (!this.images || !Array.isArray(this.images))\r\n        {\r\n            return [];\r\n        }\r\n\r\n        return this.images.map(function (image)\r\n        {\r\n            return image.name;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Internally used. Returns the index of the object in one of the Tilemaps arrays whose name\r\n     * property matches the given `name`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} location - The Tilemap array to search.\r\n     * @param {string} name - The name of the array element to get.\r\n     *\r\n     * @return {number} The index of the element in the array, or null if not found.\r\n     */\r\n    getIndex: function (location, name)\r\n    {\r\n        for (var i = 0; i < location.length; i++)\r\n        {\r\n            if (location[i].name === name)\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Gets the LayerData from `this.layers` that is associated with the given `layer`, or null if the layer is invalid.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The name of the layer from Tiled, the index of the layer in the map or Tilemap Layer. If not given will default to the maps current layer index.\r\n     *\r\n     * @return {Phaser.Tilemaps.LayerData} The corresponding LayerData within this.layers.\r\n     */\r\n    getLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        return (index !== null) ? this.layers[index] : null;\r\n    },\r\n\r\n    /**\r\n     * Gets the ObjectLayer from `this.objects` that has the given `name`, or null if no ObjectLayer is found with that name.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getObjectLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [name] - The name of the object layer from Tiled.\r\n     *\r\n     * @return {?Phaser.Tilemaps.ObjectLayer} The corresponding `ObjectLayer` within `this.objects`, or null.\r\n     */\r\n    getObjectLayer: function (name)\r\n    {\r\n        var index = this.getIndex(this.objects, name);\r\n\r\n        return (index !== null) ? this.objects[index] : null;\r\n    },\r\n\r\n    /**\r\n     * Return a list of all valid objectgroup names loaded in this Tilemap.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getObjectLayerNames\r\n     * @since 3.21.0\r\n     *\r\n     * @return {string[]} Array of valid objectgroup names / IDs loaded into this Tilemap.\r\n     */\r\n    getObjectLayerNames: function ()\r\n    {\r\n        if (!this.objects || !Array.isArray(this.objects))\r\n        {\r\n            return [];\r\n        }\r\n\r\n        return this.objects.map(function (object)\r\n        {\r\n            return object.name;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Gets the LayerData index of the given `layer` within this.layers, or null if an invalid\r\n     * `layer` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayerIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The name of the layer from Tiled, the index of the layer in the map or a Tilemap Layer. If not given will default to the map's current layer index.\r\n     *\r\n     * @return {number} The LayerData index within this.layers.\r\n     */\r\n    getLayerIndex: function (layer)\r\n    {\r\n        if (layer === undefined)\r\n        {\r\n            return this.currentLayerIndex;\r\n        }\r\n        else if (typeof layer === 'string')\r\n        {\r\n            return this.getLayerIndexByName(layer);\r\n        }\r\n        else if (typeof layer === 'number' && layer < this.layers.length)\r\n        {\r\n            return layer;\r\n        }\r\n        else if (layer instanceof TilemapLayer)\r\n        {\r\n            return layer.layerIndex;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Gets the index of the LayerData within this.layers that has the given `name`, or null if an\r\n     * invalid `name` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayerIndexByName\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the layer to get.\r\n     *\r\n     * @return {number} The LayerData index within this.layers.\r\n     */\r\n    getLayerIndexByName: function (name)\r\n    {\r\n        return this.getIndex(this.layers, name);\r\n    },\r\n\r\n    /**\r\n     * Gets a tile at the given tile coordinates from the given layer.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - X position to get the tile from (given in tile units, not pixels).\r\n     * @param {number} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n     * @param {boolean} [nonNull] - If true getTile won't return null for empty tiles, but a Tile object with an index of -1.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    getTileAt: function (tileX, tileY, nonNull, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTileAt(tileX, tileY, nonNull, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets a tile at the given world coordinates from the given layer.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - X position to get the tile from (given in pixels)\r\n     * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n     * @param {boolean} [nonNull] - If true, function won't return null for empty tiles, but a Tile object with an index of -1.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    getTileAtWorldXY: function (worldX, worldY, nonNull, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Return a list of all valid tilelayer names loaded in this Tilemap.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileLayerNames\r\n     * @since 3.21.0\r\n     *\r\n     * @return {string[]} Array of valid tilelayer names / IDs loaded into this Tilemap.\r\n     */\r\n    getTileLayerNames: function ()\r\n    {\r\n        if (!this.layers || !Array.isArray(this.layers))\r\n        {\r\n            return [];\r\n        }\r\n\r\n        return this.layers.map(function (layer)\r\n        {\r\n            return layer.name;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    getTilesWithin: function (tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n     * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithinShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    getTilesWithinShape: function (shape, filteringOptions, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithinWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The world x coordinate for the top-left of the area.\r\n     * @param {number} worldY - The world y coordinate for the top-left of the area.\r\n     * @param {number} width - The width of the area.\r\n     * @param {number} height - The height of the area.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    getTilesWithinWorldXY: function (worldX, worldY, width, height, filteringOptions, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the Tileset that has the given `name`, or null if an invalid `name` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileset\r\n     * @since 3.14.0\r\n     *\r\n     * @param {string} name - The name of the Tileset to get.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tileset} The Tileset, or `null` if no matching named tileset was found.\r\n     */\r\n    getTileset: function (name)\r\n    {\r\n        var index = this.getIndex(this.tilesets, name);\r\n\r\n        return (index !== null) ? this.tilesets[index] : null;\r\n    },\r\n\r\n    /**\r\n     * Gets the index of the Tileset within this.tilesets that has the given `name`, or null if an\r\n     * invalid `name` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesetIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the Tileset to get.\r\n     *\r\n     * @return {number} The Tileset index within this.tilesets.\r\n     */\r\n    getTilesetIndex: function (name)\r\n    {\r\n        return this.getIndex(this.tilesets, name);\r\n    },\r\n\r\n    /**\r\n     * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#hasTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n     */\r\n    hasTileAt: function (tileX, tileY, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.HasTileAt(tileX, tileY, layer);\r\n    },\r\n\r\n    /**\r\n     * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#hasTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n     */\r\n    hasTileAtWorldXY: function (worldX, worldY, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * The LayerData object that is currently selected in the map. You can set this property using\r\n     * any type supported by setLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#layer\r\n     * @type {Phaser.Tilemaps.LayerData}\r\n     * @since 3.0.0\r\n     */\r\n    layer: {\r\n        get: function ()\r\n        {\r\n            return this.layers[this.currentLayerIndex];\r\n        },\r\n\r\n        set: function (layer)\r\n        {\r\n            this.setLayer(layer);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n     * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n     * location. If you pass in an index, only the index at the specified location will be changed.\r\n     * Collision information will be recalculated at the specified location.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces] - `true` if the faces data should be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid or the coordinates were out of bounds.\r\n     */\r\n    putTileAt: function (tile, tileX, tileY, recalculateFaces, layer)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, layer);\r\n    },\r\n\r\n    /**\r\n     * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either\r\n     * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the\r\n     * specified location. If you pass in an index, only the index at the specified location will be\r\n     * changed. Collision information will be recalculated at the specified location.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {boolean} [recalculateFaces] - `true` if the faces data should be recalculated.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    putTileAtWorldXY: function (tile, worldX, worldY, recalculateFaces, camera, layer)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified\r\n     * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,\r\n     * all attributes will be copied over to the specified location. If you pass in an index, only the\r\n     * index at the specified location will be changed. Collision information will be recalculated\r\n     * within the region tiles were changed.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTilesAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number[]|number[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles or tile indexes to place.\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces] - `true` if the faces data should be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    putTilesAt: function (tilesArray, tileX, tileY, recalculateFaces, layer)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n     * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n     * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n     * indexes. This method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#randomize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {number[]} [indexes] - An array of indexes to randomly draw from during randomization.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    randomize: function (tileX, tileY, width, height, indexes, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.Randomize(tileX, tileY, width, height, indexes, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n     * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n     * internally to optimize recalculating faces when only one tile has been changed.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#calculateFacesAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    calculateFacesAt: function (tileX, tileY, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.CalculateFacesAt(tileX, tileY, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n     * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n     * is mostly used internally.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#calculateFacesWithin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    calculateFacesWithin: function (tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the given TilemapLayer from this Tilemap without destroying it.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeLayer\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to be removed.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    removeLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        if (index !== null)\r\n        {\r\n            SpliceOne(this.layers, index);\r\n\r\n            for (var i = index; i < this.layers.length; i++)\r\n            {\r\n                if (this.layers[i].tilemapLayer)\r\n                {\r\n                    this.layers[i].tilemapLayer.layerIndex--;\r\n                }\r\n            }\r\n\r\n            if (this.currentLayerIndex === index)\r\n            {\r\n                this.currentLayerIndex = 0;\r\n            }\r\n\r\n            return this;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys the given TilemapLayer and removes it from this Tilemap.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#destroyLayer\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to be destroyed.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    destroyLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        if (index !== null)\r\n        {\r\n            layer = this.layers[index];\r\n\r\n            layer.destroy();\r\n\r\n            SpliceOne(this.layers, index);\r\n\r\n            if (this.currentLayerIndex === index)\r\n            {\r\n                this.currentLayerIndex = 0;\r\n            }\r\n\r\n            return this;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Removes all Tilemap Layers from this Tilemap and calls `destroy` on each of them.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeAllLayers\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    removeAllLayers: function ()\r\n    {\r\n        var layers = this.layers;\r\n\r\n        for (var i = 0; i < layers.length; i++)\r\n        {\r\n            if (layers[i].tilemapLayer)\r\n            {\r\n                layers[i].tilemapLayer.destroy(false);\r\n            }\r\n        }\r\n\r\n        layers.length = 0;\r\n\r\n        this.currentLayerIndex = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the given Tile, or an array of Tiles, from the layer to which they belong,\r\n     * and optionally recalculates the collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeTile\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.Tile|Phaser.Tilemaps.Tile[])} tiles - The Tile to remove, or an array of Tiles.\r\n     * @param {number} [replaceIndex=-1] - After removing the Tile, insert a brand new Tile into its location with the given index. Leave as -1 to just remove the tile.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} Returns an array of Tiles that were removed.\r\n     */\r\n    removeTile: function (tiles, replaceIndex, recalculateFaces)\r\n    {\r\n        if (replaceIndex === undefined) { replaceIndex = -1; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        var removed = [];\r\n\r\n        if (!Array.isArray(tiles))\r\n        {\r\n            tiles = [ tiles ];\r\n        }\r\n\r\n        for (var i = 0; i < tiles.length; i++)\r\n        {\r\n            var tile = tiles[i];\r\n\r\n            removed.push(this.removeTileAt(tile.x, tile.y, true, recalculateFaces, tile.tilemapLayer));\r\n\r\n            if (replaceIndex > -1)\r\n            {\r\n                this.putTileAt(replaceIndex, tile.x, tile.y, recalculateFaces, tile.tilemapLayer);\r\n            }\r\n        }\r\n\r\n        return removed;\r\n    },\r\n\r\n    /**\r\n     * Removes the tile at the given tile coordinates in the specified layer and updates the layers collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [replaceWithNull] - If `true` (the default), this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces] - If `true` (the default), the faces data will be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns the Tile that was removed, or null if the layer given was invalid.\r\n     */\r\n    removeTileAt: function (tileX, tileY, replaceWithNull, recalculateFaces, layer)\r\n    {\r\n        if (replaceWithNull === undefined) { replaceWithNull = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, layer);\r\n    },\r\n\r\n    /**\r\n     * Removes the tile at the given world coordinates in the specified layer and updates the layers collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {boolean} [replaceWithNull] - If `true` (the default), this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces] - If `true` (the default), the faces data will be recalculated.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    removeTileAtWorldXY: function (worldX, worldY, replaceWithNull, recalculateFaces, camera, layer)\r\n    {\r\n        if (replaceWithNull === undefined) { replaceWithNull = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Draws a debug representation of the layer to the given Graphics object. This is helpful when you want to\r\n     * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n     * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n     * wherever you want on the screen.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * **Note:** This method currently only works with orthogonal tilemap layers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#renderDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n     * @param {Phaser.Types.Tilemaps.StyleConfig} [styleConfig] - An object specifying the colors to use for the debug drawing.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    renderDebug: function (graphics, styleConfig, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        if (this.orientation === ORIENTATION.ORTHOGONAL)\r\n        {\r\n            TilemapComponents.RenderDebug(graphics, styleConfig, layer);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws a debug representation of all layers within this Tilemap to the given Graphics object.\r\n     *\r\n     * This is helpful when you want to get a quick idea of which of your tiles are colliding and which\r\n     * have interesting faces. The tiles are drawn starting at (0, 0) in the Graphics, allowing you to\r\n     * place the debug representation wherever you want on the screen.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#renderDebugFull\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n     * @param {Phaser.Types.Tilemaps.StyleConfig} [styleConfig] - An object specifying the colors to use for the debug drawing.\r\n     *\r\n     * @return {this} This Tilemap instance.\r\n     */\r\n    renderDebugFull: function (graphics, styleConfig)\r\n    {\r\n        var layers = this.layers;\r\n\r\n        for (var i = 0; i < layers.length; i++)\r\n        {\r\n            TilemapComponents.RenderDebug(graphics, styleConfig, layers[i]);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does\r\n     * not change collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#replaceByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} findIndex - The index of the tile to search for.\r\n     * @param {number} newIndex - The index of the tile to replace it with.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    replaceByIndex: function (findIndex, newIndex, tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n     * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n     * collision will be enabled (true) or disabled (false).\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollision: function (indexes, collides, recalculateFaces, layer, updateLayer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n        if (updateLayer === undefined) { updateLayer = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollision(indexes, collides, recalculateFaces, layer, updateLayer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n     * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n     * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n     * enabled (true) or disabled (false).\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionBetween\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} start - The first index of the tile to be set for collision.\r\n     * @param {number} stop - The last index of the tile to be set for collision.\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionBetween: function (start, stop, collides, recalculateFaces, layer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n     * that matches the given properties object, its collision flag will be set. The `collides`\r\n     * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n     * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n     * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n     * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n     * \"types\" property that matches any of those values, its collision flag will be updated.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionByProperty\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} properties - An object with tile properties and corresponding values that should be checked.\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionByProperty: function (properties, collides, recalculateFaces, layer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n     * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n     * disabled (false). Tile indexes not currently in the layer are not affected.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionByExclusion\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number[]} indexes - An array of the tile indexes to not be counted for collision.\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionByExclusion: function (indexes, collides, recalculateFaces, layer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the tiles within a layer by checking each tiles collision group data\r\n     * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n     * a tiles collision group, the tiles colliding information will be set. The `collides` parameter\r\n     * controls if collision will be enabled (true) or disabled (false).\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionFromCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionFromCollisionGroup: function (collides, recalculateFaces, layer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n     * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n     * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n     * at a specific location on the map then see `setTileLocationCallback`.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setTileIndexCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|number[])} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for. All values should be integers.\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} callbackContext - The context under which the callback is called.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setTileIndexCallback: function (indexes, callback, callbackContext, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.\r\n     * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n     * remove it.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setTileLocationCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} [callbackContext] - The context under which the callback is called.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setTileLocationCallback: function (tileX, tileY, width, height, callback, callbackContext, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current layer to the LayerData associated with `layer`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The name of the layer from Tiled, the index of the layer in the map or a TilemapLayer. If not given will default to the maps current layer index.\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    setLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        if (index !== null)\r\n        {\r\n            this.currentLayerIndex = index;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the base tile size for the map. Note: this does not necessarily match the tileWidth and\r\n     * tileHeight for all layers. This also updates the base size on all tiles across all layers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setBaseTileSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileWidth - The width of the tiles the map uses for calculations.\r\n     * @param {number} tileHeight - The height of the tiles the map uses for calculations.\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    setBaseTileSize: function (tileWidth, tileHeight)\r\n    {\r\n        this.tileWidth = tileWidth;\r\n        this.tileHeight = tileHeight;\r\n        this.widthInPixels = this.width * tileWidth;\r\n        this.heightInPixels = this.height * tileHeight;\r\n\r\n        //  Update the base tile size on all layers & tiles\r\n        for (var i = 0; i < this.layers.length; i++)\r\n        {\r\n            this.layers[i].baseTileWidth = tileWidth;\r\n            this.layers[i].baseTileHeight = tileHeight;\r\n\r\n            var mapData = this.layers[i].data;\r\n            var mapWidth = this.layers[i].width;\r\n            var mapHeight = this.layers[i].height;\r\n\r\n            for (var row = 0; row < mapHeight; row++)\r\n            {\r\n                for (var col = 0; col < mapWidth; col++)\r\n                {\r\n                    var tile = mapData[row][col];\r\n\r\n                    if (tile !== null)\r\n                    {\r\n                        tile.setSize(undefined, undefined, tileWidth, tileHeight);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tile size for a specific `layer`. Note: this does not necessarily match the maps\r\n     * tileWidth and tileHeight for all layers. This will set the tile size for the layer and any\r\n     * tiles the layer has.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setLayerTileSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileWidth - The width of the tiles (in pixels) in the layer.\r\n     * @param {number} tileHeight - The height of the tiles (in pixels) in the layer.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The name of the layer from Tiled, the index of the layer in the map or a TilemapLayer. If not given will default to the maps current layer index.\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    setLayerTileSize: function (tileWidth, tileHeight, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return this; }\r\n\r\n        layer.tileWidth = tileWidth;\r\n        layer.tileHeight = tileHeight;\r\n\r\n        var mapData = layer.data;\r\n        var mapWidth = layer.width;\r\n        var mapHeight = layer.height;\r\n\r\n        for (var row = 0; row < mapHeight; row++)\r\n        {\r\n            for (var col = 0; col < mapWidth; col++)\r\n            {\r\n                var tile = mapData[row][col];\r\n\r\n                if (tile !== null)\r\n                {\r\n                    tile.setSize(tileWidth, tileHeight);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given\r\n     * layer. It will only randomize the tiles in that area, so if they're all the same nothing will\r\n     * appear to have changed! This method only modifies tile indexes and does not change collision\r\n     * information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#shuffle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    shuffle: function (tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.Shuffle(tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision\r\n     * information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#swapByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileA - First tile index.\r\n     * @param {number} tileB - Second tile index.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    swapByIndex: function (indexA, indexB, tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    tileToWorldX: function (tileX, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.TileToWorldX(tileX, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    tileToWorldY: function (tileY, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.TileToWorldY(tileY, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Math.Vector2} [vec2] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Math.Vector2} Returns a Vector2, or null if the layer given was invalid.\r\n     */\r\n    tileToWorldXY: function (tileX, tileY, vec2, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.TileToWorldXY(tileX, tileY, vec2, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. New indexes are drawn from the given\r\n     * weightedIndexes array. An example weighted array:\r\n     *\r\n     * [\r\n     *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n     *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n     *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n     *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n     * ]\r\n     *\r\n     * The probability of any index being picked is (the indexs weight) / (sum of all weights). This\r\n     * method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#weightedRandomize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object[]} weightedIndexes - An array of objects to randomly draw from during randomization. They should be in the form: { index: 0, weight: 4 } or { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    weightedRandomize: function (weightedIndexes, tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    worldToTileX: function (worldX, snapToFloor, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.WorldToTileX(worldX, snapToFloor, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    worldToTileY: function (worldY, snapToFloor, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.WorldToTileY(worldY, snapToFloor, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Math.Vector2} [vec2] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Math.Vector2} Returns a vec2, or null if the layer given was invalid.\r\n     */\r\n    worldToTileXY: function (worldX, worldY, snapToFloor, vec2, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.WorldToTileXY(worldX, worldY, snapToFloor, vec2, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Removes all layer data from this Tilemap and nulls the scene reference. This will destroy any\r\n     * TilemapLayers that have been created.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllLayers();\r\n\r\n        this.tilesets.length = 0;\r\n        this.objects.length = 0;\r\n\r\n        this.scene = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Tilemap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectCreator = require('../gameobjects/GameObjectCreator');\r\nvar ParseToTilemap = require('./ParseToTilemap');\r\n\r\n/**\r\n * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.\r\n * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing\r\n * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map\r\n * data. For an empty map, you should specify tileWidth, tileHeight, width & height.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#tilemap\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Types.Tilemaps.TilemapConfig} [config] - The config options for the Tilemap.\r\n * \r\n * @return {Phaser.Tilemaps.Tilemap}\r\n */\r\nGameObjectCreator.register('tilemap', function (config)\r\n{\r\n    // Defaults are applied in ParseToTilemap\r\n    var c = (config !== undefined) ? config : {};\r\n\r\n    return ParseToTilemap(\r\n        this.scene,\r\n        c.key,\r\n        c.tileWidth,\r\n        c.tileHeight,\r\n        c.width,\r\n        c.height,\r\n        c.data,\r\n        c.insertNull\r\n    );\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../gameobjects/GameObjectFactory');\r\nvar ParseToTilemap = require('./ParseToTilemap');\r\n\r\n/**\r\n * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.\r\n * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing\r\n * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map\r\n * data. For an empty map, you should specify tileWidth, tileHeight, width & height.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#tilemap\r\n * @since 3.0.0\r\n *\r\n * @param {string} [key] - The key in the Phaser cache that corresponds to the loaded tilemap data.\r\n * @param {number} [tileWidth=32] - The width of a tile in pixels. Pass in `null` to leave as the\r\n * default.\r\n * @param {number} [tileHeight=32] - The height of a tile in pixels. Pass in `null` to leave as the\r\n * default.\r\n * @param {number} [width=10] - The width of the map in tiles. Pass in `null` to leave as the\r\n * default.\r\n * @param {number} [height=10] - The height of the map in tiles. Pass in `null` to leave as the\r\n * default.\r\n * @param {number[][]} [data] - Instead of loading from the cache, you can also load directly from\r\n * a 2D array of tile indexes. Pass in `null` for no data.\r\n * @param {boolean} [insertNull=false] - Controls how empty tiles, tiles with an index of -1, in the\r\n * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n * \r\n * @return {Phaser.Tilemaps.Tilemap}\r\n */\r\nGameObjectFactory.register('tilemap', function (key, tileWidth, tileHeight, width, height, data, insertNull)\r\n{\r\n    // Allow users to specify null to indicate that they want the default value, since null is\r\n    // shorter & more legible than undefined. Convert null to undefined to allow ParseToTilemap\r\n    // defaults to take effect.\r\n\r\n    if (key === null) { key = undefined; }\r\n    if (tileWidth === null) { tileWidth = undefined; }\r\n    if (tileHeight === null) { tileHeight = undefined; }\r\n    if (width === null) { width = undefined; }\r\n    if (height === null) { height = undefined; }\r\n\r\n    return ParseToTilemap(this.scene, key, tileWidth, tileHeight, width, height, data, insertNull);\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar Components = require('../gameobjects/components');\r\nvar GameObject = require('../gameobjects/GameObject');\r\nvar TilemapComponents = require('./components');\r\nvar TilemapLayerRender = require('./TilemapLayerRender');\r\n\r\n/**\r\n * @classdesc\r\n * A Tilemap Layer is a Game Object that renders LayerData from a Tilemap when used in combination\r\n * with one, or more, Tilesets.\r\n *\r\n * @class TilemapLayer\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.\r\n * @param {Phaser.Tilemaps.Tilemap} tilemap - The Tilemap this layer is a part of.\r\n * @param {number} layerIndex - The index of the LayerData associated with this layer.\r\n * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n * @param {number} [x=0] - The world x position where the top left of this layer will be placed.\r\n * @param {number} [y=0] - The world y position where the top left of this layer will be placed.\r\n */\r\nvar TilemapLayer = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Components.ScrollFactor,\r\n        TilemapLayerRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function TilemapLayer (scene, tilemap, layerIndex, tileset, x, y)\r\n    {\r\n        GameObject.call(this, scene, 'TilemapLayer');\r\n\r\n        /**\r\n         * Used internally by physics system to perform fast type checks.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#isTilemap\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.isTilemap = true;\r\n\r\n        /**\r\n         * The Tilemap that this layer is a part of.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#tilemap\r\n         * @type {Phaser.Tilemaps.Tilemap}\r\n         * @since 3.50.0\r\n         */\r\n        this.tilemap = tilemap;\r\n\r\n        /**\r\n         * The index of the LayerData associated with this layer.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#layerIndex\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.layerIndex = layerIndex;\r\n\r\n        /**\r\n         * The LayerData associated with this layer. LayerData can only be associated with one\r\n         * tilemap layer.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#layer\r\n         * @type {Phaser.Tilemaps.LayerData}\r\n         * @since 3.50.0\r\n         */\r\n        this.layer = tilemap.layers[layerIndex];\r\n\r\n        // Link the LayerData with this static tilemap layer\r\n        this.layer.tilemapLayer = this;\r\n\r\n        /**\r\n         * An array of `Tileset` objects associated with this layer.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#tileset\r\n         * @type {Phaser.Tilemaps.Tileset[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.tileset = [];\r\n\r\n        /**\r\n         * The total number of tiles drawn by the renderer in the last frame.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#tilesDrawn\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.tilesDrawn = 0;\r\n\r\n        /**\r\n         * The total number of tiles in this layer. Updated every frame.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#tilesTotal\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.tilesTotal = this.layer.width * this.layer.height;\r\n\r\n        /**\r\n         * Used internally during rendering. This holds the tiles that are visible within the Camera.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#culledTiles\r\n         * @type {Phaser.Tilemaps.Tile[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.culledTiles = [];\r\n\r\n        /**\r\n         * You can control if the camera should cull tiles on this layer before rendering them or not.\r\n         *\r\n         * By default the camera will try to cull the tiles in this layer, to avoid over-drawing to the renderer.\r\n         *\r\n         * However, there are some instances when you may wish to disable this, and toggling this flag allows\r\n         * you to do so. Also see `setSkipCull` for a chainable method that does the same thing.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#skipCull\r\n         * @type {boolean}\r\n         * @since 3.50.0\r\n         */\r\n        this.skipCull = false;\r\n\r\n        /**\r\n         * The amount of extra tiles to add into the cull rectangle when calculating its horizontal size.\r\n         *\r\n         * See the method `setCullPadding` for more details.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#cullPaddingX\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.50.0\r\n         */\r\n        this.cullPaddingX = 1;\r\n\r\n        /**\r\n         * The amount of extra tiles to add into the cull rectangle when calculating its vertical size.\r\n         *\r\n         * See the method `setCullPadding` for more details.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#cullPaddingY\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.50.0\r\n         */\r\n        this.cullPaddingY = 1;\r\n\r\n        /**\r\n         * The callback that is invoked when the tiles are culled.\r\n         *\r\n         * It will call a different function based on the map orientation:\r\n         *\r\n         * Orthogonal (the default) is `TilemapComponents.CullTiles`\r\n         * Isometric is `TilemapComponents.IsometricCullTiles`\r\n         * Hexagonal is `TilemapComponents.HexagonalCullTiles`\r\n         * Staggered is `TilemapComponents.StaggeredCullTiles`\r\n         *\r\n         * However, you can override this to call any function you like.\r\n         *\r\n         * It will be sent 4 arguments:\r\n         *\r\n         * 1. The Phaser.Tilemaps.LayerData object for this Layer\r\n         * 2. The Camera that is culling the layer. You can check its `dirty` property to see if it has changed since the last cull.\r\n         * 3. A reference to the `culledTiles` array, which should be used to store the tiles you want rendered.\r\n         * 4. The Render Order constant.\r\n         *\r\n         * See the `TilemapComponents.CullTiles` source code for details on implementing your own culling system.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#cullCallback\r\n         * @type {function}\r\n         * @since 3.50.0\r\n         */\r\n        this.cullCallback = TilemapComponents.GetCullTilesFunction(this.layer.orientation);\r\n\r\n        /**\r\n         * The rendering (draw) order of the tiles in this layer.\r\n         *\r\n         * The default is 0 which is 'right-down', meaning it will draw the tiles starting from the top-left,\r\n         * drawing to the right and then moving down to the next row.\r\n         *\r\n         * The draw orders are:\r\n         *\r\n         * 0 = right-down\r\n         * 1 = left-down\r\n         * 2 = right-up\r\n         * 3 = left-up\r\n         *\r\n         * This can be changed via the `setRenderOrder` method.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#_renderOrder\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this._renderOrder = 0;\r\n\r\n        /**\r\n         * An array holding the mapping between the tile indexes and the tileset they belong to.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#gidMap\r\n         * @type {Phaser.Tilemaps.Tileset[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.gidMap = [];\r\n\r\n        this.setTilesets(tileset);\r\n        this.setAlpha(this.layer.alpha);\r\n        this.setPosition(x, y);\r\n        this.setOrigin();\r\n        this.setSize(tilemap.tileWidth * this.layer.width, tilemap.tileHeight * this.layer.height);\r\n\r\n        this.initPipeline();\r\n    },\r\n\r\n    /**\r\n     * Populates the internal `tileset` array with the Tileset references this Layer requires for rendering.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setTilesets\r\n     * @private\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n     */\r\n    setTilesets: function (tilesets)\r\n    {\r\n        var gidMap = [];\r\n        var setList = [];\r\n        var map = this.tilemap;\r\n\r\n        if (!Array.isArray(tilesets))\r\n        {\r\n            tilesets = [ tilesets ];\r\n        }\r\n\r\n        for (var i = 0; i < tilesets.length; i++)\r\n        {\r\n            var tileset = tilesets[i];\r\n\r\n            if (typeof tileset === 'string')\r\n            {\r\n                tileset = map.getTileset(tileset);\r\n            }\r\n\r\n            if (tileset)\r\n            {\r\n                setList.push(tileset);\r\n\r\n                var s = tileset.firstgid;\r\n\r\n                for (var t = 0; t < tileset.total; t++)\r\n                {\r\n                    gidMap[s + t] = tileset;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.gidMap = gidMap;\r\n        this.tileset = setList;\r\n    },\r\n\r\n    /**\r\n     * Sets the rendering (draw) order of the tiles in this layer.\r\n     *\r\n     * The default is 'right-down', meaning it will order the tiles starting from the top-left,\r\n     * drawing to the right and then moving down to the next row.\r\n     *\r\n     * The draw orders are:\r\n     *\r\n     * 0 = right-down\r\n     * 1 = left-down\r\n     * 2 = right-up\r\n     * 3 = left-up\r\n     *\r\n     * Setting the render order does not change the tiles or how they are stored in the layer,\r\n     * it purely impacts the order in which they are rendered.\r\n     *\r\n     * You can provide either an integer (0 to 3), or the string version of the order.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setRenderOrder\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|string)} renderOrder - The render (draw) order value. Either an integer between 0 and 3, or a string: 'right-down', 'left-down', 'right-up' or 'left-up'.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setRenderOrder: function (renderOrder)\r\n    {\r\n        var orders = [ 'right-down', 'left-down', 'right-up', 'left-up' ];\r\n\r\n        if (typeof renderOrder === 'string')\r\n        {\r\n            renderOrder = orders.indexOf(renderOrder);\r\n        }\r\n\r\n        if (renderOrder >= 0 && renderOrder < 4)\r\n        {\r\n            this._renderOrder = renderOrder;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n     * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n     * internally to optimize recalculating faces when only one tile has been changed.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#calculateFacesAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate.\r\n     * @param {number} tileY - The y coordinate.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    calculateFacesAt: function (tileX, tileY)\r\n    {\r\n        TilemapComponents.CalculateFacesAt(tileX, tileY, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n     * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n     * is mostly used internally.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#calculateFacesWithin\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    calculateFacesWithin: function (tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n     * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n     * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n     * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#createFromTiles\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n     * @param {(number|array)} replacements - The tile index, or array of indexes, to change a converted\r\n     * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a\r\n     * one-to-one mapping with the indexes array.\r\n     * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} [spriteConfig] - The config object to pass into the Sprite creator (i.e.\r\n     * scene.make.sprite).\r\n     * @param {Phaser.Scene} [scene] - The Scene to create the Sprites within.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when determining the world XY\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n     */\r\n    createFromTiles: function (indexes, replacements, spriteConfig, scene, camera)\r\n    {\r\n        return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Returns the tiles in the given layer that are within the cameras viewport.\r\n     * This is used internally during rendering.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#cull\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to run the cull check against.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects to render.\r\n     */\r\n    cull: function (camera)\r\n    {\r\n        return this.cullCallback(this.layer, camera, this.culledTiles, this._renderOrder);\r\n    },\r\n\r\n    /**\r\n     * Copies the tiles in the source rectangular area to a new destination (all specified in tile\r\n     * coordinates) within the layer. This copies all tile properties & recalculates collision\r\n     * information in the destination region.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#copy\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} srcTileX - The x coordinate of the area to copy from, in tiles, not pixels.\r\n     * @param {number} srcTileY - The y coordinate of the area to copy from, in tiles, not pixels.\r\n     * @param {number} width - The width of the area to copy, in tiles, not pixels.\r\n     * @param {number} height - The height of the area to copy, in tiles, not pixels.\r\n     * @param {number} destTileX - The x coordinate of the area to copy to, in tiles, not pixels.\r\n     * @param {number} destTileY - The y coordinate of the area to copy to, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    copy: function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces)\r\n    {\r\n        TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the\r\n     * specified index. Tiles will be set to collide if the given index is a colliding index.\r\n     * Collision information in the region will be recalculated.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#fill\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} index - The tile index to fill the area with.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    fill: function (index, tileX, tileY, width, height, recalculateFaces)\r\n    {\r\n        TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n     * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#filterTiles\r\n     * @since 3.50.0\r\n     *\r\n     * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n     * filter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n     */\r\n    filterTiles: function (callback, context, tileX, tileY, width, height, filteringOptions)\r\n    {\r\n        return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n     * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n     * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n     * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n     * the top-left.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#findByIndex\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} index - The tile index value to search for.\r\n     * @param {number} [skip=0] - The number of times to skip a matching tile before returning.\r\n     * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the bottom-right. Otherwise it scans from the top-left.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The first matching Tile object.\r\n     */\r\n    findByIndex: function (findIndex, skip, reverse)\r\n    {\r\n        return TilemapComponents.FindByIndex(findIndex, skip, reverse, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n     * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n     * true. Similar to Array.prototype.find in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#findTile\r\n     * @since 3.50.0\r\n     *\r\n     * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} The first Tile found at the given location.\r\n     */\r\n    findTile: function (callback, context, tileX, tileY, width, height, filteringOptions)\r\n    {\r\n        return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);\r\n    },\r\n\r\n    /**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#forEachTile\r\n     * @since 3.50.0\r\n     *\r\n     * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context, or scope, under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    forEachTile: function (callback, context, tileX, tileY, width, height, filteringOptions)\r\n    {\r\n        TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets a tile at the given tile coordinates from the given layer.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTileAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - X position to get the tile from (given in tile units, not pixels).\r\n     * @param {number} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n     * @param {boolean} [nonNull=false] - If true getTile won't return null for empty tiles, but a Tile object with an index of -1.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The Tile at the given coordinates or null if no tile was found or the coordinates were invalid.\r\n     */\r\n    getTileAt: function (tileX, tileY, nonNull)\r\n    {\r\n        return TilemapComponents.GetTileAt(tileX, tileY, nonNull, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Gets a tile at the given world coordinates from the given layer.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTileAtWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - X position to get the tile from (given in pixels)\r\n     * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n     * @param {boolean} [nonNull=false] - If true, function won't return null for empty tiles, but a Tile object with an index of -1.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates were invalid.\r\n     */\r\n    getTileAtWorldXY: function (worldX, worldY, nonNull, camera)\r\n    {\r\n        return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTilesWithin\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects found within the area.\r\n     */\r\n    getTilesWithin: function (tileX, tileY, width, height, filteringOptions)\r\n    {\r\n        return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n     * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTilesWithinShape\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects found within the shape.\r\n     */\r\n    getTilesWithinShape: function (shape, filteringOptions, camera)\r\n    {\r\n        return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTilesWithinWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The world x coordinate for the top-left of the area.\r\n     * @param {number} worldY - The world y coordinate for the top-left of the area.\r\n     * @param {number} width - The width of the area.\r\n     * @param {number} height - The height of the area.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects found within the area.\r\n     */\r\n    getTilesWithinWorldXY: function (worldX, worldY, width, height, filteringOptions, camera)\r\n    {\r\n        return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#hasTileAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     *\r\n     * @return {boolean} `true` if a tile was found at the given location, otherwise `false`.\r\n     */\r\n    hasTileAt: function (tileX, tileY)\r\n    {\r\n        return TilemapComponents.HasTileAt(tileX, tileY, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#hasTileAtWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     *\r\n     * @return {boolean} `true` if a tile was found at the given location, otherwise `false`.\r\n     */\r\n    hasTileAtWorldXY: function (worldX, worldY, camera)\r\n    {\r\n        return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n     * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n     * location. If you pass in an index, only the index at the specified location will be changed.\r\n     * Collision information will be recalculated at the specified location.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#putTileAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The Tile object that was inserted at the given coordinates.\r\n     */\r\n    putTileAt: function (tile, tileX, tileY, recalculateFaces)\r\n    {\r\n        return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either\r\n     * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the\r\n     * specified location. If you pass in an index, only the index at the specified location will be\r\n     * changed. Collision information will be recalculated at the specified location.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#putTileAtWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {boolean} [recalculateFaces] - `true` if the faces data should be recalculated.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The Tile object that was inserted at the given coordinates.\r\n     */\r\n    putTileAtWorldXY: function (tile, worldX, worldY, recalculateFaces, camera)\r\n    {\r\n        return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified\r\n     * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,\r\n     * all attributes will be copied over to the specified location. If you pass in an index, only the\r\n     * index at the specified location will be changed. Collision information will be recalculated\r\n     * within the region tiles were changed.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#putTilesAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number[]|number[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles or tile indexes to place.\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    putTilesAt: function (tilesArray, tileX, tileY, recalculateFaces)\r\n    {\r\n        TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n     * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n     * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n     * indexes. This method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#randomize\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {number[]} [indexes] - An array of indexes to randomly draw from during randomization.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    randomize: function (tileX, tileY, width, height, indexes)\r\n    {\r\n        TilemapComponents.Randomize(tileX, tileY, width, height, indexes, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the tile at the given tile coordinates in the specified layer and updates the layers\r\n     * collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#removeTileAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} A Tile object.\r\n     */\r\n    removeTileAt: function (tileX, tileY, replaceWithNull, recalculateFaces)\r\n    {\r\n        return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Removes the tile at the given world coordinates in the specified layer and updates the layers\r\n     * collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#removeTileAtWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The Tile object that was removed from the given location.\r\n     */\r\n    removeTileAtWorldXY: function (worldX, worldY, replaceWithNull, recalculateFaces, camera)\r\n    {\r\n        return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to\r\n     * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n     * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n     * wherever you want on the screen.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#renderDebug\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n     * @param {Phaser.Types.Tilemaps.StyleConfig} [styleConfig] - An object specifying the colors to use for the debug drawing.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    renderDebug: function (graphics, styleConfig)\r\n    {\r\n        TilemapComponents.RenderDebug(graphics, styleConfig, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does\r\n     * not change collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#replaceByIndex\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} findIndex - The index of the tile to search for.\r\n     * @param {number} newIndex - The index of the tile to replace it with.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    replaceByIndex: function (findIndex, newIndex, tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * You can control if the Cameras should cull tiles before rendering them or not.\r\n     *\r\n     * By default the camera will try to cull the tiles in this layer, to avoid over-drawing to the renderer.\r\n     *\r\n     * However, there are some instances when you may wish to disable this.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setSkipCull\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [value=true] - Set to `true` to stop culling tiles. Set to `false` to enable culling again.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setSkipCull: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skipCull = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * When a Camera culls the tiles in this layer it does so using its view into the world, building up a\r\n     * rectangle inside which the tiles must exist or they will be culled. Sometimes you may need to expand the size\r\n     * of this 'cull rectangle', especially if you plan on rotating the Camera viewing the layer. Do so\r\n     * by providing the padding values. The values given are in tiles, not pixels. So if the tile width was 32px\r\n     * and you set `paddingX` to be 4, it would add 32px x 4 to the cull rectangle (adjusted for scale)\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCullPadding\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [paddingX=1] - The amount of extra horizontal tiles to add to the cull check padding.\r\n     * @param {number} [paddingY=1] - The amount of extra vertical tiles to add to the cull check padding.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCullPadding: function (paddingX, paddingY)\r\n    {\r\n        if (paddingX === undefined) { paddingX = 1; }\r\n        if (paddingY === undefined) { paddingY = 1; }\r\n\r\n        this.cullPaddingX = paddingX;\r\n        this.cullPaddingY = paddingY;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n     * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n     * collision will be enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollision\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollision: function (indexes, collides, recalculateFaces, updateLayer)\r\n    {\r\n        TilemapComponents.SetCollision(indexes, collides, recalculateFaces, this.layer, updateLayer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n     * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n     * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n     * enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollisionBetween\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} start - The first index of the tile to be set for collision.\r\n     * @param {number} stop - The last index of the tile to be set for collision.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollisionBetween: function (start, stop, collides, recalculateFaces)\r\n    {\r\n        TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n     * that matches the given properties object, its collision flag will be set. The `collides`\r\n     * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n     * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n     * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n     * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n     * \"types\" property that matches any of those values, its collision flag will be updated.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollisionByProperty\r\n     * @since 3.50.0\r\n     *\r\n     * @param {object} properties - An object with tile properties and corresponding values that should be checked.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollisionByProperty: function (properties, collides, recalculateFaces)\r\n    {\r\n        TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n     * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n     * disabled (false). Tile indexes not currently in the layer are not affected.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollisionByExclusion\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number[]} indexes - An array of the tile indexes to not be counted for collision.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollisionByExclusion: function (indexes, collides, recalculateFaces)\r\n    {\r\n        TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the tiles within a layer by checking each tiles collision group data\r\n     * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n     * a tiles collision group, the tile's colliding information will be set. The `collides` parameter\r\n     * controls if collision will be enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollisionFromCollisionGroup\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollisionFromCollisionGroup: function (collides, recalculateFaces)\r\n    {\r\n        TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n     * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n     * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n     * at a specific location on the map then see setTileLocationCallback.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setTileIndexCallback\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|number[])} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for.\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} callbackContext - The context under which the callback is called.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setTileIndexCallback: function (indexes, callback, callbackContext)\r\n    {\r\n        TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.\r\n     * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n     * remove it.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setTileLocationCallback\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {function} [callback] - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} [callbackContext] - The context, or scope, under which the callback is invoked.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setTileLocationCallback: function (tileX, tileY, width, height, callback, callbackContext)\r\n    {\r\n        TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given\r\n     * layer. It will only randomize the tiles in that area, so if they're all the same nothing will\r\n     * appear to have changed! This method only modifies tile indexes and does not change collision\r\n     * information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#shuffle\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    shuffle: function (tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.Shuffle(tileX, tileY, width, height, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision\r\n     * information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#swapByIndex\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileA - First tile index.\r\n     * @param {number} tileB - Second tile index.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    swapByIndex: function (indexA, indexB, tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#tileToWorldX\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {number} The Tile X coordinate converted to pixels.\r\n     */\r\n    tileToWorldX: function (tileX, camera)\r\n    {\r\n        return this.tilemap.tileToWorldX(tileX, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#tileToWorldY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {number} The Tile Y coordinate converted to pixels.\r\n     */\r\n    tileToWorldY: function (tileY, camera)\r\n    {\r\n        return this.tilemap.tileToWorldY(tileY, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#tileToWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Math.Vector2} A Vector2 containing the world coordinates of the Tile.\r\n     */\r\n    tileToWorldXY: function (tileX, tileY, point, camera)\r\n    {\r\n        return this.tilemap.tileToWorldXY(tileX, tileY, point, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. New indexes are drawn from the given\r\n     * weightedIndexes array. An example weighted array:\r\n     *\r\n     * [\r\n     *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n     *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n     *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n     *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n     * ]\r\n     *\r\n     * The probability of any index being choose is (the index's weight) / (sum of all weights). This\r\n     * method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#weightedRandomize\r\n     * @since 3.50.0\r\n     *\r\n     * @param {object[]} weightedIndexes - An array of objects to randomly draw from during randomization. They should be in the form: { index: 0, weight: 4 } or { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    weightedRandomize: function (weightedIndexes, tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#worldToTileX\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {number} The tile X coordinate based on the world value.\r\n     */\r\n    worldToTileX: function (worldX, snapToFloor, camera)\r\n    {\r\n        return this.tilemap.worldToTileX(worldX, snapToFloor, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#worldToTileY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {number} The tile Y coordinate based on the world value.\r\n     */\r\n    worldToTileY: function (worldY, snapToFloor, camera)\r\n    {\r\n        return this.tilemap.worldToTileY(worldY, snapToFloor, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#worldToTileXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Math.Vector2} A Vector2 containing the tile coordinates of the world values.\r\n     */\r\n    worldToTileXY: function (worldX, worldY, snapToFloor, point, camera)\r\n    {\r\n        return this.tilemap.worldToTileXY(worldX, worldY, snapToFloor, point, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Destroys this TilemapLayer and removes its link to the associated LayerData.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#destroy\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [removeFromTilemap=true] - Remove this layer from the parent Tilemap?\r\n     */\r\n    destroy: function (removeFromTilemap)\r\n    {\r\n        if (removeFromTilemap === undefined) { removeFromTilemap = true; }\r\n\r\n        if (!this.tilemap)\r\n        {\r\n            //  Abort, we've already been destroyed\r\n            return;\r\n        }\r\n\r\n        //  Uninstall this layer only if it is still installed on the LayerData object\r\n        if (this.layer.tilemapLayer === this)\r\n        {\r\n            this.layer.tilemapLayer = undefined;\r\n        }\r\n\r\n        if (removeFromTilemap)\r\n        {\r\n            this.tilemap.removeLayer(this);\r\n        }\r\n\r\n        this.tilemap = undefined;\r\n        this.layer = undefined;\r\n        this.culledTiles.length = 0;\r\n        this.cullCallback = null;\r\n\r\n        this.gidMap = [];\r\n        this.tileset = [];\r\n\r\n        GameObject.prototype.destroy.call(this);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = TilemapLayer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TransformMatrix = require('../gameobjects/components/TransformMatrix');\r\n\r\nvar tempMatrix1 = new TransformMatrix();\r\nvar tempMatrix2 = new TransformMatrix();\r\nvar tempMatrix3 = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.Tilemaps.TilemapLayer#renderCanvas\r\n * @since 3.50.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.Tilemaps.TilemapLayer} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TilemapLayerCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var renderTiles = src.cull(camera);\r\n\r\n    var tileCount = renderTiles.length;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (tileCount === 0 || alpha <= 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var camMatrix = tempMatrix1;\r\n    var layerMatrix = tempMatrix2;\r\n    var calcMatrix = tempMatrix3;\r\n\r\n    layerMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\r\n\r\n    camMatrix.copyFrom(camera.matrix);\r\n\r\n    var ctx = renderer.currentContext;\r\n    var gidMap = src.gidMap;\r\n\r\n    ctx.save();\r\n\r\n    if (parentMatrix)\r\n    {\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        layerMatrix.e = src.x;\r\n        layerMatrix.f = src.y;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(layerMatrix, calcMatrix);\r\n\r\n        calcMatrix.copyToContext(ctx);\r\n    }\r\n    else\r\n    {\r\n        layerMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        layerMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        layerMatrix.copyToContext(ctx);\r\n    }\r\n\r\n    if (!renderer.antialias || src.scaleX > 1 || src.scaleY > 1)\r\n    {\r\n        ctx.imageSmoothingEnabled = false;\r\n    }\r\n\r\n    for (var i = 0; i < tileCount; i++)\r\n    {\r\n        var tile = renderTiles[i];\r\n\r\n        var tileset = gidMap[tile.index];\r\n\r\n        if (!tileset)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var image = tileset.image.getSourceImage();\r\n\r\n        var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);\r\n\r\n        if (tileTexCoords === null)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var tileWidth = tileset.tileWidth;\r\n        var tileHeight = tileset.tileHeight;\r\n\r\n        var halfWidth = tileWidth * 0.5;\r\n        var halfHeight = tileHeight * 0.5;\r\n\r\n        tileTexCoords.x += tileset.tileOffset.x;\r\n        tileTexCoords.y += tileset.tileOffset.y;\r\n\r\n        ctx.save();\r\n\r\n        ctx.translate(tile.pixelX + halfWidth, tile.pixelY + halfHeight);\r\n\r\n        if (tile.rotation !== 0)\r\n        {\r\n            ctx.rotate(tile.rotation);\r\n        }\r\n\r\n        if (tile.flipX || tile.flipY)\r\n        {\r\n            ctx.scale((tile.flipX) ? -1 : 1, (tile.flipY) ? -1 : 1);\r\n        }\r\n\r\n        ctx.globalAlpha = alpha * tile.alpha;\r\n\r\n        ctx.drawImage(\r\n            image,\r\n            tileTexCoords.x, tileTexCoords.y,\r\n            tileWidth , tileHeight,\r\n            -halfWidth, -halfHeight,\r\n            tileWidth, tileHeight\r\n        );\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    ctx.restore();\r\n};\r\n\r\nmodule.exports = TilemapLayerCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../utils/NOOP');\r\nvar renderCanvas = require('../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./TilemapLayerWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./TilemapLayerCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Utils = require('../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.Tilemaps.TilemapLayer#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.Tilemaps.TilemapLayer} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n */\r\nvar TilemapLayerWebGLRenderer = function (renderer, src, camera)\r\n{\r\n    var renderTiles = src.cull(camera);\r\n\r\n    var tileCount = renderTiles.length;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (tileCount === 0 || alpha <= 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var gidMap = src.gidMap;\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n    var scrollFactorX = src.scrollFactorX;\r\n    var scrollFactorY = src.scrollFactorY;\r\n\r\n    var x = src.x;\r\n    var y = src.y;\r\n\r\n    var sx = src.scaleX;\r\n    var sy = src.scaleY;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    for (var i = 0; i < tileCount; i++)\r\n    {\r\n        var tile = renderTiles[i];\r\n\r\n        var tileset = gidMap[tile.index];\r\n\r\n        if (!tileset)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);\r\n\r\n        if (tileTexCoords === null)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var texture = tileset.glTexture;\r\n\r\n        var textureUnit = pipeline.setTexture2D(texture, src);\r\n\r\n        var frameWidth = tileset.tileWidth;\r\n        var frameHeight = tileset.tileHeight;\r\n\r\n        var frameX = tileTexCoords.x;\r\n        var frameY = tileTexCoords.y;\r\n\r\n        var tw = tileset.tileWidth * 0.5;\r\n        var th = tileset.tileHeight * 0.5;\r\n\r\n        var tOffsetX = tileset.tileOffset.x;\r\n        var tOffsetY = tileset.tileOffset.y;\r\n\r\n        var tint = getTint(tile.tint, alpha * tile.alpha);\r\n\r\n        pipeline.batchTexture(\r\n            src,\r\n            texture,\r\n            texture.width, texture.height,\r\n            x + tile.pixelX * sx + (tw * sx - tOffsetX), y + tile.pixelY * sy + (th * sy - tOffsetY),\r\n            tile.width, tile.height,\r\n            sx, sy,\r\n            tile.rotation,\r\n            tile.flipX, tile.flipY,\r\n            scrollFactorX, scrollFactorY,\r\n            tw, th,\r\n            frameX, frameY, frameWidth, frameHeight,\r\n            tint, tint, tint, tint, false,\r\n            0, 0,\r\n            camera,\r\n            null,\r\n            true,\r\n            textureUnit\r\n        );\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = TilemapLayerWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Tileset is a combination of an image containing the tiles and a container for data about\r\n * each tile.\r\n *\r\n * @class Tileset\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tileset in the map data.\r\n * @param {number} firstgid - The first tile index this tileset contains.\r\n * @param {number} [tileWidth=32] - Width of each tile (in pixels).\r\n * @param {number} [tileHeight=32] - Height of each tile (in pixels).\r\n * @param {number} [tileMargin=0] - The margin around all tiles in the sheet (in pixels).\r\n * @param {number} [tileSpacing=0] - The spacing between each tile in the sheet (in pixels).\r\n * @param {object} [tileProperties={}] - Custom properties defined per tile in the Tileset.\r\n * These typically are custom properties created in Tiled when editing a tileset.\r\n * @param {object} [tileData={}] - Data stored per tile. These typically are created in Tiled when editing a tileset, e.g. from Tiled's tile collision editor or terrain editor.\r\n * @param {object} [tileOffset={x: 0, y: 0}] - Tile texture drawing offset.\r\n */\r\nvar Tileset = new Class({\r\n\r\n    initialize:\r\n\r\n    function Tileset (name, firstgid, tileWidth, tileHeight, tileMargin, tileSpacing, tileProperties, tileData, tileOffset)\r\n    {\r\n        if (tileWidth === undefined || tileWidth <= 0) { tileWidth = 32; }\r\n        if (tileHeight === undefined || tileHeight <= 0) { tileHeight = 32; }\r\n        if (tileMargin === undefined) { tileMargin = 0; }\r\n        if (tileSpacing === undefined) { tileSpacing = 0; }\r\n        if (tileProperties === undefined) { tileProperties = {}; }\r\n        if (tileData === undefined) { tileData = {}; }\r\n\r\n        /**\r\n         * The name of the Tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = name;\r\n\r\n        /**\r\n         * The starting index of the first tile index this Tileset contains.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#firstgid\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.firstgid = firstgid;\r\n\r\n        /**\r\n         * The width of each tile (in pixels). Use setTileSize to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileWidth\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.tileWidth = tileWidth;\r\n\r\n        /**\r\n         * The height of each tile (in pixels). Use setTileSize to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileHeight\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.tileHeight = tileHeight;\r\n\r\n        /**\r\n         * The margin around the tiles in the sheet (in pixels). Use `setSpacing` to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileMargin\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.tileMargin = tileMargin;\r\n\r\n        /**\r\n         * The spacing between each the tile in the sheet (in pixels). Use `setSpacing` to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileSpacing\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.tileSpacing = tileSpacing;\r\n\r\n        /**\r\n         * Tileset-specific properties per tile that are typically defined in the Tiled editor in the\r\n         * Tileset editor.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileProperties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileProperties = tileProperties;\r\n\r\n        /**\r\n         * Tileset-specific data per tile that are typically defined in the Tiled editor, e.g. within\r\n         * the Tileset collision editor. This is where collision objects and terrain are stored.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileData\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileData = tileData;\r\n\r\n        /**\r\n         * Controls the drawing offset from the tile origin.\r\n         * Defaults to 0x0, no offset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileOffset\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.60.0\r\n         */\r\n        this.tileOffset = new Vector2();\r\n\r\n        if (tileOffset !== undefined)\r\n        {\r\n            this.tileOffset.set(tileOffset.x, tileOffset.y);\r\n        }\r\n\r\n        /**\r\n         * The cached image that contains the individual tiles. Use setImage to set.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#image\r\n         * @type {?Phaser.Textures.Texture}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.image = null;\r\n\r\n        /**\r\n         * The gl texture used by the WebGL renderer.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#glTexture\r\n         * @type {?WebGLTexture}\r\n         * @readonly\r\n         * @since 3.11.0\r\n         */\r\n        this.glTexture = null;\r\n\r\n        /**\r\n         * The number of tile rows in the the tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#rows\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.rows = 0;\r\n\r\n        /**\r\n         * The number of tile columns in the tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#columns\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.columns = 0;\r\n\r\n        /**\r\n         * The total number of tiles in the tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#total\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.total = 0;\r\n\r\n        /**\r\n         * The look-up table to specific tile image texture coordinates (UV in pixels). Each element\r\n         * contains the coordinates for a tile in an object of the form {x, y}.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#texCoordinates\r\n         * @type {object[]}\r\n         * @readonly\r\n         * @since 3.0.0\r\n        */\r\n        this.texCoordinates = [];\r\n    },\r\n\r\n    /**\r\n     * Get a tiles properties that are stored in the Tileset. Returns null if tile index is not\r\n     * contained in this Tileset. This is typically defined in Tiled under the Tileset editor.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileProperties\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?(object|undefined)}\r\n     */\r\n    getTileProperties: function (tileIndex)\r\n    {\r\n        if (!this.containsTileIndex(tileIndex)) { return null; }\r\n\r\n        return this.tileProperties[tileIndex - this.firstgid];\r\n    },\r\n\r\n    /**\r\n     * Get a tile's data that is stored in the Tileset. Returns null if tile index is not contained\r\n     * in this Tileset. This is typically defined in Tiled and will contain both Tileset collision\r\n     * info and terrain mapping.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?object|undefined}\r\n     */\r\n    getTileData: function (tileIndex)\r\n    {\r\n        if (!this.containsTileIndex(tileIndex)) { return null; }\r\n\r\n        return this.tileData[tileIndex - this.firstgid];\r\n    },\r\n\r\n    /**\r\n     * Get a tile's collision group that is stored in the Tileset. Returns null if tile index is not\r\n     * contained in this Tileset. This is typically defined within Tiled's tileset collision editor.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?object}\r\n     */\r\n    getTileCollisionGroup: function (tileIndex)\r\n    {\r\n        var data = this.getTileData(tileIndex);\r\n\r\n        return (data && data.objectgroup) ? data.objectgroup : null;\r\n    },\r\n\r\n    /**\r\n     * Returns true if and only if this Tileset contains the given tile index.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#containsTileIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    containsTileIndex: function (tileIndex)\r\n    {\r\n        return (\r\n            tileIndex >= this.firstgid &&\r\n            tileIndex < (this.firstgid + this.total)\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Returns the texture coordinates (UV in pixels) in the Tileset image for the given tile index.\r\n     * Returns null if tile index is not contained in this Tileset.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileTextureCoordinates\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?object} Object in the form { x, y } representing the top-left UV coordinate\r\n     * within the Tileset image.\r\n     */\r\n    getTileTextureCoordinates: function (tileIndex)\r\n    {\r\n        if (!this.containsTileIndex(tileIndex)) { return null; }\r\n\r\n        return this.texCoordinates[tileIndex - this.firstgid];\r\n    },\r\n\r\n    /**\r\n     * Sets the image associated with this Tileset and updates the tile data (rows, columns, etc.).\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#setImage\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Textures.Texture} texture - The image that contains the tiles.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */\r\n    setImage: function (texture)\r\n    {\r\n        this.image = texture;\r\n\r\n        this.glTexture = texture.get().source.glTexture;\r\n\r\n        this.updateTileData(this.image.source[0].width, this.image.source[0].height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tile width & height and updates the tile data (rows, columns, etc.).\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#setTileSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileWidth] - The width of a tile in pixels.\r\n     * @param {number} [tileHeight] - The height of a tile in pixels.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */\r\n    setTileSize: function (tileWidth, tileHeight)\r\n    {\r\n        if (tileWidth !== undefined) { this.tileWidth = tileWidth; }\r\n        if (tileHeight !== undefined) { this.tileHeight = tileHeight; }\r\n\r\n        if (this.image)\r\n        {\r\n            this.updateTileData(this.image.source[0].width, this.image.source[0].height);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tile margin & spacing and updates the tile data (rows, columns, etc.).\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#setSpacing\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [margin] - The margin around the tiles in the sheet (in pixels).\r\n     * @param {number} [spacing] - The spacing between the tiles in the sheet (in pixels).\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */\r\n    setSpacing: function (margin, spacing)\r\n    {\r\n        if (margin !== undefined) { this.tileMargin = margin; }\r\n        if (spacing !== undefined) { this.tileSpacing = spacing; }\r\n\r\n        if (this.image)\r\n        {\r\n            this.updateTileData(this.image.source[0].width, this.image.source[0].height);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates tile texture coordinates and tileset data.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#updateTileData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} imageWidth - The (expected) width of the image to slice.\r\n     * @param {number} imageHeight - The (expected) height of the image to slice.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */\r\n    updateTileData: function (imageWidth, imageHeight)\r\n    {\r\n        var rowCount = (imageHeight - this.tileMargin * 2 + this.tileSpacing) / (this.tileHeight + this.tileSpacing);\r\n        var colCount = (imageWidth - this.tileMargin * 2 + this.tileSpacing) / (this.tileWidth + this.tileSpacing);\r\n\r\n        if (rowCount % 1 !== 0 || colCount % 1 !== 0)\r\n        {\r\n            console.warn('Image tile area not tile size multiple in: ' + this.name);\r\n        }\r\n\r\n        // In Tiled a tileset image that is not an even multiple of the tile dimensions is truncated\r\n        // - hence the floor when calculating the rows/columns.\r\n        rowCount = Math.floor(rowCount);\r\n        colCount = Math.floor(colCount);\r\n\r\n        this.rows = rowCount;\r\n        this.columns = colCount;\r\n\r\n        // In Tiled, \"empty\" spaces in a tileset count as tiles and hence count towards the gid\r\n        this.total = rowCount * colCount;\r\n\r\n        this.texCoordinates.length = 0;\r\n\r\n        var tx = this.tileMargin;\r\n        var ty = this.tileMargin;\r\n\r\n        for (var y = 0; y < this.rows; y++)\r\n        {\r\n            for (var x = 0; x < this.columns; x++)\r\n            {\r\n                this.texCoordinates.push({ x: tx, y: ty });\r\n                tx += this.tileWidth + this.tileSpacing;\r\n            }\r\n\r\n            tx = this.tileMargin;\r\n            ty += this.tileHeight + this.tileSpacing;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Tileset;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTileAt = require('./GetTileAt');\r\n\r\n/**\r\n * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n * internally to optimize recalculating faces when only one tile has been changed.\r\n *\r\n * @function Phaser.Tilemaps.Components.CalculateFacesAt\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate.\r\n * @param {number} tileY - The y coordinate.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar CalculateFacesAt = function (tileX, tileY, layer)\r\n{\r\n    var tile = GetTileAt(tileX, tileY, true, layer);\r\n    var above = GetTileAt(tileX, tileY - 1, true, layer);\r\n    var below = GetTileAt(tileX, tileY + 1, true, layer);\r\n    var left = GetTileAt(tileX - 1, tileY, true, layer);\r\n    var right = GetTileAt(tileX + 1, tileY, true, layer);\r\n    var tileCollides = tile && tile.collides;\r\n\r\n    // Assume the changed tile has all interesting edges\r\n    if (tileCollides)\r\n    {\r\n        tile.faceTop = true;\r\n        tile.faceBottom = true;\r\n        tile.faceLeft = true;\r\n        tile.faceRight = true;\r\n    }\r\n\r\n    // Reset edges that are shared between tile and its neighbors\r\n    if (above && above.collides)\r\n    {\r\n        if (tileCollides)\r\n        {\r\n            tile.faceTop = false;\r\n        }\r\n\r\n        above.faceBottom = !tileCollides;\r\n    }\r\n\r\n    if (below && below.collides)\r\n    {\r\n        if (tileCollides)\r\n        {\r\n            tile.faceBottom = false;\r\n        }\r\n\r\n        below.faceTop = !tileCollides;\r\n    }\r\n\r\n    if (left && left.collides)\r\n    {\r\n        if (tileCollides)\r\n        {\r\n            tile.faceLeft = false;\r\n        }\r\n\r\n        left.faceRight = !tileCollides;\r\n    }\r\n\r\n    if (right && right.collides)\r\n    {\r\n        if (tileCollides)\r\n        {\r\n            tile.faceRight = false;\r\n        }\r\n\r\n        right.faceLeft = !tileCollides;\r\n    }\r\n\r\n    if (tile && !tile.collides)\r\n    {\r\n        tile.resetFaces();\r\n    }\r\n\r\n    return tile;\r\n};\r\n\r\nmodule.exports = CalculateFacesAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTileAt = require('./GetTileAt');\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n * is mostly used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.CalculateFacesWithin\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar CalculateFacesWithin = function (tileX, tileY, width, height, layer)\r\n{\r\n    var above = null;\r\n    var below = null;\r\n    var left = null;\r\n    var right = null;\r\n\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        var tile = tiles[i];\r\n\r\n        if (tile)\r\n        {\r\n            if (tile.collides)\r\n            {\r\n                above = GetTileAt(tile.x, tile.y - 1, true, layer);\r\n                below = GetTileAt(tile.x, tile.y + 1, true, layer);\r\n                left = GetTileAt(tile.x - 1, tile.y, true, layer);\r\n                right = GetTileAt(tile.x + 1, tile.y, true, layer);\r\n\r\n                tile.faceTop = (above && above.collides) ? false : true;\r\n                tile.faceBottom = (below && below.collides) ? false : true;\r\n                tile.faceLeft = (left && left.collides) ? false : true;\r\n                tile.faceRight = (right && right.collides) ? false : true;\r\n            }\r\n            else\r\n            {\r\n                tile.resetFaces();\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = CalculateFacesWithin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Checks if the given tile coordinate is within the isometric layer bounds, or not.\r\n *\r\n * @function Phaser.Tilemaps.Components.CheckIsoBounds\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to check against.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to run the cull check against.\r\n *\r\n * @return {boolean} Returns `true` if the coordinates are within the iso bounds.\r\n */\r\nvar CheckIsoBounds = function (tileX, tileY, layer, camera)\r\n{\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var cullPaddingX = tilemapLayer.cullPaddingX;\r\n    var cullPaddingY = tilemapLayer.cullPaddingY;\r\n\r\n    var pos = tilemapLayer.tilemap.tileToWorldXY(tileX, tileY, point, camera, tilemapLayer);\r\n\r\n    // we always subtract 1/2 of the tile's height/width to make the culling distance start from the center of the tiles.\r\n    return pos.x > camera.worldView.x + tilemapLayer.scaleX * layer.tileWidth * (-cullPaddingX - 0.5)\r\n        && pos.x < camera.worldView.right + tilemapLayer.scaleX * layer.tileWidth * (cullPaddingX - 0.5)\r\n        && pos.y > camera.worldView.y + tilemapLayer.scaleY * layer.tileHeight * (-cullPaddingY - 1.0)\r\n        && pos.y < camera.worldView.bottom + tilemapLayer.scaleY * layer.tileHeight * (cullPaddingY - 0.5);\r\n};\r\n\r\nmodule.exports = CheckIsoBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\n\r\n/**\r\n * Copies the tiles in the source rectangular area to a new destination (all specified in tile\r\n * coordinates) within the layer. This copies all tile properties & recalculates collision\r\n * information in the destination region.\r\n *\r\n * @function Phaser.Tilemaps.Components.Copy\r\n * @since 3.0.0\r\n *\r\n * @param {number} srcTileX - The x coordinate of the area to copy from, in tiles, not pixels.\r\n * @param {number} srcTileY - The y coordinate of the area to copy from, in tiles, not pixels.\r\n * @param {number} width - The width of the area to copy, in tiles, not pixels.\r\n * @param {number} height - The height of the area to copy, in tiles, not pixels.\r\n * @param {number} destTileX - The x coordinate of the area to copy to, in tiles, not pixels.\r\n * @param {number} destTileY - The y coordinate of the area to copy to, in tiles, not pixels.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar Copy = function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer)\r\n{\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (srcTileX < 0) { srcTileX = 0; }\r\n    if (srcTileY < 0) { srcTileY = 0; }\r\n\r\n    var srcTiles = GetTilesWithin(srcTileX, srcTileY, width, height, null, layer);\r\n\r\n    var offsetX = destTileX - srcTileX;\r\n    var offsetY = destTileY - srcTileY;\r\n\r\n    for (var i = 0; i < srcTiles.length; i++)\r\n    {\r\n        var tileX = srcTiles[i].x + offsetX;\r\n        var tileY = srcTiles[i].y + offsetY;\r\n\r\n        if (tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height)\r\n        {\r\n            if (layer.data[tileY][tileX])\r\n            {\r\n                layer.data[tileY][tileX].copy(srcTiles[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        // Recalculate the faces within the destination area and neighboring tiles\r\n        CalculateFacesWithin(destTileX - 1, destTileY - 1, width + 2, height + 2, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = Copy;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar ReplaceByIndex = require('./ReplaceByIndex');\r\n\r\n/**\r\n * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n *\r\n * @function Phaser.Tilemaps.Components.CreateFromTiles\r\n * @since 3.0.0\r\n *\r\n * @param {(number|number[])} indexes - The tile index, or array of indexes, to create Sprites from.\r\n * @param {(number|number[])} replacements - The tile index, or array of indexes, to change a converted tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a one-to-one mapping with the indexes array.\r\n * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e. scene.make.sprite).\r\n * @param {Phaser.Scene} scene - The Scene to create the Sprites within.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when determining the world XY\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n */\r\nvar CreateFromTiles = function (indexes, replacements, spriteConfig, scene, camera, layer)\r\n{\r\n    if (!spriteConfig) { spriteConfig = {}; }\r\n\r\n    if (!Array.isArray(indexes))\r\n    {\r\n        indexes = [ indexes ];\r\n    }\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (!scene) { scene = tilemapLayer.scene; }\r\n    if (!camera) { camera = scene.cameras.main; }\r\n\r\n    var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);\r\n    var sprites = [];\r\n    var i;\r\n\r\n    for (i = 0; i < tiles.length; i++)\r\n    {\r\n        var tile = tiles[i];\r\n\r\n        if (indexes.indexOf(tile.index) !== -1)\r\n        {\r\n            var point = tilemapLayer.tileToWorldXY(tile.x, tile.y, undefined, camera,layer);\r\n\r\n            spriteConfig.x = point.x;\r\n            spriteConfig.y = point.y;\r\n\r\n            sprites.push(scene.make.sprite(spriteConfig));\r\n        }\r\n    }\r\n\r\n    if (typeof replacements === 'number')\r\n    {\r\n        //  Assume 1 replacement for all types of tile given\r\n        for (i = 0; i < indexes.length; i++)\r\n        {\r\n            ReplaceByIndex(indexes[i], replacements, 0, 0, layer.width, layer.height, layer);\r\n        }\r\n    }\r\n    else if (Array.isArray(replacements))\r\n    {\r\n        //  Assume 1 to 1 mapping with indexes array\r\n        for (i = 0; i < indexes.length; i++)\r\n        {\r\n            ReplaceByIndex(indexes[i], replacements[i], 0, 0, layer.width, layer.height, layer);\r\n        }\r\n    }\r\n\r\n    return sprites;\r\n};\r\n\r\nmodule.exports = CreateFromTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar SnapCeil = require('../../math/snap/SnapCeil');\r\nvar SnapFloor = require('../../math/snap/SnapFloor');\r\n\r\nvar bounds = new Rectangle();\r\n\r\n/**\r\n * Returns the bounds in the given orthogonal layer that are within the cameras viewport.\r\n * This is used internally by the cull tiles function.\r\n *\r\n * @function Phaser.Tilemaps.Components.CullBounds\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n *\r\n * @return {Phaser.Geom.Rectangle} A rectangle containing the culled bounds. If you wish to retain this object, clone it, as it's recycled internally.\r\n */\r\nvar CullBounds = function (layer, camera)\r\n{\r\n    var tilemap = layer.tilemapLayer.tilemap;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    //  We need to use the tile sizes defined for the map as a whole, not the layer,\r\n    //  in order to calculate the bounds correctly. As different sized tiles may be\r\n    //  placed on the grid and we cannot trust layer.baseTileWidth to give us the true size.\r\n    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);\r\n    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);\r\n\r\n    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;\r\n    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;\r\n\r\n    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH, 0, true) - tilemapLayer.cullPaddingY;\r\n    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH, 0, true) + tilemapLayer.cullPaddingY;\r\n\r\n    return bounds.setTo(\r\n        boundsLeft,\r\n        boundsTop,\r\n        (boundsRight - boundsLeft),\r\n        (boundsBottom - boundsTop)\r\n    );\r\n};\r\n\r\nmodule.exports = CullBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CullBounds = require('./CullBounds');\r\nvar RunCull = require('./RunCull');\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.CullTiles\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n * @param {number} [renderOrder=0] - The rendering order constant.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar CullTiles = function (layer, camera, outputArray, renderOrder)\r\n{\r\n    if (outputArray === undefined) { outputArray = []; }\r\n    if (renderOrder === undefined) { renderOrder = 0; }\r\n\r\n    outputArray.length = 0;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    //  Camera world view bounds, snapped for scaled tile size\r\n    //  Cull Padding values are given in tiles, not pixels\r\n    var bounds = CullBounds(layer, camera);\r\n\r\n    if (tilemapLayer.skipCull || tilemapLayer.scrollFactorX !== 1 || tilemapLayer.scrollFactorY !== 1)\r\n    {\r\n        bounds.left = 0;\r\n        bounds.right = layer.width;\r\n        bounds.top = 0;\r\n        bounds.bottom = layer.height;\r\n    }\r\n\r\n    RunCull(layer, bounds, renderOrder, outputArray);\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = CullTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar SetTileCollision = require('./SetTileCollision');\r\n\r\n/**\r\n * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the\r\n * specified index. Tiles will be set to collide if the given index is a colliding index.\r\n * Collision information in the region will be recalculated.\r\n *\r\n * @function Phaser.Tilemaps.Components.Fill\r\n * @since 3.0.0\r\n *\r\n * @param {number} index - The tile index to fill the area with.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The tile layer to use. If not given the current layer is used.\r\n */\r\nvar Fill = function (index, tileX, tileY, width, height, recalculateFaces, layer)\r\n{\r\n    var doesIndexCollide = (layer.collideIndexes.indexOf(index) !== -1);\r\n\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        tiles[i].index = index;\r\n\r\n        SetTileCollision(tiles[i], doesIndexCollide);\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        // Recalculate the faces within the area and neighboring tiles\r\n        CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = Fill;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n *\r\n * @function Phaser.Tilemaps.Components.FilterTiles\r\n * @since 3.0.0\r\n *\r\n * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n * filter.\r\n * @param {object} context - The context under which the callback should be run.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} The filtered array of Tiles.\r\n */\r\nvar FilterTiles = function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);\r\n\r\n    return tiles.filter(callback, context);\r\n};\r\n\r\nmodule.exports = FilterTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n * the top-left.\r\n *\r\n * @function Phaser.Tilemaps.Components.FindByIndex\r\n * @since 3.0.0\r\n *\r\n * @param {number} index - The tile index value to search for.\r\n * @param {number} skip - The number of times to skip a matching tile before returning.\r\n * @param {boolean} reverse - If true it will scan the layer in reverse, starting at the bottom-right. Otherwise it scans from the top-left.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?Phaser.Tilemaps.Tile} The first (or n skipped) tile with the matching index.\r\n */\r\nvar FindByIndex = function (findIndex, skip, reverse, layer)\r\n{\r\n    if (skip === undefined) { skip = 0; }\r\n    if (reverse === undefined) { reverse = false; }\r\n\r\n    var count = 0;\r\n    var tx;\r\n    var ty;\r\n    var tile;\r\n\r\n    if (reverse)\r\n    {\r\n        for (ty = layer.height - 1; ty >= 0; ty--)\r\n        {\r\n            for (tx = layer.width - 1; tx >= 0; tx--)\r\n            {\r\n                tile = layer.data[ty][tx];\r\n                if (tile && tile.index === findIndex)\r\n                {\r\n                    if (count === skip)\r\n                    {\r\n                        return tile;\r\n                    }\r\n                    else\r\n                    {\r\n                        count += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (ty = 0; ty < layer.height; ty++)\r\n        {\r\n            for (tx = 0; tx < layer.width; tx++)\r\n            {\r\n                tile = layer.data[ty][tx];\r\n                if (tile && tile.index === findIndex)\r\n                {\r\n                    if (count === skip)\r\n                    {\r\n                        return tile;\r\n                    }\r\n                    else\r\n                    {\r\n                        count += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nmodule.exports = FindByIndex;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * @callback FindTileCallback\r\n *\r\n * @param {Phaser.Tilemaps.Tile} value - The Tile.\r\n * @param {number} index - The index of the tile.\r\n * @param {Phaser.Tilemaps.Tile[]} array - An array of Tile objects.\r\n *\r\n * @return {boolean} Return `true` if the callback should run, otherwise `false`.\r\n */\r\n\r\n/**\r\n * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n * true. Similar to Array.prototype.find in vanilla JS.\r\n *\r\n * @function Phaser.Tilemaps.Components.FindTile\r\n * @since 3.0.0\r\n *\r\n * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n * @param {object} context - The context under which the callback should be run.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?Phaser.Tilemaps.Tile} A Tile that matches the search, or null if no Tile found\r\n */\r\nvar FindTile = function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);\r\n\r\n    return tiles.find(callback, context) || null;\r\n};\r\n\r\nmodule.exports = FindTile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * @callback EachTileCallback\r\n *\r\n * @param {Phaser.Tilemaps.Tile} value - The Tile.\r\n * @param {number} index - The index of the tile.\r\n * @param {Phaser.Tilemaps.Tile[]} array - An array of Tile objects.\r\n */\r\n\r\n/**\r\n * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n *\r\n * @function Phaser.Tilemaps.Components.ForEachTile\r\n * @since 3.0.0\r\n *\r\n * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n * @param {object} context - The context under which the callback should be run.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar ForEachTile = function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);\r\n\r\n    tiles.forEach(callback, context);\r\n};\r\n\r\nmodule.exports = ForEachTile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar CullTiles = require('./CullTiles');\r\nvar HexagonalCullTiles = require('./HexagonalCullTiles');\r\nvar IsometricCullTiles = require('./IsometricCullTiles');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredCullTiles = require('./StaggeredCullTiles');\r\n\r\n/**\r\n * Gets the correct function to use to cull tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetCullTilesFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to cull tiles for the given map type.\r\n */\r\nvar GetCullTilesFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return CullTiles;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalCullTiles;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredCullTiles;\r\n    }\r\n    else if (orientation === CONST.ISOMETRIC)\r\n    {\r\n        return IsometricCullTiles;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetCullTilesFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar IsInLayerBounds = require('./IsInLayerBounds');\r\n\r\n/**\r\n * Gets a tile at the given tile coordinates from the given layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - X position to get the tile from (given in tile units, not pixels).\r\n * @param {number} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n * @param {boolean} nonNull - If true getTile won't return null for empty tiles, but a Tile object with an index of -1.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates were invalid.\r\n */\r\nvar GetTileAt = function (tileX, tileY, nonNull, layer)\r\n{\r\n    if (nonNull === undefined) { nonNull = false; }\r\n\r\n    if (IsInLayerBounds(tileX, tileY, layer))\r\n    {\r\n        var tile = layer.data[tileY][tileX] || null;\r\n\r\n        if (!tile)\r\n        {\r\n            return null;\r\n        }\r\n        else if (tile.index === -1)\r\n        {\r\n            return nonNull ? tile : null;\r\n        }\r\n        else\r\n        {\r\n            return tile;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        return null;\r\n    }\r\n};\r\n\r\nmodule.exports = GetTileAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTileAt = require('./GetTileAt');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Gets a tile at the given world coordinates from the given layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - X position to get the tile from (given in pixels)\r\n * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n * @param {boolean} nonNull - If true, function won't return null for empty tiles, but a Tile object with an index of -1.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates were invalid.\r\n */\r\nvar GetTileAtWorldXY = function (worldX, worldY, nonNull, camera, layer)\r\n{\r\n    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);\r\n\r\n    return GetTileAt(point.x, point.y, nonNull, layer);\r\n};\r\n\r\nmodule.exports = GetTileAtWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar TileToWorldX = require('./TileToWorldX');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileToWorldXFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetTileToWorldXFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return TileToWorldX;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetTileToWorldXFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar HexagonalTileToWorldXY = require('./HexagonalTileToWorldXY');\r\nvar IsometricTileToWorldXY = require('./IsometricTileToWorldXY');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredTileToWorldXY = require('./StaggeredTileToWorldXY');\r\nvar TileToWorldXY = require('./TileToWorldXY');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileToWorldXYFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetTileToWorldXYFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return TileToWorldXY;\r\n    }\r\n    else if (orientation === CONST.ISOMETRIC)\r\n    {\r\n        return IsometricTileToWorldXY;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalTileToWorldXY;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredTileToWorldXY;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetTileToWorldXYFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar HexagonalTileToWorldY = require('./HexagonalTileToWorldY');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredTileToWorldY = require('./StaggeredTileToWorldY');\r\nvar TileToWorldY = require('./TileToWorldY');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileToWorldYFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetTileToWorldYFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return TileToWorldY;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalTileToWorldY;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredTileToWorldY;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetTileToWorldYFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithin\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\r\nvar GetTilesWithin = function (tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    if (tileX === undefined) { tileX = 0; }\r\n    if (tileY === undefined) { tileY = 0; }\r\n    if (width === undefined) { width = layer.width; }\r\n    if (height === undefined) { height = layer.height; }\r\n    if (!filteringOptions) { filteringOptions = {}; }\r\n\r\n    var isNotEmpty = GetFastValue(filteringOptions, 'isNotEmpty', false);\r\n    var isColliding = GetFastValue(filteringOptions, 'isColliding', false);\r\n    var hasInterestingFace = GetFastValue(filteringOptions, 'hasInterestingFace', false);\r\n\r\n    // Clip x, y to top left of map, while shrinking width/height to match.\r\n    if (tileX < 0)\r\n    {\r\n        width += tileX;\r\n        tileX = 0;\r\n    }\r\n\r\n    if (tileY < 0)\r\n    {\r\n        height += tileY;\r\n        tileY = 0;\r\n    }\r\n\r\n    // Clip width and height to bottom right of map.\r\n    if (tileX + width > layer.width)\r\n    {\r\n        width = Math.max(layer.width - tileX, 0);\r\n    }\r\n\r\n    if (tileY + height > layer.height)\r\n    {\r\n        height = Math.max(layer.height - tileY, 0);\r\n    }\r\n\r\n    var results = [];\r\n\r\n    for (var ty = tileY; ty < tileY + height; ty++)\r\n    {\r\n        for (var tx = tileX; tx < tileX + width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n\r\n            if (tile !== null)\r\n            {\r\n                if (isNotEmpty && tile.index === -1)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (isColliding && !tile.collides)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (hasInterestingFace && !tile.hasInterestingFace)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                results.push(tile);\r\n            }\r\n        }\r\n    }\r\n\r\n    return results;\r\n};\r\n\r\nmodule.exports = GetTilesWithin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Geom = require('../../geom/');\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar Intersects = require('../../geom/intersects/');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar TriangleToRectangle = function (triangle, rect)\r\n{\r\n    return Intersects.RectangleToTriangle(rect, triangle);\r\n};\r\n\r\nvar point = new Vector2();\r\nvar pointStart = new Vector2();\r\nvar pointEnd = new Vector2();\r\n\r\n/**\r\n * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithinShape\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\r\nvar GetTilesWithinShape = function (shape, filteringOptions, camera, layer)\r\n{\r\n    if (shape === undefined) { return []; }\r\n\r\n    // intersectTest is a function with parameters: shape, rect\r\n    var intersectTest = NOOP;\r\n\r\n    if (shape instanceof Geom.Circle)\r\n    {\r\n        intersectTest = Intersects.CircleToRectangle;\r\n    }\r\n    else if (shape instanceof Geom.Rectangle)\r\n    {\r\n        intersectTest = Intersects.RectangleToRectangle;\r\n    }\r\n    else if (shape instanceof Geom.Triangle)\r\n    {\r\n        intersectTest = TriangleToRectangle;\r\n    }\r\n    else if (shape instanceof Geom.Line)\r\n    {\r\n        intersectTest = Intersects.LineToRectangle;\r\n    }\r\n\r\n    // Top left corner of the shapes's bounding box, rounded down to include partial tiles\r\n    layer.tilemapLayer.worldToTileXY(shape.left, shape.top, true, pointStart, camera);\r\n\r\n    var xStart = pointStart.x;\r\n    var yStart = pointStart.y;\r\n\r\n    // Bottom right corner of the shapes's bounding box, rounded up to include partial tiles\r\n    layer.tilemapLayer.worldToTileXY(shape.right, shape.bottom, true, pointEnd, camera);\r\n\r\n    var xEnd = Math.ceil(pointEnd.x);\r\n    var yEnd = Math.ceil(pointEnd.y);\r\n\r\n    // Tiles within bounding rectangle of shape. Bounds are forced to be at least 1 x 1 tile in size\r\n    // to grab tiles for shapes that don't have a height or width (e.g. a horizontal line).\r\n    var width = Math.max(xEnd - xStart, 1);\r\n    var height = Math.max(yEnd - yStart, 1);\r\n\r\n    var tiles = GetTilesWithin(xStart, yStart, width, height, filteringOptions, layer);\r\n\r\n    var tileWidth = layer.tileWidth;\r\n    var tileHeight = layer.tileHeight;\r\n\r\n    if (layer.tilemapLayer)\r\n    {\r\n        tileWidth *= layer.tilemapLayer.scaleX;\r\n        tileHeight *= layer.tilemapLayer.scaleY;\r\n    }\r\n\r\n    var results = [];\r\n    var tileRect = new Geom.Rectangle(0, 0, tileWidth, tileHeight);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        var tile = tiles[i];\r\n\r\n        layer.tilemapLayer.tileToWorldXY(tile.x, tile.y, point, camera);\r\n\r\n        tileRect.x = point.x;\r\n        tileRect.y = point.y;\r\n\r\n        if (intersectTest(shape, tileRect))\r\n        {\r\n            results.push(tile);\r\n        }\r\n    }\r\n\r\n    return results;\r\n};\r\n\r\nmodule.exports = GetTilesWithinShape;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar pointStart = new Vector2();\r\nvar pointEnd = new Vector2();\r\n\r\n/**\r\n * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithinWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The world x coordinate for the top-left of the area.\r\n * @param {number} worldY - The world y coordinate for the top-left of the area.\r\n * @param {number} width - The width of the area.\r\n * @param {number} height - The height of the area.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when factoring in which tiles to return.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\r\nvar GetTilesWithinWorldXY = function (worldX, worldY, width, height, filteringOptions, camera, layer)\r\n{\r\n    var worldToTileXY = layer.tilemapLayer.tilemap._convert.WorldToTileXY;\r\n\r\n    //  Top left corner of the rect, rounded down to include partial tiles\r\n    worldToTileXY(worldX, worldY, true, pointStart, camera, layer);\r\n\r\n    var xStart = pointStart.x;\r\n    var yStart = pointStart.y;\r\n\r\n    //  Bottom right corner of the rect, rounded up to include partial tiles\r\n    worldToTileXY(worldX + width, worldY + height, false, pointEnd, camera, layer);\r\n\r\n    var xEnd = Math.ceil(pointEnd.x);\r\n    var yEnd = Math.ceil(pointEnd.y);\r\n\r\n    return GetTilesWithin(xStart, yStart, xEnd - xStart, yEnd - yStart, filteringOptions, layer);\r\n};\r\n\r\nmodule.exports = GetTilesWithinWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar WorldToTileX = require('./WorldToTileX');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetWorldToTileXFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetWorldToTileXFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return WorldToTileX;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetWorldToTileXFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar HexagonalWorldToTileXY = require('./HexagonalWorldToTileXY');\r\nvar IsometricWorldToTileXY = require('./IsometricWorldToTileXY');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredWorldToTileXY = require('./StaggeredWorldToTileXY');\r\nvar WorldToTileXY = require('./WorldToTileXY');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetWorldToTileXYFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetWorldToTileXYFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return WorldToTileXY;\r\n    }\r\n    else if (orientation === CONST.ISOMETRIC)\r\n    {\r\n        return IsometricWorldToTileXY;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalWorldToTileXY;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredWorldToTileXY;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetWorldToTileXYFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar HexagonalWorldToTileY = require('./HexagonalWorldToTileY');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredWorldToTileY = require('./StaggeredWorldToTileY');\r\nvar WorldToTileY = require('./WorldToTileY');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetWorldToTileYFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetWorldToTileYFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return WorldToTileY;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalWorldToTileY;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredWorldToTileY;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetWorldToTileYFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar IsInLayerBounds = require('./IsInLayerBounds');\r\n\r\n/**\r\n * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n * false if there is no tile or if the tile at that location has an index of -1.\r\n *\r\n * @function Phaser.Tilemaps.Components.HasTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - X position to get the tile from (given in tile units, not pixels).\r\n * @param {number} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n */\r\nvar HasTileAt = function (tileX, tileY, layer)\r\n{\r\n    if (IsInLayerBounds(tileX, tileY, layer))\r\n    {\r\n        var tile = layer.data[tileY][tileX];\r\n\r\n        return (tile !== null && tile.index > -1);\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = HasTileAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar HasTileAt = require('./HasTileAt');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n * false if there is no tile or if the tile at that location has an index of -1.\r\n *\r\n * @function Phaser.Tilemaps.Components.HasTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The X coordinate of the world position.\r\n * @param {number} worldY - The Y coordinate of the world position.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when factoring in which tiles to return.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n */\r\nvar HasTileAtWorldXY = function (worldX, worldY, camera, layer)\r\n{\r\n    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);\r\n\r\n    var tileX = point.x;\r\n    var tileY = point.y;\r\n\r\n    return HasTileAt(tileX, tileY, layer);\r\n};\r\n\r\nmodule.exports = HasTileAtWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SnapCeil = require('../../math/snap/SnapCeil');\r\nvar SnapFloor = require('../../math/snap/SnapFloor');\r\n\r\n/**\r\n * Returns the bounds in the given layer that are within the camera's viewport.\r\n * This is used internally by the cull tiles function.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalCullBounds\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n *\r\n * @return {object} An object containing the `left`, `right`, `top` and `bottom` bounds.\r\n */\r\nvar HexagonalCullBounds = function (layer, camera)\r\n{\r\n    var tilemap = layer.tilemapLayer.tilemap;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    //  We need to use the tile sizes defined for the map as a whole, not the layer,\r\n    //  in order to calculate the bounds correctly. As different sized tiles may be\r\n    //  placed on the grid and we cannot trust layer.baseTileWidth to give us the true size.\r\n    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);\r\n    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);\r\n\r\n    var len = layer.hexSideLength;\r\n    var rowH = ((tileH - len) / 2 + len);\r\n\r\n    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;\r\n    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;\r\n\r\n    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, rowH, 0, true) - tilemapLayer.cullPaddingY;\r\n    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, rowH, 0, true) + tilemapLayer.cullPaddingY;\r\n\r\n    return {\r\n        left: boundsLeft,\r\n        right: boundsRight,\r\n        top: boundsTop,\r\n        bottom: boundsBottom\r\n    };\r\n};\r\n\r\nmodule.exports = HexagonalCullBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CullBounds = require('./HexagonalCullBounds');\r\nvar RunCull = require('./RunCull');\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalCullTiles\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n * @param {number} [renderOrder=0] - The rendering order constant.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar HexagonalCullTiles = function (layer, camera, outputArray, renderOrder)\r\n{\r\n    if (outputArray === undefined) { outputArray = []; }\r\n    if (renderOrder === undefined) { renderOrder = 0; }\r\n\r\n    outputArray.length = 0;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1)\r\n    {\r\n        //  Camera world view bounds, snapped for scaled tile size\r\n        //  Cull Padding values are given in tiles, not pixels\r\n\r\n        var bounds = CullBounds(layer, camera);\r\n\r\n        RunCull(layer, bounds, renderOrder, outputArray);\r\n    }\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = HexagonalCullTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from hexagonal tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalTileToWorldXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in world coordinates.\r\n */\r\nvar HexagonalTileToWorldXY = function (tileX, tileY, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var layerWorldX = 0;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var len = layer.hexSideLength;\r\n    var rowHeight = ((tileHeight - len) / 2 + len);\r\n\r\n    // similar to staggered, because Tiled uses the oddr representation.\r\n    var x = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);\r\n    var y = layerWorldY + tileY * rowHeight;\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = HexagonalTileToWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from hexagonal tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalTileToWorldY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in world coordinates.\r\n */\r\nvar HexagonalTileToWorldY = function (tileY, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (camera === undefined) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var len = tilemapLayer.tilemap.hexSideLength;\r\n\r\n    var rowHeight = ((tileHeight - len) / 2 + len);\r\n\r\n    return layerWorldY + tileY * rowHeight;\r\n};\r\n\r\nmodule.exports = HexagonalTileToWorldY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from world XY coordinates (pixels) to hexagonal tile XY coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalWorldToTileXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinates down to the nearest integer.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in tile units.\r\n */\r\nvar HexagonalWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's horizontal scroll\r\n\r\n        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    var len = layer.hexSideLength;\r\n    var rowHeight = ((tileHeight - len) / 2 + len);\r\n\r\n    // similar to staggered, because Tiled uses the oddr representation.\r\n    var y = (snapToFloor) ? Math.floor((worldY / rowHeight)) : (worldY / rowHeight);\r\n    var x = (snapToFloor) ? Math.floor((worldX - (y % 2) * 0.5 * tileWidth) / tileWidth) : (worldX - (y % 2) * 0.5 * tileWidth) / tileWidth;\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = HexagonalWorldToTileXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from world Y coordinates (pixels) to hexagonal tile Y coordinates (tile units), factoring in the\r\n * layers position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalWorldToTileY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in tile units.\r\n */\r\nvar HexagonalWorldToTileY = function (worldY, snapToFloor, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        //  Find the world position relative to the static or dynamic layer's top left origin,\r\n        //  factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var len = layer.hexSideLength;\r\n\r\n    var rowHeight = ((tileHeight - len) / 2 + len);\r\n\r\n    return (snapToFloor) ? Math.floor(worldY / rowHeight) : worldY / rowHeight;\r\n};\r\n\r\nmodule.exports = HexagonalWorldToTileY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks if the given tile coordinates are within the bounds of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.IsInLayerBounds\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {boolean} `true` if the tile coordinates are within the bounds of the layer, otherwise `false`.\r\n */\r\nvar IsInLayerBounds = function (tileX, tileY, layer)\r\n{\r\n    return (tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height);\r\n};\r\n\r\nmodule.exports = IsInLayerBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CheckIsoBounds = require('./CheckIsoBounds');\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.IsometricCullTiles\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n * @param {number} [renderOrder=0] - The rendering order constant.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar IsometricCullTiles = function (layer, camera, outputArray, renderOrder)\r\n{\r\n    if (outputArray === undefined) { outputArray = []; }\r\n    if (renderOrder === undefined) { renderOrder = 0; }\r\n\r\n    outputArray.length = 0;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var mapData = layer.data;\r\n    var mapWidth = layer.width;\r\n    var mapHeight = layer.height;\r\n\r\n    var drawLeft = 0;\r\n    var drawRight = mapWidth;\r\n    var drawTop = 0;\r\n    var drawBottom = mapHeight;\r\n\r\n    if (!tilemapLayer.skipCull)\r\n    {\r\n        var x;\r\n        var y;\r\n        var tile;\r\n\r\n        if (renderOrder === 0)\r\n        {\r\n            //  right-down\r\n\r\n            for (y = drawTop; y < drawBottom; y++)\r\n            {\r\n                for (x = drawLeft; mapData[y] && x < drawRight; x++)\r\n                {\r\n                    if (CheckIsoBounds(x, y, layer, camera))\r\n                    {\r\n                        tile = mapData[y][x];\r\n\r\n                        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        outputArray.push(tile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (renderOrder === 1)\r\n        {\r\n            //  left-down\r\n\r\n            for (y = drawTop; y < drawBottom; y++)\r\n            {\r\n                for (x = drawRight; mapData[y] && x >= drawLeft; x--)\r\n                {\r\n                    if (CheckIsoBounds(x, y, layer, camera))\r\n                    {\r\n                        tile = mapData[y][x];\r\n\r\n                        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        outputArray.push(tile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (renderOrder === 2)\r\n        {\r\n            //  right-up\r\n\r\n            for (y = drawBottom; y >= drawTop; y--)\r\n            {\r\n                for (x = drawLeft; mapData[y] && x < drawRight; x++)\r\n                {\r\n                    if (CheckIsoBounds(x, y, layer, camera))\r\n                    {\r\n                        tile = mapData[y][x];\r\n\r\n                        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        outputArray.push(tile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (renderOrder === 3)\r\n        {\r\n            //  left-up\r\n\r\n            for (y = drawBottom; y >= drawTop; y--)\r\n            {\r\n                for (x = drawRight; mapData[y] && x >= drawLeft; x--)\r\n                {\r\n                    if (CheckIsoBounds(x, y, layer, camera))\r\n                    {\r\n                        tile = mapData[y][x];\r\n\r\n                        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        outputArray.push(tile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    tilemapLayer.tilesDrawn = outputArray.length;\r\n    tilemapLayer.tilesTotal = mapWidth * mapHeight;\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = IsometricCullTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from isometric tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.IsometricTileToWorldXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in world coordinates.\r\n */\r\nvar IsometricTileToWorldXY = function (tileX, tileY, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var layerWorldX = 0;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var x = layerWorldX + (tileX - tileY) * (tileWidth / 2);\r\n    var y = layerWorldY + (tileX + tileY) * (tileHeight / 2);\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = IsometricTileToWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from world XY coordinates (pixels) to isometric tile XY coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.IsometricWorldToTileXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in tile units.\r\n */\r\nvar IsometricWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's horizontal scroll\r\n\r\n        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    var x = (snapToFloor) ? Math.floor((worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2) : ((worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2);\r\n    var y = (snapToFloor) ? Math.floor((worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2) : ((worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2);\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = IsometricWorldToTileXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tile = require('../Tile');\r\nvar IsInLayerBounds = require('./IsInLayerBounds');\r\nvar CalculateFacesAt = require('./CalculateFacesAt');\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar BuildTilesetIndex = require('../parsers/tiled/BuildTilesetIndex');\r\n\r\n/**\r\n * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n * location. If you pass in an index, only the index at the specified location will be changed.\r\n * Collision information will be recalculated at the specified location.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was created or added to this map.\r\n */\r\nvar PutTileAt = function (tile, tileX, tileY, recalculateFaces, layer)\r\n{\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (!IsInLayerBounds(tileX, tileY, layer))\r\n    {\r\n        return null;\r\n    }\r\n\r\n    var oldTile = layer.data[tileY][tileX];\r\n    var oldTileCollides = oldTile && oldTile.collides;\r\n\r\n    if (tile instanceof Tile)\r\n    {\r\n        if (layer.data[tileY][tileX] === null)\r\n        {\r\n            layer.data[tileY][tileX] = new Tile(layer, tile.index, tileX, tileY, layer.tileWidth, layer.tileHeight);\r\n        }\r\n\r\n        layer.data[tileY][tileX].copy(tile);\r\n    }\r\n    else\r\n    {\r\n        var index = tile;\r\n\r\n        if (layer.data[tileY][tileX] === null)\r\n        {\r\n            layer.data[tileY][tileX] = new Tile(layer, index, tileX, tileY, layer.tileWidth, layer.tileHeight);\r\n        }\r\n        else\r\n        {\r\n            layer.data[tileY][tileX].index = index;\r\n        }\r\n    }\r\n\r\n    // Updating colliding flag on the new tile\r\n    var newTile = layer.data[tileY][tileX];\r\n    var collides = layer.collideIndexes.indexOf(newTile.index) !== -1;\r\n\r\n    // Copy properties from tileset to tiles.\r\n    var tiles = BuildTilesetIndex(layer.tilemapLayer.tilemap);\r\n    var index = tile instanceof Tile ? tile.index : tile;\r\n\r\n    var sid = tiles[index][2];\r\n    var set = layer.tilemapLayer.tileset[sid];\r\n\r\n    newTile.width = set.tileWidth;\r\n    newTile.height = set.tileHeight;\r\n\r\n    SetTileCollision(newTile, collides);\r\n\r\n    // Recalculate faces only if the colliding flag at (tileX, tileY) has changed\r\n    if (recalculateFaces && (oldTileCollides !== newTile.collides))\r\n    {\r\n        CalculateFacesAt(tileX, tileY, layer);\r\n    }\r\n\r\n    return newTile;\r\n};\r\n\r\nmodule.exports = PutTileAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PutTileAt = require('./PutTileAt');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either\r\n * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the\r\n * specified location. If you pass in an index, only the index at the specified location will be\r\n * changed. Collision information will be recalculated at the specified location.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n * @param {number} worldX - The x coordinate, in pixels.\r\n * @param {number} worldY - The y coordinate, in pixels.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was created or added to this map.\r\n */\r\nvar PutTileAtWorldXY = function (tile, worldX, worldY, recalculateFaces, camera, layer)\r\n{\r\n    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);\r\n\r\n    return PutTileAt(tile, point.x, point.y, recalculateFaces, layer);\r\n};\r\n\r\nmodule.exports = PutTileAtWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar PutTileAt = require('./PutTileAt');\r\n\r\n/**\r\n * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified\r\n * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,\r\n * all attributes will be copied over to the specified location. If you pass in an index, only the\r\n * index at the specified location will be changed. Collision information will be recalculated\r\n * within the region tiles were changed.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTilesAt\r\n * @since 3.0.0\r\n *\r\n * @param {(number[]|number[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles or tile indexes to place.\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar PutTilesAt = function (tilesArray, tileX, tileY, recalculateFaces, layer)\r\n{\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (!Array.isArray(tilesArray))\r\n    {\r\n        return null;\r\n    }\r\n\r\n    // Force the input array to be a 2D array\r\n    if (!Array.isArray(tilesArray[0]))\r\n    {\r\n        tilesArray = [ tilesArray ];\r\n    }\r\n\r\n    var height = tilesArray.length;\r\n    var width = tilesArray[0].length;\r\n\r\n    for (var ty = 0; ty < height; ty++)\r\n    {\r\n        for (var tx = 0; tx < width; tx++)\r\n        {\r\n            var tile = tilesArray[ty][tx];\r\n\r\n            PutTileAt(tile, tileX + tx, tileY + ty, false, layer);\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        // Recalculate the faces within the destination area and neighboring tiles\r\n        CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = PutTilesAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar GetRandom = require('../../utils/array/GetRandom');\r\n\r\n/**\r\n * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n * indexes. This method only modifies tile indexes and does not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.Randomize\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {number[]} indexes - An array of indexes to randomly draw from during randomization.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar Randomize = function (tileX, tileY, width, height, indexes, layer)\r\n{\r\n    var i;\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, {}, layer);\r\n\r\n    // If no indices are given, then find all the unique indexes within the specified region\r\n    if (!indexes)\r\n    {\r\n        indexes = [];\r\n\r\n        for (i = 0; i < tiles.length; i++)\r\n        {\r\n            if (indexes.indexOf(tiles[i].index) === -1)\r\n            {\r\n                indexes.push(tiles[i].index);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < tiles.length; i++)\r\n    {\r\n        tiles[i].index = GetRandom(indexes);\r\n    }\r\n};\r\n\r\nmodule.exports = Randomize;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tile = require('../Tile');\r\nvar IsInLayerBounds = require('./IsInLayerBounds');\r\nvar CalculateFacesAt = require('./CalculateFacesAt');\r\n\r\n/**\r\n * Removes the tile at the given tile coordinates in the specified layer and updates the layer's\r\n * collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.RemoveTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate.\r\n * @param {number} tileY - The y coordinate.\r\n * @param {boolean} replaceWithNull - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was removed.\r\n */\r\nvar RemoveTileAt = function (tileX, tileY, replaceWithNull, recalculateFaces, layer)\r\n{\r\n    if (replaceWithNull === undefined) { replaceWithNull = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (!IsInLayerBounds(tileX, tileY, layer))\r\n    {\r\n        return null;\r\n    }\r\n\r\n    var tile = layer.data[tileY][tileX];\r\n\r\n    if (!tile)\r\n    {\r\n        return null;\r\n    }\r\n    else\r\n    {\r\n        layer.data[tileY][tileX] = (replaceWithNull) ? null : new Tile(layer, -1, tileX, tileY, layer.tileWidth, layer.tileHeight);\r\n    }\r\n\r\n    //  Recalculate faces only if the removed tile was a colliding tile\r\n    if (recalculateFaces && tile && tile.collides)\r\n    {\r\n        CalculateFacesAt(tileX, tileY, layer);\r\n    }\r\n\r\n    return tile;\r\n};\r\n\r\nmodule.exports = RemoveTileAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar RemoveTileAt = require('./RemoveTileAt');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Removes the tile at the given world coordinates in the specified layer and updates the layer's\r\n * collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.RemoveTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The x coordinate, in pixels.\r\n * @param {number} worldY - The y coordinate, in pixels.\r\n * @param {boolean} replaceWithNull - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was removed.\r\n */\r\nvar RemoveTileAtWorldXY = function (worldX, worldY, replaceWithNull, recalculateFaces, camera, layer)\r\n{\r\n    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);\r\n\r\n    return RemoveTileAt(point.x, point.y, replaceWithNull, recalculateFaces, layer);\r\n};\r\n\r\nmodule.exports = RemoveTileAtWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar Color = require('../../display/color');\r\n\r\nvar defaultTileColor = new Color(105, 210, 231, 150);\r\nvar defaultCollidingTileColor = new Color(243, 134, 48, 200);\r\nvar defaultFaceColor = new Color(40, 39, 37, 150);\r\n\r\n/**\r\n * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to\r\n * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n * wherever you want on the screen.\r\n *\r\n * @function Phaser.Tilemaps.Components.RenderDebug\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n * @param {Phaser.Types.Tilemaps.DebugStyleOptions} styleConfig - An object specifying the colors to use for the debug drawing.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar RenderDebug = function (graphics, styleConfig, layer)\r\n{\r\n    if (styleConfig === undefined) { styleConfig = {}; }\r\n\r\n    // Default colors without needlessly creating Color objects\r\n    var tileColor = (styleConfig.tileColor !== undefined) ? styleConfig.tileColor : defaultTileColor;\r\n    var collidingTileColor = (styleConfig.collidingTileColor !== undefined) ? styleConfig.collidingTileColor : defaultCollidingTileColor;\r\n    var faceColor = (styleConfig.faceColor !== undefined) ? styleConfig.faceColor : defaultFaceColor;\r\n\r\n    var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);\r\n\r\n    graphics.translateCanvas(layer.tilemapLayer.x, layer.tilemapLayer.y);\r\n    graphics.scaleCanvas(layer.tilemapLayer.scaleX, layer.tilemapLayer.scaleY);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        var tile = tiles[i];\r\n\r\n        var tw = tile.width;\r\n        var th = tile.height;\r\n        var x = tile.pixelX;\r\n        var y = tile.pixelY;\r\n\r\n        var color = tile.collides ? collidingTileColor : tileColor;\r\n\r\n        if (color !== null)\r\n        {\r\n            graphics.fillStyle(color.color, color.alpha / 255);\r\n            graphics.fillRect(x, y, tw, th);\r\n        }\r\n\r\n        // Inset the face line to prevent neighboring tile's lines from overlapping\r\n        x += 1;\r\n        y += 1;\r\n        tw -= 2;\r\n        th -= 2;\r\n\r\n        if (faceColor !== null)\r\n        {\r\n            graphics.lineStyle(1, faceColor.color, faceColor.alpha / 255);\r\n\r\n            if (tile.faceTop) { graphics.lineBetween(x, y, x + tw, y); }\r\n            if (tile.faceRight) { graphics.lineBetween(x + tw, y, x + tw, y + th); }\r\n            if (tile.faceBottom) { graphics.lineBetween(x, y + th, x + tw, y + th); }\r\n            if (tile.faceLeft) { graphics.lineBetween(x, y, x, y + th); }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = RenderDebug;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does\r\n * not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.ReplaceByIndex\r\n * @since 3.0.0\r\n *\r\n * @param {number} findIndex - The index of the tile to search for.\r\n * @param {number} newIndex - The index of the tile to replace it with.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar ReplaceByIndex = function (findIndex, newIndex, tileX, tileY, width, height, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        if (tiles[i] && tiles[i].index === findIndex)\r\n        {\r\n            tiles[i].index = newIndex;\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = ReplaceByIndex;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.RunCull\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {object} bounds - An object containing the `left`, `right`, `top` and `bottom` bounds.\r\n * @param {number} renderOrder - The rendering order constant.\r\n * @param {array} outputArray - The array to store the Tile objects within.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar RunCull = function (layer, bounds, renderOrder, outputArray)\r\n{\r\n    var mapData = layer.data;\r\n    var mapWidth = layer.width;\r\n    var mapHeight = layer.height;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var drawLeft = Math.max(0, bounds.left);\r\n    var drawRight = Math.min(mapWidth, bounds.right);\r\n    var drawTop = Math.max(0, bounds.top);\r\n    var drawBottom = Math.min(mapHeight, bounds.bottom);\r\n\r\n    var x;\r\n    var y;\r\n    var tile;\r\n\r\n    if (renderOrder === 0)\r\n    {\r\n        //  right-down\r\n\r\n        for (y = drawTop; y < drawBottom; y++)\r\n        {\r\n            for (x = drawLeft; mapData[y] && x < drawRight; x++)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n    else if (renderOrder === 1)\r\n    {\r\n        //  left-down\r\n\r\n        for (y = drawTop; y < drawBottom; y++)\r\n        {\r\n            for (x = drawRight; mapData[y] && x >= drawLeft; x--)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n    else if (renderOrder === 2)\r\n    {\r\n        //  right-up\r\n\r\n        for (y = drawBottom; y >= drawTop; y--)\r\n        {\r\n            for (x = drawLeft; mapData[y] && x < drawRight; x++)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n    else if (renderOrder === 3)\r\n    {\r\n        //  left-up\r\n\r\n        for (y = drawBottom; y >= drawTop; y--)\r\n        {\r\n            for (x = drawRight; mapData[y] && x >= drawLeft; x--)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n\r\n    tilemapLayer.tilesDrawn = outputArray.length;\r\n    tilemapLayer.tilesTotal = mapWidth * mapHeight;\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = RunCull;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar SetLayerCollisionIndex = require('./SetLayerCollisionIndex');\r\n\r\n/**\r\n * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n * collision will be enabled (true) or disabled (false).\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollision\r\n * @since 3.0.0\r\n *\r\n * @param {(number|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.\r\n */\r\nvar SetCollision = function (indexes, collides, recalculateFaces, layer, updateLayer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n    if (updateLayer === undefined) { updateLayer = true; }\r\n\r\n    if (!Array.isArray(indexes))\r\n    {\r\n        indexes = [ indexes ];\r\n    }\r\n\r\n    // Update the array of colliding indexes\r\n    for (var i = 0; i < indexes.length; i++)\r\n    {\r\n        SetLayerCollisionIndex(indexes[i], collides, layer);\r\n    }\r\n\r\n    // Update the tiles\r\n    if (updateLayer)\r\n    {\r\n        for (var ty = 0; ty < layer.height; ty++)\r\n        {\r\n            for (var tx = 0; tx < layer.width; tx++)\r\n            {\r\n                var tile = layer.data[ty][tx];\r\n\r\n                if (tile && indexes.indexOf(tile.index) !== -1)\r\n                {\r\n                    SetTileCollision(tile, collides);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollision;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar SetLayerCollisionIndex = require('./SetLayerCollisionIndex');\r\n\r\n/**\r\n * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n * enabled (true) or disabled (false).\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionBetween\r\n * @since 3.0.0\r\n *\r\n * @param {number} start - The first index of the tile to be set for collision.\r\n * @param {number} stop - The last index of the tile to be set for collision.\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.\r\n */\r\nvar SetCollisionBetween = function (start, stop, collides, recalculateFaces, layer, updateLayer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n    if (updateLayer === undefined) { updateLayer = true; }\r\n\r\n    if (start > stop)\r\n    {\r\n        return;\r\n    }\r\n\r\n    //  Update the array of colliding indexes\r\n    for (var index = start; index <= stop; index++)\r\n    {\r\n        SetLayerCollisionIndex(index, collides, layer);\r\n    }\r\n\r\n    //  Update the tiles\r\n    if (updateLayer)\r\n    {\r\n        for (var ty = 0; ty < layer.height; ty++)\r\n        {\r\n            for (var tx = 0; tx < layer.width; tx++)\r\n            {\r\n                var tile = layer.data[ty][tx];\r\n\r\n                if (tile)\r\n                {\r\n                    if (tile.index >= start && tile.index <= stop)\r\n                    {\r\n                        SetTileCollision(tile, collides);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollisionBetween;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar SetLayerCollisionIndex = require('./SetLayerCollisionIndex');\r\n\r\n/**\r\n * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n * disabled (false). Tile indexes not currently in the layer are not affected.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionByExclusion\r\n * @since 3.0.0\r\n *\r\n * @param {number[]} indexes - An array of the tile indexes to not be counted for collision.\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetCollisionByExclusion = function (indexes, collides, recalculateFaces, layer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (!Array.isArray(indexes))\r\n    {\r\n        indexes = [ indexes ];\r\n    }\r\n\r\n    // Note: this only updates layer.collideIndexes for tile indexes found currently in the layer\r\n    for (var ty = 0; ty < layer.height; ty++)\r\n    {\r\n        for (var tx = 0; tx < layer.width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n\r\n            if (tile && indexes.indexOf(tile.index) === -1)\r\n            {\r\n                SetTileCollision(tile, collides);\r\n                SetLayerCollisionIndex(tile.index, collides, layer);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollisionByExclusion;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar HasValue = require('../../utils/object/HasValue');\r\n\r\n/**\r\n * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n * that matches the given properties object, its collision flag will be set. The `collides`\r\n * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n * \"types\" property that matches any of those values, its collision flag will be updated.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionByProperty\r\n * @since 3.0.0\r\n *\r\n * @param {object} properties - An object with tile properties and corresponding values that should be checked.\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetCollisionByProperty = function (properties, collides, recalculateFaces, layer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    for (var ty = 0; ty < layer.height; ty++)\r\n    {\r\n        for (var tx = 0; tx < layer.width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n\r\n            if (!tile) { continue; }\r\n\r\n            for (var property in properties)\r\n            {\r\n                if (!HasValue(tile.properties, property)) { continue; }\r\n\r\n                var values = properties[property];\r\n\r\n                if (!Array.isArray(values))\r\n                {\r\n                    values = [ values ];\r\n                }\r\n\r\n                for (var i = 0; i < values.length; i++)\r\n                {\r\n                    if (tile.properties[property] === values[i])\r\n                    {\r\n                        SetTileCollision(tile, collides);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollisionByProperty;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\n\r\n/**\r\n * Sets collision on the tiles within a layer by checking each tile's collision group data\r\n * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n * a tile's collision group, the tile's colliding information will be set. The `collides` parameter\r\n * controls if collision will be enabled (true) or disabled (false).\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionFromCollisionGroup\r\n * @since 3.0.0\r\n *\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetCollisionFromCollisionGroup = function (collides, recalculateFaces, layer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    for (var ty = 0; ty < layer.height; ty++)\r\n    {\r\n        for (var tx = 0; tx < layer.width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n\r\n            if (!tile) { continue; }\r\n\r\n            var collisionGroup = tile.getCollisionGroup();\r\n\r\n            // It's possible in Tiled to have a collision group without any shapes, e.g. create a\r\n            // shape and then delete the shape.\r\n            if (collisionGroup && collisionGroup.objects && collisionGroup.objects.length > 0)\r\n            {\r\n                SetTileCollision(tile, collides);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollisionFromCollisionGroup;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Internally used method to keep track of the tile indexes that collide within a layer. This\r\n * updates LayerData.collideIndexes to either contain or not contain the given `tileIndex`.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetLayerCollisionIndex\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileIndex - The tile index to set the collision boolean for.\r\n * @param {boolean} collides - Should the tile index collide or not?\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetLayerCollisionIndex = function (tileIndex, collides, layer)\r\n{\r\n    var loc = layer.collideIndexes.indexOf(tileIndex);\r\n\r\n    if (collides && loc === -1)\r\n    {\r\n        layer.collideIndexes.push(tileIndex);\r\n    }\r\n    else if (!collides && loc !== -1)\r\n    {\r\n        layer.collideIndexes.splice(loc, 1);\r\n    }\r\n};\r\n\r\nmodule.exports = SetLayerCollisionIndex;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Internally used method to set the colliding state of a tile. This does not recalculate\r\n * interesting faces.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetTileCollision\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.Tile} tile - The Tile to set the collision on.\r\n * @param {boolean} [collides=true] - Should the tile index collide or not?\r\n */\r\nvar SetTileCollision = function (tile, collides)\r\n{\r\n    if (collides)\r\n    {\r\n        tile.setCollision(true, true, true, true, false);\r\n    }\r\n    else\r\n    {\r\n        tile.resetCollision(false);\r\n    }\r\n};\r\n\r\nmodule.exports = SetTileCollision;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n * at a specific location on the map then see setTileLocationCallback.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetTileIndexCallback\r\n * @since 3.0.0\r\n *\r\n * @param {(number|array)} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for.\r\n * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n * @param {object} callbackContext - The context under which the callback is called.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetTileIndexCallback = function (indexes, callback, callbackContext, layer)\r\n{\r\n    if (typeof indexes === 'number')\r\n    {\r\n        layer.callbacks[indexes] = (callback !== null)\r\n            ? { callback: callback, callbackContext: callbackContext }\r\n            : undefined;\r\n    }\r\n    else\r\n    {\r\n        for (var i = 0, len = indexes.length; i < len; i++)\r\n        {\r\n            layer.callbacks[indexes[i]] = (callback !== null)\r\n                ? { callback: callback, callbackContext: callbackContext }\r\n                : undefined;\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = SetTileIndexCallback;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.\r\n * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n * remove it.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetTileLocationCallback\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n * @param {object} callbackContext - The context under which the callback is called.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetTileLocationCallback = function (tileX, tileY, width, height, callback, callbackContext, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        tiles[i].setCollisionCallback(callback, callbackContext);\r\n    }\r\n};\r\n\r\nmodule.exports = SetTileLocationCallback;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar ShuffleArray = require('../../utils/array/Shuffle');\r\n\r\n/**\r\n * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given\r\n * layer. It will only randomize the tiles in that area, so if they're all the same nothing will\r\n * appear to have changed! This method only modifies tile indexes and does not change collision\r\n * information.\r\n *\r\n * @function Phaser.Tilemaps.Components.Shuffle\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar Shuffle = function (tileX, tileY, width, height, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    var indexes = tiles.map(function (tile) { return tile.index; });\r\n\r\n    ShuffleArray(indexes);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        tiles[i].index = indexes[i];\r\n    }\r\n};\r\n\r\nmodule.exports = Shuffle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SnapCeil = require('../../math/snap/SnapCeil');\r\nvar SnapFloor = require('../../math/snap/SnapFloor');\r\n\r\n/**\r\n * Returns the bounds in the given layer that are within the camera's viewport.\r\n * This is used internally by the cull tiles function.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredCullBounds\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n *\r\n * @return {object} An object containing the `left`, `right`, `top` and `bottom` bounds.\r\n */\r\nvar StaggeredCullBounds = function (layer, camera)\r\n{\r\n    var tilemap = layer.tilemapLayer.tilemap;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    //  We need to use the tile sizes defined for the map as a whole, not the layer,\r\n    //  in order to calculate the bounds correctly. As different sized tiles may be\r\n    //  placed on the grid and we cannot trust layer.baseTileWidth to give us the true size.\r\n    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);\r\n    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);\r\n\r\n    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;\r\n    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;\r\n\r\n    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH / 2, 0, true) - tilemapLayer.cullPaddingY;\r\n    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH / 2, 0, true) + tilemapLayer.cullPaddingY;\r\n\r\n    return {\r\n        left: boundsLeft,\r\n        right: boundsRight,\r\n        top: boundsTop,\r\n        bottom: boundsBottom\r\n    };\r\n};\r\n\r\nmodule.exports = StaggeredCullBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CullBounds = require('./StaggeredCullBounds');\r\nvar RunCull = require('./RunCull');\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredCullTiles\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n * @param {number} [renderOrder=0] - The rendering order constant.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar StaggeredCullTiles = function (layer, camera, outputArray, renderOrder)\r\n{\r\n    if (outputArray === undefined) { outputArray = []; }\r\n    if (renderOrder === undefined) { renderOrder = 0; }\r\n\r\n    outputArray.length = 0;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1)\r\n    {\r\n        //  Camera world view bounds, snapped for scaled tile size\r\n        //  Cull Padding values are given in tiles, not pixels\r\n\r\n        var bounds = CullBounds(layer, camera);\r\n\r\n        RunCull(layer, bounds, renderOrder, outputArray);\r\n    }\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = StaggeredCullTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from staggered tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredTileToWorldXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in world coordinates.\r\n */\r\nvar StaggeredTileToWorldXY = function (tileX, tileY, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var layerWorldX = 0;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var x = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);\r\n    var y = layerWorldY + tileY * (tileHeight / 2);\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = StaggeredTileToWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from staggered tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n * layers position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredTileToWorldY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in world coordinates.\r\n */\r\nvar StaggeredTileToWorldY = function (tileY, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (camera === undefined) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    return layerWorldY + tileY * (tileHeight / 2) + tileHeight;\r\n};\r\n\r\nmodule.exports = StaggeredTileToWorldY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from world XY coordinates (pixels) to staggered tile XY coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredWorldToTileXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in tile units.\r\n */\r\nvar StaggeredWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's horizontal scroll\r\n\r\n        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    var y = (snapToFloor) ? Math.floor((worldY / (tileHeight / 2))) : (worldY / (tileHeight / 2));\r\n    var x = (snapToFloor) ? Math.floor((worldX + (y % 2) * 0.5 * tileWidth) / tileWidth) : (worldX + (y % 2) * 0.5 * tileWidth) / tileWidth;\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = StaggeredWorldToTileXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from world Y coordinates (pixels) to staggered tile Y coordinates (tile units), factoring in the\r\n * layers position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredWorldToTileY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in tile units.\r\n */\r\nvar StaggeredWorldToTileY = function (worldY, snapToFloor, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        //  Find the world position relative to the static or dynamic layer's top left origin,\r\n        //  factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    return (snapToFloor) ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);\r\n};\r\n\r\nmodule.exports = StaggeredWorldToTileY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision\r\n * information.\r\n *\r\n * @function Phaser.Tilemaps.Components.SwapByIndex\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileA - First tile index.\r\n * @param {number} tileB - Second tile index.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SwapByIndex = function (indexA, indexB, tileX, tileY, width, height, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        if (tiles[i])\r\n        {\r\n            if (tiles[i].index === indexA)\r\n            {\r\n                tiles[i].index = indexB;\r\n            }\r\n            else if (tiles[i].index === indexB)\r\n            {\r\n                tiles[i].index = indexA;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = SwapByIndex;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.TileToWorldX\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number}\r\n */\r\nvar TileToWorldX = function (tileX, camera, layer)\r\n{\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n    var layerWorldX = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    return layerWorldX + tileX * tileWidth;\r\n};\r\n\r\nmodule.exports = TileToWorldX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TileToWorldX = require('./TileToWorldX');\r\nvar TileToWorldY = require('./TileToWorldY');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.TileToWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in world coordinates.\r\n */\r\nvar TileToWorldXY = function (tileX, tileY, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(0, 0); }\r\n\r\n    point.x = TileToWorldX(tileX, camera, layer);\r\n    point.y = TileToWorldY(tileY, camera, layer);\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = TileToWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.TileToWorldY\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in world coordinates.\r\n */\r\nvar TileToWorldY = function (tileY, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    return layerWorldY + tileY * tileHeight;\r\n};\r\n\r\nmodule.exports = TileToWorldY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n * specified layer. Each tile will receive a new index. New indexes are drawn from the given\r\n * weightedIndexes array. An example weighted array:\r\n *\r\n * [\r\n *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n * ]\r\n *\r\n * The probability of any index being choose is (the index's weight) / (sum of all weights). This\r\n * method only modifies tile indexes and does not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.WeightedRandomize\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {object[]} weightedIndexes - An array of objects to randomly draw from during\r\n * randomization. They should be in the form: { index: 0, weight: 4 } or\r\n * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar WeightedRandomize = function (tileX, tileY, width, height, weightedIndexes, layer)\r\n{\r\n    if (!weightedIndexes) { return; }\r\n\r\n    var i;\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    var weightTotal = 0;\r\n\r\n    for (i = 0; i < weightedIndexes.length; i++)\r\n    {\r\n        weightTotal += weightedIndexes[i].weight;\r\n    }\r\n\r\n    if (weightTotal <= 0) { return; }\r\n\r\n    for (i = 0; i < tiles.length; i++)\r\n    {\r\n        var rand = Math.random() * weightTotal;\r\n        var sum = 0;\r\n        var randomIndex = -1;\r\n\r\n        for (var j = 0; j < weightedIndexes.length; j++)\r\n        {\r\n            sum += weightedIndexes[j].weight;\r\n\r\n            if (rand <= sum)\r\n            {\r\n                var chosen = weightedIndexes[j].index;\r\n\r\n                randomIndex = Array.isArray(chosen)\r\n                    ? chosen[Math.floor(Math.random() * chosen.length)]\r\n                    : chosen;\r\n                break;\r\n            }\r\n        }\r\n\r\n        tiles[i].index = randomIndex;\r\n    }\r\n};\r\n\r\nmodule.exports = WeightedRandomize;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.WorldToTileX\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {?Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The X location in tile units.\r\n */\r\nvar WorldToTileX = function (worldX, snapToFloor, camera, layer)\r\n{\r\n    if (snapToFloor === undefined) { snapToFloor = true; }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's horizontal scroll\r\n        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    return (snapToFloor) ? Math.floor(worldX / tileWidth) : worldX / tileWidth;\r\n};\r\n\r\nmodule.exports = WorldToTileX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar WorldToTileX = require('./WorldToTileX');\r\nvar WorldToTileY = require('./WorldToTileY');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.WorldToTileXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in tile units.\r\n */\r\nvar WorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)\r\n{\r\n    if (snapToFloor === undefined) { snapToFloor = true; }\r\n    if (!point) { point = new Vector2(0, 0); }\r\n\r\n    point.x = WorldToTileX(worldX, snapToFloor, camera, layer);\r\n    point.y = WorldToTileY(worldY, snapToFloor, camera, layer);\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = WorldToTileXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.WorldToTileY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {?Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in tile units.\r\n */\r\nvar WorldToTileY = function (worldY, snapToFloor, camera, layer)\r\n{\r\n    if (snapToFloor === undefined) { snapToFloor = true; }\r\n\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's vertical scroll\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    return (snapToFloor) ? Math.floor(worldY / tileHeight) : worldY / tileHeight;\r\n};\r\n\r\nmodule.exports = WorldToTileY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Components\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    CalculateFacesAt: require('./CalculateFacesAt'),\r\n    CalculateFacesWithin: require('./CalculateFacesWithin'),\r\n    CheckIsoBounds: require('./CheckIsoBounds'),\r\n    Copy: require('./Copy'),\r\n    CreateFromTiles: require('./CreateFromTiles'),\r\n    CullBounds: require('./CullBounds'),\r\n    CullTiles: require('./CullTiles'),\r\n    Fill: require('./Fill'),\r\n    FilterTiles: require('./FilterTiles'),\r\n    FindByIndex: require('./FindByIndex'),\r\n    FindTile: require('./FindTile'),\r\n    ForEachTile: require('./ForEachTile'),\r\n    GetCullTilesFunction: require('./GetCullTilesFunction'),\r\n    GetTileAt: require('./GetTileAt'),\r\n    GetTileAtWorldXY: require('./GetTileAtWorldXY'),\r\n    GetTilesWithin: require('./GetTilesWithin'),\r\n    GetTilesWithinShape: require('./GetTilesWithinShape'),\r\n    GetTilesWithinWorldXY: require('./GetTilesWithinWorldXY'),\r\n    GetTileToWorldXFunction: require('./GetTileToWorldXFunction'),\r\n    GetTileToWorldXYFunction: require('./GetTileToWorldXYFunction'),\r\n    GetTileToWorldYFunction: require('./GetTileToWorldYFunction'),\r\n    GetWorldToTileXFunction: require('./GetWorldToTileXFunction'),\r\n    GetWorldToTileXYFunction: require('./GetWorldToTileXYFunction'),\r\n    GetWorldToTileYFunction: require('./GetWorldToTileYFunction'),\r\n    HasTileAt: require('./HasTileAt'),\r\n    HasTileAtWorldXY: require('./HasTileAtWorldXY'),\r\n    HexagonalCullBounds: require('./HexagonalCullBounds'),\r\n    HexagonalCullTiles: require('./HexagonalCullTiles'),\r\n    HexagonalTileToWorldXY: require('./HexagonalTileToWorldXY'),\r\n    HexagonalTileToWorldY: require('./HexagonalTileToWorldY'),\r\n    HexagonalWorldToTileXY: require('./HexagonalWorldToTileXY'),\r\n    HexagonalWorldToTileY: require('./HexagonalWorldToTileY'),\r\n    IsInLayerBounds: require('./IsInLayerBounds'),\r\n    IsometricCullTiles: require('./IsometricCullTiles'),\r\n    IsometricTileToWorldXY: require('./IsometricTileToWorldXY'),\r\n    IsometricWorldToTileXY: require('./IsometricWorldToTileXY'),\r\n    PutTileAt: require('./PutTileAt'),\r\n    PutTileAtWorldXY: require('./PutTileAtWorldXY'),\r\n    PutTilesAt: require('./PutTilesAt'),\r\n    Randomize: require('./Randomize'),\r\n    RemoveTileAt: require('./RemoveTileAt'),\r\n    RemoveTileAtWorldXY: require('./RemoveTileAtWorldXY'),\r\n    RenderDebug: require('./RenderDebug'),\r\n    ReplaceByIndex: require('./ReplaceByIndex'),\r\n    RunCull: require('./RunCull'),\r\n    SetCollision: require('./SetCollision'),\r\n    SetCollisionBetween: require('./SetCollisionBetween'),\r\n    SetCollisionByExclusion: require('./SetCollisionByExclusion'),\r\n    SetCollisionByProperty: require('./SetCollisionByProperty'),\r\n    SetCollisionFromCollisionGroup: require('./SetCollisionFromCollisionGroup'),\r\n    SetLayerCollisionIndex: require('./SetLayerCollisionIndex'),\r\n    SetTileCollision: require('./SetTileCollision'),\r\n    SetTileIndexCallback: require('./SetTileIndexCallback'),\r\n    SetTileLocationCallback: require('./SetTileLocationCallback'),\r\n    Shuffle: require('./Shuffle'),\r\n    StaggeredCullBounds: require('./StaggeredCullBounds'),\r\n    StaggeredCullTiles: require('./StaggeredCullTiles'),\r\n    StaggeredTileToWorldXY: require('./StaggeredTileToWorldXY'),\r\n    StaggeredTileToWorldY: require('./StaggeredTileToWorldY'),\r\n    StaggeredWorldToTileXY: require('./StaggeredWorldToTileXY'),\r\n    StaggeredWorldToTileY: require('./StaggeredWorldToTileY'),\r\n    SwapByIndex: require('./SwapByIndex'),\r\n    TileToWorldX: require('./TileToWorldX'),\r\n    TileToWorldXY: require('./TileToWorldXY'),\r\n    TileToWorldY: require('./TileToWorldY'),\r\n    WeightedRandomize: require('./WeightedRandomize'),\r\n    WorldToTileX: require('./WorldToTileX'),\r\n    WorldToTileXY: require('./WorldToTileXY'),\r\n    WorldToTileY: require('./WorldToTileY')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Phaser Tilemap constants for orientation.\r\n * \r\n * @namespace Phaser.Tilemaps.Orientation\r\n * @memberof Phaser.Tilemaps\r\n * @since 3.50.0\r\n */\r\n\r\n/**\r\n * Phaser Tilemap constants for orientation.\r\n * \r\n * To find out what each mode does please see [Phaser.Tilemaps.Orientation]{@link Phaser.Tilemaps.Orientation}.\r\n * \r\n * @typedef {Phaser.Tilemaps.Orientation} Phaser.Tilemaps.OrientationType\r\n * @memberof Phaser.Tilemaps\r\n * @since 3.50.0\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * Orthogonal Tilemap orientation constant.\r\n     * \r\n     * @name Phaser.Tilemaps.Orientation.ORTHOGONAL\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    ORTHOGONAL: 0,\r\n\r\n    /**\r\n     * Isometric Tilemap orientation constant.\r\n     *\r\n     * @name Phaser.Tilemaps.Orientation.ISOMETRIC\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    ISOMETRIC: 1,\r\n\r\n    /**\r\n     * Staggered Tilemap orientation constant.\r\n     *\r\n     * @name Phaser.Tilemaps.Orientation.STAGGERED\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    STAGGERED: 2,\r\n\r\n    /**\r\n     * Hexagonal Tilemap orientation constant.\r\n     *\r\n     * @name Phaser.Tilemaps.Orientation.HEXAGONAL\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    HEXAGONAL: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = {\r\n\r\n    ORIENTATION: require('./ORIENTATION_CONST')\r\n\r\n};\r\n\r\nmodule.exports = CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Extend = require('../utils/object/Extend');\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps\r\n *\r\n * @borrows Phaser.Tilemaps.Orientation.ORTHOGONAL as ORTHOGONAL\r\n * @borrows Phaser.Tilemaps.Orientation.ISOMETRIC as ISOMETRIC\r\n * @borrows Phaser.Tilemaps.Orientation.STAGGERED as STAGGERED\r\n * @borrows Phaser.Tilemaps.Orientation.HEXAGONAL as HEXAGONAL\r\n */\r\n\r\nvar Tilemaps = {\r\n\r\n    Components: require('./components'),\r\n    Parsers: require('./parsers'),\r\n\r\n    Formats: require('./Formats'),\r\n    ImageCollection: require('./ImageCollection'),\r\n    ParseToTilemap: require('./ParseToTilemap'),\r\n    Tile: require('./Tile'),\r\n    Tilemap: require('./Tilemap'),\r\n    TilemapCreator: require('./TilemapCreator'),\r\n    TilemapFactory: require('./TilemapFactory'),\r\n    Tileset: require('./Tileset'),\r\n    TilemapLayer: require('./TilemapLayer'),\r\n    Orientation: require('./const/ORIENTATION_CONST'),\r\n\r\n    LayerData: require('./mapdata/LayerData'),\r\n    MapData: require('./mapdata/MapData'),\r\n    ObjectLayer: require('./mapdata/ObjectLayer')\r\n\r\n};\r\n\r\nTilemaps = Extend(false, Tilemaps, CONST.ORIENTATION);\r\n\r\nmodule.exports = Tilemaps;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * @classdesc\r\n * A class for representing data about about a layer in a map. Maps are parsed from CSV, Tiled,\r\n * etc. into this format. Tilemap and TilemapLayer objects have a reference\r\n * to this data and use it to look up and perform operations on tiles.\r\n *\r\n * @class LayerData\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Tilemaps.LayerDataConfig} [config] - The Layer Data configuration object.\r\n */\r\nvar LayerData = new Class({\r\n\r\n    initialize:\r\n\r\n    function LayerData (config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        /**\r\n         * The name of the layer, if specified in Tiled.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = GetFastValue(config, 'name', 'layer');\r\n\r\n        /**\r\n         * The x offset of where to draw from the top left.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.x = GetFastValue(config, 'x', 0);\r\n\r\n        /**\r\n         * The y offset of where to draw from the top left.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.y = GetFastValue(config, 'y', 0);\r\n\r\n        /**\r\n         * The width of the layer in tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = GetFastValue(config, 'width', 0);\r\n\r\n        /**\r\n         * The height of the layer in tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = GetFastValue(config, 'height', 0);\r\n\r\n        /**\r\n         * The pixel width of the tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#tileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileWidth = GetFastValue(config, 'tileWidth', 0);\r\n\r\n        /**\r\n         * The pixel height of the tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#tileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileHeight = GetFastValue(config, 'tileHeight', 0);\r\n\r\n        /**\r\n         * The base tile width.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#baseTileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseTileWidth = GetFastValue(config, 'baseTileWidth', this.tileWidth);\r\n\r\n        /**\r\n         * The base tile height.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#baseTileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseTileHeight = GetFastValue(config, 'baseTileHeight', this.tileHeight);\r\n\r\n        /**\r\n         * The layers orientation, necessary to be able to determine a tiles pixelX and pixelY as well as the layers width and height.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#orientation\r\n         * @type {Phaser.Tilemaps.OrientationType}\r\n         * @since 3.50.0\r\n         */\r\n        this.orientation = GetFastValue(config, 'orientation', CONST.ORTHOGONAL);\r\n\r\n        /**\r\n         * The width in pixels of the entire layer.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#widthInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.widthInPixels = GetFastValue(config, 'widthInPixels', this.width * this.baseTileWidth);\r\n\r\n        /**\r\n         * The height in pixels of the entire layer.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#heightInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.heightInPixels = GetFastValue(config, 'heightInPixels', this.height * this.baseTileHeight);\r\n\r\n        /**\r\n         * The alpha value of the layer.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#alpha\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.alpha = GetFastValue(config, 'alpha', 1);\r\n\r\n        /**\r\n         * Is the layer visible or not?\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#visible\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.visible = GetFastValue(config, 'visible', true);\r\n\r\n        /**\r\n         * Layer specific properties (can be specified in Tiled)\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#properties\r\n         * @type {object[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = GetFastValue(config, 'properties', []);\r\n\r\n        /**\r\n         * Tile ID index map.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#indexes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.indexes = GetFastValue(config, 'indexes', []);\r\n\r\n        /**\r\n         * Tile Collision ID index map.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#collideIndexes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideIndexes = GetFastValue(config, 'collideIndexes', []);\r\n\r\n        /**\r\n         * An array of callbacks.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#callbacks\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.callbacks = GetFastValue(config, 'callbacks', []);\r\n\r\n        /**\r\n         * An array of physics bodies.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#bodies\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.bodies = GetFastValue(config, 'bodies', []);\r\n\r\n        /**\r\n         * An array of the tile data indexes.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#data\r\n         * @type {Phaser.Tilemaps.Tile[][]}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = GetFastValue(config, 'data', []);\r\n\r\n        /**\r\n         * A reference to the Tilemap layer that owns this data.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#tilemapLayer\r\n         * @type {Phaser.Tilemaps.TilemapLayer}\r\n         * @since 3.0.0\r\n         */\r\n        this.tilemapLayer = GetFastValue(config, 'tilemapLayer', null);\r\n\r\n        /**\r\n         * The length of the horizontal sides of the hexagon.\r\n         * Only used for hexagonal orientation Tilemaps.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#hexSideLength\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.hexSideLength = GetFastValue(config, 'hexSideLength', 0);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = LayerData;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * @classdesc\r\n * A class for representing data about a map. Maps are parsed from CSV, Tiled, etc. into this\r\n * format. A Tilemap object get a copy of this data and then unpacks the needed properties into\r\n * itself.\r\n *\r\n * @class MapData\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Tilemaps.MapDataConfig} [config] - The Map configuration object.\r\n */\r\nvar MapData = new Class({\r\n\r\n    initialize:\r\n\r\n    function MapData (config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        /**\r\n         * The key in the Phaser cache that corresponds to the loaded tilemap data.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = GetFastValue(config, 'name', 'map');\r\n\r\n        /**\r\n         * The width of the entire tilemap.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = GetFastValue(config, 'width', 0);\r\n\r\n        /**\r\n         * The height of the entire tilemap.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = GetFastValue(config, 'height', 0);\r\n\r\n        /**\r\n         * If the map is infinite or not.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#infinite\r\n         * @type {boolean}\r\n         * @since 3.17.0\r\n         */\r\n        this.infinite = GetFastValue(config, 'infinite', false);\r\n\r\n        /**\r\n         * The width of the tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#tileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileWidth = GetFastValue(config, 'tileWidth', 0);\r\n\r\n        /**\r\n         * The height of the tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#tileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileHeight = GetFastValue(config, 'tileHeight', 0);\r\n\r\n        /**\r\n         * The width in pixels of the entire tilemap.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#widthInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.widthInPixels = GetFastValue(config, 'widthInPixels', this.width * this.tileWidth);\r\n\r\n        /**\r\n         * The height in pixels of the entire tilemap.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#heightInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.heightInPixels = GetFastValue(config, 'heightInPixels', this.height * this.tileHeight);\r\n\r\n        /**\r\n         * The format of the map data.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#format\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.format = GetFastValue(config, 'format', null);\r\n\r\n        /**\r\n         * The orientation of the map data (i.e. orthogonal, isometric, hexagonal), default 'orthogonal'.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#orientation\r\n         * @type {Phaser.Tilemaps.OrientationType}\r\n         * @since 3.50.0\r\n         */\r\n        this.orientation = GetFastValue(config, 'orientation', CONST.ORTHOGONAL);\r\n\r\n        /**\r\n         * Determines the draw order of tilemap. Default is right-down\r\n         *\r\n         * 0, or 'right-down'\r\n         * 1, or 'left-down'\r\n         * 2, or 'right-up'\r\n         * 3, or 'left-up'\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#renderOrder\r\n         * @type {string}\r\n         * @since 3.12.0\r\n         */\r\n        this.renderOrder = GetFastValue(config, 'renderOrder', 'right-down');\r\n\r\n        /**\r\n         * The version of the map data (as specified in Tiled).\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#version\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.version = GetFastValue(config, 'version', '1');\r\n\r\n        /**\r\n         * Map specific properties (can be specified in Tiled)\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = GetFastValue(config, 'properties', {});\r\n\r\n        /**\r\n         * An array with all the layers configured to the MapData.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#layers\r\n         * @type {(Phaser.Tilemaps.LayerData[]|Phaser.Tilemaps.ObjectLayer)}\r\n         * @since 3.0.0\r\n         */\r\n        this.layers = GetFastValue(config, 'layers', []);\r\n\r\n        /**\r\n         * An array of Tiled Image Layers.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#images\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.images = GetFastValue(config, 'images', []);\r\n\r\n        /**\r\n         * An object of Tiled Object Layers.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#objects\r\n         * @type {Phaser.Types.Tilemaps.ObjectLayerConfig[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.objects = GetFastValue(config, 'objects', []);\r\n\r\n        /**\r\n          * An object of collision data. Must be created as physics object or will return undefined.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#collision\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.collision = GetFastValue(config, 'collision', {});\r\n\r\n        /**\r\n         * An array of Tilesets.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#tilesets\r\n         * @type {Phaser.Tilemaps.Tileset[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.tilesets = GetFastValue(config, 'tilesets', []);\r\n\r\n        /**\r\n         * The collection of images the map uses(specified in Tiled)\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#imageCollections\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.imageCollections = GetFastValue(config, 'imageCollections', []);\r\n\r\n        /**\r\n         * An array of tile instances.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#tiles\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.tiles = GetFastValue(config, 'tiles', []);\r\n\r\n        /**\r\n         * The length of the horizontal sides of the hexagon.\r\n         * Only used for hexagonal orientation Tilemaps.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#hexSideLength\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.hexSideLength = GetFastValue(config, 'hexSideLength', 0);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MapData;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * @classdesc\r\n * A class for representing a Tiled object layer in a map. This mirrors the structure of a Tiled\r\n * object layer, except:\r\n *  - \"x\" & \"y\" properties are ignored since these cannot be changed in Tiled.\r\n *  - \"offsetx\" & \"offsety\" are applied to the individual object coordinates directly, so they\r\n *    are ignored as well.\r\n *  - \"draworder\" is ignored.\r\n *\r\n * @class ObjectLayer\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Tilemaps.ObjectLayerConfig} [config] - The data for the layer from the Tiled JSON object.\r\n */\r\nvar ObjectLayer = new Class({\r\n\r\n    initialize:\r\n\r\n    function ObjectLayer (config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        /**\r\n         * The name of the Object Layer.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = GetFastValue(config, 'name', 'object layer');\r\n\r\n        /**\r\n         * The opacity of the layer, between 0 and 1.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#opacity\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.opacity = GetFastValue(config, 'opacity', 1);\r\n\r\n        /**\r\n         * The custom properties defined on the Object Layer, keyed by their name.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = GetFastValue(config, 'properties', {});\r\n\r\n        /**\r\n         * The type of each custom property defined on the Object Layer, keyed by its name.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#propertyTypes\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.propertyTypes = GetFastValue(config, 'propertytypes', {});\r\n\r\n        /**\r\n         * The type of the layer, which should be `objectgroup`.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = GetFastValue(config, 'type', 'objectgroup');\r\n\r\n        /**\r\n         * Whether the layer is shown (`true`) or hidden (`false`).\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#visible\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.visible = GetFastValue(config, 'visible', true);\r\n\r\n        /**\r\n         * An array of all objects on this Object Layer.\r\n         *\r\n         * Each Tiled object corresponds to a JavaScript object in this array. It has an `id` (unique),\r\n         * `name` (as assigned in Tiled), `type` (as assigned in Tiled), `rotation` (in clockwise degrees),\r\n         * `properties` (if any), `visible` state (`true` if visible, `false` otherwise),\r\n         * `x` and `y` coordinates (in pixels, relative to the tilemap), and a `width` and `height` (in pixels).\r\n         *\r\n         * An object tile has a `gid` property (GID of the represented tile), a `flippedHorizontal` property,\r\n         * a `flippedVertical` property, and `flippedAntiDiagonal` property.\r\n         * The {@link http://docs.mapeditor.org/en/latest/reference/tmx-map-format/|Tiled documentation} contains\r\n         * information on flipping and rotation.\r\n         *\r\n         * Polylines have a `polyline` property, which is an array of objects corresponding to points,\r\n         * where each point has an `x` property and a `y` property. Polygons have an identically structured\r\n         * array in their `polygon` property. Text objects have a `text` property with the text's properties.\r\n         *\r\n         * Rectangles and ellipses have a `rectangle` or `ellipse` property set to `true`.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#objects\r\n         * @type {Phaser.Types.Tilemaps.TiledObject[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.objects = GetFastValue(config, 'objects', []);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ObjectLayer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\n\r\n/**\r\n * Get the Tilemap orientation from the given string.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.FromOrientationString\r\n * @since 3.50.0\r\n *\r\n * @param {string} [orientation] - The orientation type as a string.\r\n *\r\n * @return {Phaser.Tilemaps.OrientationType} The Tilemap Orientation type.\r\n */\r\nvar FromOrientationString = function (orientation)\r\n{\r\n    orientation = orientation.toLowerCase();\r\n\r\n    if (orientation === 'isometric')\r\n    {\r\n        return CONST.ISOMETRIC;\r\n    }\r\n    else if (orientation === 'staggered')\r\n    {\r\n        return CONST.STAGGERED;\r\n    }\r\n    else if (orientation === 'hexagonal')\r\n    {\r\n        return CONST.HEXAGONAL;\r\n    }\r\n    else\r\n    {\r\n        return CONST.ORTHOGONAL;\r\n    }\r\n};\r\n\r\nmodule.exports = FromOrientationString;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('../Formats');\r\nvar Parse2DArray = require('./Parse2DArray');\r\nvar ParseCSV = require('./ParseCSV');\r\nvar ParseJSONTiled = require('./tiled/ParseJSONTiled');\r\nvar ParseWeltmeister = require('./impact/ParseWeltmeister');\r\n\r\n/**\r\n * Parses raw data of a given Tilemap format into a new MapData object. If no recognized data format\r\n * is found, returns `null`. When loading from CSV or a 2D array, you should specify the tileWidth &\r\n * tileHeight. When parsing from a map from Tiled, the tileWidth & tileHeight will be pulled from\r\n * the map data.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Parse\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {number} mapFormat - See ../Formats.js.\r\n * @param {(number[][]|string|object)} data - 2D array, CSV string or Tiled JSON object.\r\n * @param {number} tileWidth - The width of a tile in pixels. Required for 2D array and CSV, but\r\n * ignored for Tiled JSON.\r\n * @param {number} tileHeight - The height of a tile in pixels. Required for 2D array and CSV, but\r\n * ignored for Tiled JSON.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.MapData} The created `MapData` object.\r\n */\r\nvar Parse = function (name, mapFormat, data, tileWidth, tileHeight, insertNull)\r\n{\r\n    var newMap;\r\n\r\n    switch (mapFormat)\r\n    {\r\n        case (Formats.ARRAY_2D):\r\n            newMap = Parse2DArray(name, data, tileWidth, tileHeight, insertNull);\r\n            break;\r\n        case (Formats.CSV):\r\n            newMap = ParseCSV(name, data, tileWidth, tileHeight, insertNull);\r\n            break;\r\n        case (Formats.TILED_JSON):\r\n            newMap = ParseJSONTiled(name, data, insertNull);\r\n            break;\r\n        case (Formats.WELTMEISTER):\r\n            newMap = ParseWeltmeister(name, data, insertNull);\r\n            break;\r\n        default:\r\n            console.warn('Unrecognized tilemap data format: ' + mapFormat);\r\n            newMap = null;\r\n    }\r\n\r\n    return newMap;\r\n};\r\n\r\nmodule.exports = Parse;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('../Formats');\r\nvar LayerData = require('../mapdata/LayerData');\r\nvar MapData = require('../mapdata/MapData');\r\nvar Tile = require('../Tile');\r\n\r\n/**\r\n * Parses a 2D array of tile indexes into a new MapData object with a single layer.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Parse2DArray\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {number[][]} data - 2D array, CSV string or Tiled JSON object.\r\n * @param {number} tileWidth - The width of a tile in pixels.\r\n * @param {number} tileHeight - The height of a tile in pixels.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.MapData} The MapData object.\r\n */\r\nvar Parse2DArray = function (name, data, tileWidth, tileHeight, insertNull)\r\n{\r\n    var layerData = new LayerData({\r\n        tileWidth: tileWidth,\r\n        tileHeight: tileHeight\r\n    });\r\n    \r\n    var mapData = new MapData({\r\n        name: name,\r\n        tileWidth: tileWidth,\r\n        tileHeight: tileHeight,\r\n        format: Formats.ARRAY_2D,\r\n        layers: [ layerData ]\r\n    });\r\n\r\n    var tiles = [];\r\n    var height = data.length;\r\n    var width = 0;\r\n\r\n    for (var y = 0; y < data.length; y++)\r\n    {\r\n        tiles[y] = [];\r\n        var row = data[y];\r\n\r\n        for (var x = 0; x < row.length; x++)\r\n        {\r\n            var tileIndex = parseInt(row[x], 10);\r\n\r\n            if (isNaN(tileIndex) || tileIndex === -1)\r\n            {\r\n                tiles[y][x] = insertNull\r\n                    ? null\r\n                    : new Tile(layerData, -1, x, y, tileWidth, tileHeight);\r\n            }\r\n            else\r\n            {\r\n                tiles[y][x] = new Tile(layerData, tileIndex, x, y, tileWidth, tileHeight);\r\n            }\r\n        }\r\n\r\n        if (width === 0)\r\n        {\r\n            width = row.length;\r\n        }\r\n    }\r\n\r\n    mapData.width = layerData.width = width;\r\n    mapData.height = layerData.height = height;\r\n    mapData.widthInPixels = layerData.widthInPixels = width * tileWidth;\r\n    mapData.heightInPixels = layerData.heightInPixels = height * tileHeight;\r\n    layerData.data = tiles;\r\n\r\n    return mapData;\r\n};\r\n\r\nmodule.exports = Parse2DArray;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('../Formats');\r\nvar Parse2DArray = require('./Parse2DArray');\r\n\r\n/**\r\n * Parses a CSV string of tile indexes into a new MapData object with a single layer.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.ParseCSV\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {string} data - CSV string of tile indexes.\r\n * @param {number} tileWidth - The width of a tile in pixels.\r\n * @param {number} tileHeight - The height of a tile in pixels.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.MapData} The resulting MapData object.\r\n */\r\nvar ParseCSV = function (name, data, tileWidth, tileHeight, insertNull)\r\n{\r\n    var array2D = data\r\n        .trim()\r\n        .split('\\n')\r\n        .map(function (row) { return row.split(','); });\r\n\r\n    var map = Parse2DArray(name, array2D, tileWidth, tileHeight, insertNull);\r\n    map.format = Formats.CSV;\r\n\r\n    return map;\r\n};\r\n\r\nmodule.exports = ParseCSV;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar LayerData = require('../../mapdata/LayerData');\r\nvar Tile = require('../../Tile');\r\n\r\n/**\r\n * Parses all tilemap layers in an Impact JSON object into new LayerData objects.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Impact.ParseTileLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Impact JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled (see {@link Phaser.Tilemaps.Parsers.Tiled.ParseJSONTiled}).\r\n *\r\n * @return {Phaser.Tilemaps.LayerData[]} - An array of LayerData objects, one for each entry in\r\n * json.layers with the type 'tilelayer'.\r\n */\r\nvar ParseTileLayers = function (json, insertNull)\r\n{\r\n    var tileLayers = [];\r\n\r\n    for (var i = 0; i < json.layer.length; i++)\r\n    {\r\n        var layer = json.layer[i];\r\n\r\n        var layerData = new LayerData({\r\n            name: layer.name,\r\n            width: layer.width,\r\n            height: layer.height,\r\n            tileWidth: layer.tilesize,\r\n            tileHeight: layer.tilesize,\r\n            visible: layer.visible === 1\r\n        });\r\n\r\n        var row = [];\r\n        var tileGrid = [];\r\n\r\n        //  Loop through the data field in the JSON. This is a 2D array containing the tile indexes,\r\n        //  one after the other. The indexes are relative to the tileset that contains the tile.\r\n        for (var y = 0; y < layer.data.length; y++)\r\n        {\r\n            for (var x = 0; x < layer.data[y].length; x++)\r\n            {\r\n                // In Weltmeister, 0 = no tile, but the Tilemap API expects -1 = no tile.\r\n                var index = layer.data[y][x] - 1;\r\n\r\n                var tile;\r\n\r\n                if (index > -1)\r\n                {\r\n                    tile = new Tile(layerData, index, x, y, layer.tilesize, layer.tilesize);\r\n                }\r\n                else\r\n                {\r\n                    tile = insertNull\r\n                        ? null\r\n                        : new Tile(layerData, -1, x, y, layer.tilesize, layer.tilesize);\r\n                }\r\n\r\n                row.push(tile);\r\n            }\r\n\r\n            tileGrid.push(row);\r\n            row = [];\r\n        }\r\n\r\n        layerData.data = tileGrid;\r\n\r\n        tileLayers.push(layerData);\r\n    }\r\n\r\n    return tileLayers;\r\n};\r\n\r\nmodule.exports = ParseTileLayers;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tileset = require('../../Tileset');\r\n\r\n/**\r\n * Tilesets and Image Collections\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Impact.ParseTilesets\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Impact JSON data.\r\n *\r\n * @return {array} An array of Tilesets.\r\n */\r\nvar ParseTilesets = function (json)\r\n{\r\n    var tilesets = [];\r\n    var tilesetsNames = [];\r\n\r\n    for (var i = 0; i < json.layer.length; i++)\r\n    {\r\n        var layer = json.layer[i];\r\n\r\n        // A relative filepath to the source image (within Weltmeister) is used for the name\r\n        var tilesetName = layer.tilesetName;\r\n\r\n        // Only add unique tilesets that have a valid name. Collision layers will have a blank name.\r\n        if (tilesetName !== '' && tilesetsNames.indexOf(tilesetName) === -1)\r\n        {\r\n            tilesetsNames.push(tilesetName);\r\n\r\n            // Tiles are stored with an ID relative to the tileset, rather than a globally unique ID\r\n            // across all tilesets. Also, tilesets in Weltmeister have no margin or padding.\r\n            tilesets.push(new Tileset(tilesetName, 0, layer.tilesize, layer.tilesize, 0, 0));\r\n        }\r\n    }\r\n\r\n    return tilesets;\r\n};\r\n\r\nmodule.exports = ParseTilesets;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('../../Formats');\r\nvar MapData = require('../../mapdata/MapData');\r\nvar ParseTileLayers = require('./ParseTileLayers');\r\nvar ParseTilesets = require('./ParseTilesets');\r\n\r\n/**\r\n * Parses a Weltmeister JSON object into a new MapData object.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Impact.ParseWeltmeister\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {object} json - The Weltmeister JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {?Phaser.Tilemaps.MapData} The created MapData object, or `null` if the data can't be parsed.\r\n */\r\nvar ParseWeltmeister = function (name, json, insertNull)\r\n{\r\n    if (json.layer.length === 0)\r\n    {\r\n        console.warn('No layers found in the Weltmeister map: ' + name);\r\n        return null;\r\n    }\r\n\r\n    var width = 0;\r\n    var height = 0;\r\n\r\n    for (var i = 0; i < json.layer.length; i++)\r\n    {\r\n        if (json.layer[i].width > width) { width = json.layer[i].width; }\r\n        if (json.layer[i].height > height) { height = json.layer[i].height; }\r\n    }\r\n\r\n    var mapData = new MapData({\r\n        width: width,\r\n        height: height,\r\n        name: name,\r\n        tileWidth: json.layer[0].tilesize,\r\n        tileHeight: json.layer[0].tilesize,\r\n        format: Formats.WELTMEISTER\r\n    });\r\n\r\n    mapData.layers = ParseTileLayers(json, insertNull);\r\n    mapData.tilesets = ParseTilesets(json);\r\n\r\n    return mapData;\r\n};\r\n\r\nmodule.exports = ParseWeltmeister;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Parsers.Impact\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ParseTileLayers: require('./ParseTileLayers'),\r\n    ParseTilesets: require('./ParseTilesets'),\r\n    ParseWeltmeister: require('./ParseWeltmeister')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Parsers\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    FromOrientationString: require('./FromOrientationString'),\r\n    Parse: require('./Parse'),\r\n    Parse2DArray: require('./Parse2DArray'),\r\n    ParseCSV: require('./ParseCSV'),\r\n\r\n    Impact: require('./impact/'),\r\n    Tiled: require('./tiled/')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Extend = require('../../../utils/object/Extend');\r\n\r\n/**\r\n * Copy properties from tileset to tiles.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.AssignTileProperties\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.MapData} mapData - The Map Data object.\r\n */\r\nvar AssignTileProperties = function (mapData)\r\n{\r\n    var layerData;\r\n    var tile;\r\n    var sid;\r\n    var set;\r\n    var row;\r\n\r\n    // go through each of the map data layers\r\n    for (var i = 0; i < mapData.layers.length; i++)\r\n    {\r\n        layerData = mapData.layers[i];\r\n\r\n        set = null;\r\n\r\n        // rows of tiles\r\n        for (var j = 0; j < layerData.data.length; j++)\r\n        {\r\n            row = layerData.data[j];\r\n\r\n            // individual tiles\r\n            for (var k = 0; k < row.length; k++)\r\n            {\r\n                tile = row[k];\r\n\r\n                if (tile === null || tile.index < 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                // find the relevant tileset\r\n                sid = mapData.tiles[tile.index][2];\r\n                set = mapData.tilesets[sid];\r\n\r\n                // Ensure that a tile's size matches its tileset\r\n                tile.width = set.tileWidth;\r\n                tile.height = set.tileHeight;\r\n\r\n                // if that tile type has any properties, add them to the tile object\r\n                if (set.tileProperties && set.tileProperties[tile.index - set.firstgid])\r\n                {\r\n                    tile.properties = Extend(\r\n                        tile.properties, set.tileProperties[tile.index - set.firstgid]\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = AssignTileProperties;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Decode base-64 encoded data, for example as exported by Tiled.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.Base64Decode\r\n * @since 3.0.0\r\n *\r\n * @param {object} data - Base-64 encoded data to decode.\r\n *\r\n * @return {array} Array containing the decoded bytes.\r\n */\r\nvar Base64Decode = function (data)\r\n{\r\n    var binaryString = window.atob(data);\r\n    var len = binaryString.length;\r\n    var bytes = new Array(len / 4);\r\n\r\n    // Interpret binaryString as an array of bytes representing little-endian encoded uint32 values.\r\n    for (var i = 0; i < len; i += 4)\r\n    {\r\n        bytes[i / 4] = (\r\n            binaryString.charCodeAt(i) |\r\n            binaryString.charCodeAt(i + 1) << 8 |\r\n            binaryString.charCodeAt(i + 2) << 16 |\r\n            binaryString.charCodeAt(i + 3) << 24\r\n        ) >>> 0;\r\n    }\r\n\r\n    return bytes;\r\n};\r\n\r\nmodule.exports = Base64Decode;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tileset = require('../../Tileset');\r\n\r\n/**\r\n * Master list of tiles -> x, y, index in tileset.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.BuildTilesetIndex\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.MapData} mapData - The Map Data object.\r\n *\r\n * @return {array} An array of Tileset objects.\r\n */\r\nvar BuildTilesetIndex = function (mapData)\r\n{\r\n    var i;\r\n    var set;\r\n    var tiles = [];\r\n\r\n    for (i = 0; i < mapData.imageCollections.length; i++)\r\n    {\r\n        var collection = mapData.imageCollections[i];\r\n        var images = collection.images;\r\n\r\n        for (var j = 0; j < images.length; j++)\r\n        {\r\n            var image = images[j];\r\n\r\n            set = new Tileset(image.image, image.gid, collection.imageWidth, collection.imageHeight, 0, 0);\r\n\r\n            set.updateTileData(collection.imageWidth, collection.imageHeight);\r\n\r\n            mapData.tilesets.push(set);\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < mapData.tilesets.length; i++)\r\n    {\r\n        set = mapData.tilesets[i];\r\n\r\n        var x = set.tileMargin;\r\n        var y = set.tileMargin;\r\n\r\n        var count = 0;\r\n        var countX = 0;\r\n        var countY = 0;\r\n\r\n        for (var t = set.firstgid; t < set.firstgid + set.total; t++)\r\n        {\r\n            //  Can add extra properties here as needed\r\n            tiles[t] = [ x, y, i ];\r\n\r\n            x += set.tileWidth + set.tileSpacing;\r\n\r\n            count++;\r\n\r\n            if (count === set.total)\r\n            {\r\n                break;\r\n            }\r\n\r\n            countX++;\r\n\r\n            if (countX === set.columns)\r\n            {\r\n                x = set.tileMargin;\r\n                y += set.tileHeight + set.tileSpacing;\r\n\r\n                countX = 0;\r\n                countY++;\r\n\r\n                if (countY === set.rows)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return tiles;\r\n};\r\n\r\nmodule.exports = BuildTilesetIndex;\r\n","/**\r\n * @author       Seth Berrier <berriers@uwstout.edu>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\n\r\n/**\r\n * Parse a Tiled group layer and create a state object for inheriting.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.CreateGroupLayer\r\n * @since 3.21.0\r\n *\r\n * @param {object} json - The Tiled JSON object.\r\n * @param {object} [currentl] - The current group layer from the Tiled JSON file.\r\n * @param {object} [parentstate] - The state of the parent group (if any).\r\n *\r\n * @return {object} A group state object with proper values for updating children layers.\r\n */\r\nvar CreateGroupLayer = function (json, groupl, parentstate)\r\n{\r\n    if (!groupl)\r\n    {\r\n        // Return a default group state object\r\n        return {\r\n            i: 0, // Current layer array iterator\r\n            layers: json.layers, // Current array of layers\r\n\r\n            // Values inherited from parent group\r\n            name: '',\r\n            opacity: 1,\r\n            visible: true,\r\n            x: 0,\r\n            y: 0\r\n        };\r\n    }\r\n\r\n    // Compute group layer x, y\r\n    var layerX = groupl.x + GetFastValue(groupl, 'startx', 0) * json.tilewidth + GetFastValue(groupl, 'offsetx', 0);\r\n    var layerY = groupl.y + GetFastValue(groupl, 'starty', 0) * json.tileheight + GetFastValue(groupl, 'offsety', 0);\r\n\r\n    // Compute next state inherited from group\r\n    return {\r\n        i: 0,\r\n        layers: groupl.layers,\r\n        name: parentstate.name + groupl.name + '/',\r\n        opacity: parentstate.opacity * groupl.opacity,\r\n        visible: parentstate.visible && groupl.visible,\r\n        x: parentstate.x + layerX,\r\n        y: parentstate.y + layerY\r\n    };\r\n};\r\n\r\nmodule.exports = CreateGroupLayer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FLIPPED_HORIZONTAL = 0x80000000;\r\nvar FLIPPED_VERTICAL = 0x40000000;\r\nvar FLIPPED_ANTI_DIAGONAL = 0x20000000; // Top-right is swapped with bottom-left corners\r\n\r\n/**\r\n * See Tiled documentation on tile flipping:\r\n * http://docs.mapeditor.org/en/latest/reference/tmx-map-format/\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseGID\r\n * @since 3.0.0\r\n *\r\n * @param {number} gid - A Tiled GID.\r\n *\r\n * @return {Phaser.Types.Tilemaps.GIDData} The GID Data.\r\n */\r\nvar ParseGID = function (gid)\r\n{\r\n    var flippedHorizontal = Boolean(gid & FLIPPED_HORIZONTAL);\r\n    var flippedVertical = Boolean(gid & FLIPPED_VERTICAL);\r\n    var flippedAntiDiagonal = Boolean(gid & FLIPPED_ANTI_DIAGONAL);\r\n    gid = gid & ~(FLIPPED_HORIZONTAL | FLIPPED_VERTICAL | FLIPPED_ANTI_DIAGONAL);\r\n\r\n    // Parse the flip flags into something Phaser can use\r\n    var rotation = 0;\r\n    var flipped = false;\r\n\r\n    if (flippedHorizontal && flippedVertical && flippedAntiDiagonal)\r\n    {\r\n        rotation = Math.PI / 2;\r\n        flipped = true;\r\n    }\r\n    else if (flippedHorizontal && flippedVertical && !flippedAntiDiagonal)\r\n    {\r\n        rotation = Math.PI;\r\n        flipped = false;\r\n    }\r\n    else if (flippedHorizontal && !flippedVertical && flippedAntiDiagonal)\r\n    {\r\n        rotation = Math.PI / 2;\r\n        flipped = false;\r\n    }\r\n    else if (flippedHorizontal && !flippedVertical && !flippedAntiDiagonal)\r\n    {\r\n        rotation = 0;\r\n        flipped = true;\r\n    }\r\n    else if (!flippedHorizontal && flippedVertical && flippedAntiDiagonal)\r\n    {\r\n        rotation = 3 * Math.PI / 2;\r\n        flipped = false;\r\n    }\r\n    else if (!flippedHorizontal && flippedVertical && !flippedAntiDiagonal)\r\n    {\r\n        rotation = Math.PI;\r\n        flipped = true;\r\n    }\r\n    else if (!flippedHorizontal && !flippedVertical && flippedAntiDiagonal)\r\n    {\r\n        rotation = 3 * Math.PI / 2;\r\n        flipped = true;\r\n    }\r\n    else if (!flippedHorizontal && !flippedVertical && !flippedAntiDiagonal)\r\n    {\r\n        rotation = 0;\r\n        flipped = false;\r\n    }\r\n\r\n    return {\r\n        gid: gid,\r\n        flippedHorizontal: flippedHorizontal,\r\n        flippedVertical: flippedVertical,\r\n        flippedAntiDiagonal: flippedAntiDiagonal,\r\n        rotation: rotation,\r\n        flipped: flipped\r\n    };\r\n};\r\n\r\nmodule.exports = ParseGID;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar CreateGroupLayer = require('./CreateGroupLayer');\r\n\r\n/**\r\n * Parses a Tiled JSON object into an array of objects with details about the image layers.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseImageLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Tiled JSON object.\r\n *\r\n * @return {array} Array of objects that include critical info about the map's image layers\r\n */\r\nvar ParseImageLayers = function (json)\r\n{\r\n    var images = [];\r\n\r\n    // State inherited from a parent group\r\n    var groupStack = [];\r\n    var curGroupState = CreateGroupLayer(json);\r\n\r\n    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0)\r\n    {\r\n        if (curGroupState.i >= curGroupState.layers.length)\r\n        {\r\n            // Ensure recursion stack is not empty first\r\n            if (groupStack.length < 1)\r\n            {\r\n                console.warn(\r\n                    'TilemapParser.parseTiledJSON - Invalid layer group hierarchy'\r\n                );\r\n                break;\r\n            }\r\n\r\n            // Return to previous recursive state\r\n            curGroupState = groupStack.pop();\r\n            continue;\r\n        }\r\n\r\n        // Get current layer and advance iterator\r\n        var curi = curGroupState.layers[curGroupState.i];\r\n        curGroupState.i++;\r\n\r\n        if (curi.type !== 'imagelayer')\r\n        {\r\n            if (curi.type === 'group')\r\n            {\r\n                // Compute next state inherited from group\r\n                var nextGroupState = CreateGroupLayer(json, curi, curGroupState);\r\n\r\n                // Preserve current state before recursing\r\n                groupStack.push(curGroupState);\r\n                curGroupState = nextGroupState;\r\n            }\r\n\r\n            // Skip this layer OR 'recurse' (iterative style) into the group\r\n            continue;\r\n        }\r\n\r\n        var layerOffsetX = GetFastValue(curi, 'offsetx', 0) + GetFastValue(curi, 'startx', 0);\r\n        var layerOffsetY = GetFastValue(curi, 'offsety', 0) + GetFastValue(curi, 'starty', 0);\r\n        images.push({\r\n            name: (curGroupState.name + curi.name),\r\n            image: curi.image,\r\n            x: (curGroupState.x + layerOffsetX + curi.x),\r\n            y: (curGroupState.y + layerOffsetY + curi.y),\r\n            alpha: (curGroupState.opacity * curi.opacity),\r\n            visible: (curGroupState.visible && curi.visible),\r\n            properties: GetFastValue(curi, 'properties', {})\r\n        });\r\n    }\r\n\r\n    return images;\r\n};\r\n\r\nmodule.exports = ParseImageLayers;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AssignTileProperties = require('./AssignTileProperties');\r\nvar BuildTilesetIndex = require('./BuildTilesetIndex');\r\nvar CONST = require('../../const/ORIENTATION_CONST');\r\nvar Formats = require('../../Formats');\r\nvar FromOrientationString = require('../FromOrientationString');\r\nvar MapData = require('../../mapdata/MapData');\r\nvar ParseImageLayers = require('./ParseImageLayers');\r\nvar ParseObjectLayers = require('./ParseObjectLayers');\r\nvar ParseTileLayers = require('./ParseTileLayers');\r\nvar ParseTilesets = require('./ParseTilesets');\r\n\r\n/**\r\n * Parses a Tiled JSON object into a new MapData object.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseJSONTiled\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {object} json - The Tiled JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {?Phaser.Tilemaps.MapData} The created MapData object, or `null` if the data can't be parsed.\r\n */\r\nvar ParseJSONTiled = function (name, json, insertNull)\r\n{\r\n    //  Map data will consist of: layers, objects, images, tilesets, sizes\r\n    var mapData = new MapData({\r\n        width: json.width,\r\n        height: json.height,\r\n        name: name,\r\n        tileWidth: json.tilewidth,\r\n        tileHeight: json.tileheight,\r\n        orientation: FromOrientationString(json.orientation),\r\n        format: Formats.TILED_JSON,\r\n        version: json.version,\r\n        properties: json.properties,\r\n        renderOrder: json.renderorder,\r\n        infinite: json.infinite\r\n    });\r\n\r\n    if (mapData.orientation === CONST.HEXAGONAL)\r\n    {\r\n        mapData.hexSideLength = json.hexsidelength;\r\n    }\r\n\r\n    mapData.layers = ParseTileLayers(json, insertNull);\r\n    mapData.images = ParseImageLayers(json);\r\n\r\n    var sets = ParseTilesets(json);\r\n\r\n    mapData.tilesets = sets.tilesets;\r\n    mapData.imageCollections = sets.imageCollections;\r\n\r\n    mapData.objects = ParseObjectLayers(json);\r\n\r\n    mapData.tiles = BuildTilesetIndex(mapData);\r\n\r\n    AssignTileProperties(mapData);\r\n\r\n    return mapData;\r\n};\r\n\r\nmodule.exports = ParseJSONTiled;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Pick = require('../../../utils/object/Pick');\r\nvar ParseGID = require('./ParseGID');\r\n\r\nvar copyPoints = function (p) { return { x: p.x, y: p.y }; };\r\n\r\nvar commonObjectProps = [ 'id', 'name', 'type', 'rotation', 'properties', 'visible', 'x', 'y', 'width', 'height' ];\r\n\r\n/**\r\n * Convert a Tiled object to an internal parsed object normalising and copying properties over, while applying optional x and y offsets. The parsed object will always have the properties `id`, `name`, `type`, `rotation`, `properties`, `visible`, `x`, `y`, `width` and `height`. Other properties will be added according to the object type (such as text, polyline, gid etc.)\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseObject\r\n * @since 3.0.0\r\n *\r\n * @param {object} tiledObject - Tiled object to convert to an internal parsed object normalising and copying properties over.\r\n * @param {number} [offsetX=0] - Optional additional offset to apply to the object's x property. Defaults to 0.\r\n * @param {number} [offsetY=0] - Optional additional offset to apply to the object's y property. Defaults to 0.\r\n *\r\n * @return {object} The parsed object containing properties read from the Tiled object according to it's type with x and y values updated according to the given offsets.\r\n */\r\nvar ParseObject = function (tiledObject, offsetX, offsetY)\r\n{\r\n    if (offsetX === undefined) { offsetX = 0; }\r\n    if (offsetY === undefined) { offsetY = 0; }\r\n\r\n    var parsedObject = Pick(tiledObject, commonObjectProps);\r\n\r\n    parsedObject.x += offsetX;\r\n    parsedObject.y += offsetY;\r\n\r\n    if (tiledObject.gid)\r\n    {\r\n        //  Object tiles\r\n        var gidInfo = ParseGID(tiledObject.gid);\r\n        parsedObject.gid = gidInfo.gid;\r\n        parsedObject.flippedHorizontal = gidInfo.flippedHorizontal;\r\n        parsedObject.flippedVertical = gidInfo.flippedVertical;\r\n        parsedObject.flippedAntiDiagonal = gidInfo.flippedAntiDiagonal;\r\n    }\r\n    else if (tiledObject.polyline)\r\n    {\r\n        parsedObject.polyline = tiledObject.polyline.map(copyPoints);\r\n    }\r\n    else if (tiledObject.polygon)\r\n    {\r\n        parsedObject.polygon = tiledObject.polygon.map(copyPoints);\r\n    }\r\n    else if (tiledObject.ellipse)\r\n    {\r\n        parsedObject.ellipse = tiledObject.ellipse;\r\n    }\r\n    else if (tiledObject.text)\r\n    {\r\n        parsedObject.text = tiledObject.text;\r\n    }\r\n    else if (tiledObject.point)\r\n    {\r\n        parsedObject.point = true;\r\n    }\r\n    else\r\n    {\r\n        // Otherwise, assume it is a rectangle\r\n        parsedObject.rectangle = true;\r\n    }\r\n\r\n    return parsedObject;\r\n};\r\n\r\nmodule.exports = ParseObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar ParseObject = require('./ParseObject');\r\nvar ObjectLayer = require('../../mapdata/ObjectLayer');\r\nvar CreateGroupLayer = require('./CreateGroupLayer');\r\n\r\n/**\r\n * Parses a Tiled JSON object into an array of ObjectLayer objects.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseObjectLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Tiled JSON object.\r\n *\r\n * @return {array} An array of all object layers in the tilemap as `ObjectLayer`s.\r\n */\r\nvar ParseObjectLayers = function (json)\r\n{\r\n    var objectLayers = [];\r\n\r\n    // State inherited from a parent group\r\n    var groupStack = [];\r\n    var curGroupState = CreateGroupLayer(json);\r\n\r\n    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0)\r\n    {\r\n        if (curGroupState.i >= curGroupState.layers.length)\r\n        {\r\n            // Ensure recursion stack is not empty first\r\n            if (groupStack.length < 1)\r\n            {\r\n                console.warn(\r\n                    'TilemapParser.parseTiledJSON - Invalid layer group hierarchy'\r\n                );\r\n                break;\r\n            }\r\n\r\n            // Return to previous recursive state\r\n            curGroupState = groupStack.pop();\r\n            continue;\r\n        }\r\n\r\n        // Get current layer and advance iterator\r\n        var curo = curGroupState.layers[curGroupState.i];\r\n        curGroupState.i++;\r\n\r\n        // Modify inherited properties\r\n        curo.opacity *= curGroupState.opacity;\r\n        curo.visible = curGroupState.visible && curo.visible;\r\n\r\n        if (curo.type !== 'objectgroup')\r\n        {\r\n            if (curo.type === 'group')\r\n            {\r\n                // Compute next state inherited from group\r\n                var nextGroupState = CreateGroupLayer(json, curo, curGroupState);\r\n\r\n                // Preserve current state before recursing\r\n                groupStack.push(curGroupState);\r\n                curGroupState = nextGroupState;\r\n            }\r\n\r\n            // Skip this layer OR 'recurse' (iterative style) into the group\r\n            continue;\r\n        }\r\n\r\n        curo.name = curGroupState.name + curo.name;\r\n        var offsetX = curGroupState.x + GetFastValue(curo, 'startx', 0) + GetFastValue(curo, 'offsetx', 0);\r\n        var offsetY = curGroupState.y + GetFastValue(curo, 'starty', 0) + GetFastValue(curo, 'offsety', 0);\r\n\r\n        var objects = [];\r\n        for (var j = 0; j < curo.objects.length; j++)\r\n        {\r\n            var parsedObject = ParseObject(curo.objects[j], offsetX, offsetY);\r\n\r\n            objects.push(parsedObject);\r\n        }\r\n\r\n        var objectLayer = new ObjectLayer(curo);\r\n        objectLayer.objects = objects;\r\n\r\n        objectLayers.push(objectLayer);\r\n    }\r\n\r\n    return objectLayers;\r\n};\r\n\r\nmodule.exports = ParseObjectLayers;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Base64Decode = require('./Base64Decode');\r\nvar CONST = require('../../const/ORIENTATION_CONST');\r\nvar CreateGroupLayer = require('./CreateGroupLayer');\r\nvar FromOrientationString = require('../FromOrientationString');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar LayerData = require('../../mapdata/LayerData');\r\nvar ParseGID = require('./ParseGID');\r\nvar Tile = require('../../Tile');\r\n\r\n/**\r\n * Parses all tilemap layers in a Tiled JSON object into new LayerData objects.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseTileLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Tiled JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled (see {@link Phaser.Tilemaps.Parsers.Tiled.ParseJSONTiled}).\r\n *\r\n * @return {Phaser.Tilemaps.LayerData[]} - An array of LayerData objects, one for each entry in\r\n * json.layers with the type 'tilelayer'.\r\n */\r\nvar ParseTileLayers = function (json, insertNull)\r\n{\r\n    var infiniteMap = GetFastValue(json, 'infinite', false);\r\n    var tileLayers = [];\r\n\r\n    // State inherited from a parent group\r\n    var groupStack = [];\r\n    var curGroupState = CreateGroupLayer(json);\r\n\r\n    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0)\r\n    {\r\n        if (curGroupState.i >= curGroupState.layers.length)\r\n        {\r\n            // Ensure recursion stack is not empty first\r\n            if (groupStack.length < 1)\r\n            {\r\n                console.warn(\r\n                    'TilemapParser.parseTiledJSON - Invalid layer group hierarchy'\r\n                );\r\n                break;\r\n            }\r\n\r\n            // Return to previous recursive state\r\n            curGroupState = groupStack.pop();\r\n            continue;\r\n        }\r\n\r\n        var curl = curGroupState.layers[curGroupState.i];\r\n        curGroupState.i++;\r\n\r\n        if (curl.type !== 'tilelayer')\r\n        {\r\n            if (curl.type === 'group')\r\n            {\r\n                // Compute next state inherited from group\r\n                var nextGroupState = CreateGroupLayer(json, curl, curGroupState);\r\n\r\n                // Preserve current state before recursing\r\n                groupStack.push(curGroupState);\r\n                curGroupState = nextGroupState;\r\n            }\r\n\r\n            // Skip this layer OR 'recurse' (iterative style) into the group\r\n            continue;\r\n        }\r\n\r\n        // Base64 decode data if necessary. NOTE: uncompressed base64 only.\r\n        if (curl.compression)\r\n        {\r\n            console.warn(\r\n                'TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer \\''\r\n                + curl.name + '\\''\r\n            );\r\n            continue;\r\n        }\r\n        else if (curl.encoding && curl.encoding === 'base64')\r\n        {\r\n            // Chunks for an infinite map\r\n            if (curl.chunks)\r\n            {\r\n                for (var i = 0; i < curl.chunks.length; i++)\r\n                {\r\n                    curl.chunks[i].data = Base64Decode(curl.chunks[i].data);\r\n                }\r\n            }\r\n\r\n            // Non-infinite map data\r\n            if (curl.data)\r\n            {\r\n                curl.data = Base64Decode(curl.data);\r\n            }\r\n\r\n            delete curl.encoding; // Allow the same map to be parsed multiple times\r\n        }\r\n\r\n        //  This is an array containing the tile indexes, one after the other. -1 = no tile,\r\n        //  everything else = the tile index (starting at 1 for Tiled, 0 for CSV) If the map\r\n        //  contains multiple tilesets then the indexes are relative to that which the set starts\r\n        //  from. Need to set which tileset in the cache = which tileset in the JSON, if you do this\r\n        //  manually it means you can use the same map data but a new tileset.\r\n\r\n        var layerData;\r\n        var gidInfo;\r\n        var tile;\r\n        var blankTile;\r\n\r\n        var output = [];\r\n        var x = 0;\r\n\r\n        if (infiniteMap)\r\n        {\r\n            var layerOffsetX = (GetFastValue(curl, 'startx', 0) + curl.x);\r\n            var layerOffsetY = (GetFastValue(curl, 'starty', 0) + curl.y);\r\n\r\n            layerData = new LayerData({\r\n                name: (curGroupState.name + curl.name),\r\n                x: (curGroupState.x + GetFastValue(curl, 'offsetx', 0) + layerOffsetX * json.tilewidth),\r\n                y: (curGroupState.y + GetFastValue(curl, 'offsety', 0) + layerOffsetY * json.tileheight),\r\n                width: curl.width,\r\n                height: curl.height,\r\n                tileWidth: json.tilewidth,\r\n                tileHeight: json.tileheight,\r\n                alpha: (curGroupState.opacity * curl.opacity),\r\n                visible: (curGroupState.visible && curl.visible),\r\n                properties: GetFastValue(curl, 'properties', []),\r\n                orientation: FromOrientationString(json.orientation)\r\n            });\r\n\r\n            if (layerData.orientation === CONST.HEXAGONAL)\r\n            {\r\n                layerData.hexSideLength = json.hexsidelength;\r\n            }\r\n\r\n            for (var c = 0; c < curl.height; c++)\r\n            {\r\n                output[c] = [ null ];\r\n\r\n                for (var j = 0; j < curl.width; j++)\r\n                {\r\n                    output[c][j] = null;\r\n                }\r\n            }\r\n\r\n            for (c = 0, len = curl.chunks.length; c < len; c++)\r\n            {\r\n                var chunk = curl.chunks[c];\r\n\r\n                var offsetX = (chunk.x - layerOffsetX);\r\n                var offsetY = (chunk.y - layerOffsetY);\r\n\r\n                var y = 0;\r\n\r\n                for (var t = 0, len2 = chunk.data.length; t < len2; t++)\r\n                {\r\n                    var newOffsetX = x + offsetX;\r\n                    var newOffsetY = y + offsetY;\r\n\r\n                    gidInfo = ParseGID(chunk.data[t]);\r\n\r\n                    //  index, x, y, width, height\r\n                    if (gidInfo.gid > 0)\r\n                    {\r\n                        tile = new Tile(layerData, gidInfo.gid, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);\r\n\r\n                        // Turning Tiled's FlippedHorizontal, FlippedVertical and FlippedAntiDiagonal\r\n                        // propeties into flipX, flipY and rotation\r\n                        tile.rotation = gidInfo.rotation;\r\n                        tile.flipX = gidInfo.flipped;\r\n\r\n                        output[newOffsetY][newOffsetX] = tile;\r\n                    }\r\n                    else\r\n                    {\r\n                        blankTile = insertNull\r\n                            ? null\r\n                            : new Tile(layerData, -1, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);\r\n\r\n                        output[newOffsetY][newOffsetX] = blankTile;\r\n                    }\r\n\r\n                    x++;\r\n\r\n                    if (x === chunk.width)\r\n                    {\r\n                        y++;\r\n                        x = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            layerData = new LayerData({\r\n                name: (curGroupState.name + curl.name),\r\n                x: (curGroupState.x + GetFastValue(curl, 'offsetx', 0) + curl.x),\r\n                y: (curGroupState.y + GetFastValue(curl, 'offsety', 0) + curl.y),\r\n                width: curl.width,\r\n                height: curl.height,\r\n                tileWidth: json.tilewidth,\r\n                tileHeight: json.tileheight,\r\n                alpha: (curGroupState.opacity * curl.opacity),\r\n                visible: (curGroupState.visible && curl.visible),\r\n                properties: GetFastValue(curl, 'properties', []),\r\n                orientation: FromOrientationString(json.orientation)\r\n            });\r\n\r\n            if (layerData.orientation === CONST.HEXAGONAL)\r\n            {\r\n                layerData.hexSideLength = json.hexsidelength;\r\n            }\r\n            var row = [];\r\n\r\n            //  Loop through the data field in the JSON.\r\n            for (var k = 0, len = curl.data.length; k < len; k++)\r\n            {\r\n                gidInfo = ParseGID(curl.data[k]);\r\n\r\n                //  index, x, y, width, height\r\n                if (gidInfo.gid > 0)\r\n                {\r\n                    tile = new Tile(layerData, gidInfo.gid, x, output.length, json.tilewidth, json.tileheight);\r\n\r\n                    // Turning Tiled's FlippedHorizontal, FlippedVertical and FlippedAntiDiagonal\r\n                    // propeties into flipX, flipY and rotation\r\n                    tile.rotation = gidInfo.rotation;\r\n                    tile.flipX = gidInfo.flipped;\r\n\r\n                    row.push(tile);\r\n                }\r\n                else\r\n                {\r\n                    blankTile = insertNull\r\n                        ? null\r\n                        : new Tile(layerData, -1, x, output.length, json.tilewidth, json.tileheight);\r\n                    row.push(blankTile);\r\n                }\r\n\r\n                x++;\r\n\r\n                if (x === curl.width)\r\n                {\r\n                    output.push(row);\r\n                    x = 0;\r\n                    row = [];\r\n                }\r\n            }\r\n        }\r\n\r\n        layerData.data = output;\r\n        tileLayers.push(layerData);\r\n    }\r\n\r\n    return tileLayers;\r\n};\r\n\r\nmodule.exports = ParseTileLayers;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tileset = require('../../Tileset');\r\nvar ImageCollection = require('../../ImageCollection');\r\nvar ParseObject = require('./ParseObject');\r\nvar ParseWangsets = require('./ParseWangsets');\r\n\r\n/**\r\n * Tilesets and Image Collections.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseTilesets\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Tiled JSON data.\r\n *\r\n * @return {object} An object containing the tileset and image collection data.\r\n */\r\nvar ParseTilesets = function (json)\r\n{\r\n    var tilesets = [];\r\n    var imageCollections = [];\r\n    var lastSet = null;\r\n    var stringID;\r\n\r\n    for (var i = 0; i < json.tilesets.length; i++)\r\n    {\r\n        //  name, firstgid, width, height, margin, spacing, properties\r\n        var set = json.tilesets[i];\r\n\r\n        if (set.source)\r\n        {\r\n            console.warn('External tilesets unsupported. Use Embed Tileset and re-export');\r\n        }\r\n        else if (set.image)\r\n        {\r\n            var newSet = new Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, undefined, undefined, set.tileoffset);\r\n\r\n            if (json.version > 1)\r\n            {\r\n                var datas = undefined;\r\n                var props = undefined;\r\n\r\n                if (Array.isArray(set.tiles))\r\n                {\r\n                    datas = datas || {};\r\n                    props = props || {};\r\n\r\n                    // Tiled 1.2+\r\n                    for (var t = 0; t < set.tiles.length; t++)\r\n                    {\r\n                        var tile = set.tiles[t];\r\n\r\n                        //  Convert tileproperties.\r\n                        if (tile.properties)\r\n                        {\r\n                            var newPropData = {};\r\n\r\n                            tile.properties.forEach(function (propData)\r\n                            {\r\n                                newPropData[propData['name']] = propData['value'];\r\n                            });\r\n\r\n                            props[tile.id] = newPropData;\r\n                        }\r\n\r\n                        //  Convert objectgroup\r\n                        if (tile.objectgroup)\r\n                        {\r\n                            (datas[tile.id] || (datas[tile.id] = {})).objectgroup = tile.objectgroup;\r\n\r\n                            if (tile.objectgroup.objects)\r\n                            {\r\n                                var parsedObjects2 = tile.objectgroup.objects.map(function (obj)\r\n                                {\r\n                                    return ParseObject(obj);\r\n                                });\r\n\r\n                                datas[tile.id].objectgroup.objects = parsedObjects2;\r\n                            }\r\n                        }\r\n\r\n                        // Copy animation data\r\n                        if (tile.animation)\r\n                        {\r\n                            (datas[tile.id] || (datas[tile.id] = {})).animation = tile.animation;\r\n                        }\r\n\r\n                        // Copy tile `type` field\r\n                        // (see https://doc.mapeditor.org/en/latest/manual/custom-properties/#typed-tiles).\r\n                        if (tile.type)\r\n                        {\r\n                            (datas[tile.id] || (datas[tile.id] = {})).type = tile.type;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (Array.isArray(set.wangsets))\r\n                {\r\n                    datas = datas || {};\r\n                    props = props || {};\r\n\r\n                    ParseWangsets(set.wangsets, datas);\r\n                }\r\n\r\n                if (datas) // Implies also props is set.\r\n                {\r\n                    newSet.tileData = datas;\r\n                    newSet.tileProperties = props;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // Tiled 1\r\n\r\n                // Properties stored per-tile in object with string indexes starting at \"0\"\r\n                if (set.tileproperties)\r\n                {\r\n                    newSet.tileProperties = set.tileproperties;\r\n                }\r\n\r\n                // Object & terrain shapes stored per-tile in object with string indexes starting at \"0\"\r\n                if (set.tiles)\r\n                {\r\n                    newSet.tileData = set.tiles;\r\n\r\n                    // Parse the objects into Phaser format to match handling of other Tiled objects\r\n                    for (stringID in newSet.tileData)\r\n                    {\r\n                        var objectGroup = newSet.tileData[stringID].objectgroup;\r\n\r\n                        if (objectGroup && objectGroup.objects)\r\n                        {\r\n                            var parsedObjects1 = objectGroup.objects.map(function (obj)\r\n                            {\r\n                                return ParseObject(obj);\r\n                            });\r\n\r\n                            newSet.tileData[stringID].objectgroup.objects = parsedObjects1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // For a normal sliced tileset the row/count/size information is computed when updated.\r\n            // This is done (again) after the image is set.\r\n            newSet.updateTileData(set.imagewidth, set.imageheight);\r\n\r\n            tilesets.push(newSet);\r\n        }\r\n        else\r\n        {\r\n            var newCollection = new ImageCollection(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);\r\n\r\n            var maxId = 0;\r\n\r\n            for (t = 0; t < set.tiles.length; t++)\r\n            {\r\n                tile = set.tiles[t];\r\n\r\n                var image = tile.image;\r\n                var tileId = parseInt(tile.id, 10);\r\n                var gid = set.firstgid + tileId;\r\n                newCollection.addImage(gid, image);\r\n\r\n                maxId = Math.max(tileId, maxId);\r\n            }\r\n\r\n            newCollection.maxId = maxId;\r\n\r\n            imageCollections.push(newCollection);\r\n        }\r\n\r\n        //  We've got a new Tileset, so set the lastgid into the previous one\r\n        if (lastSet)\r\n        {\r\n            lastSet.lastgid = set.firstgid - 1;\r\n        }\r\n\r\n        lastSet = set;\r\n    }\r\n\r\n    return { tilesets: tilesets, imageCollections: imageCollections };\r\n};\r\n\r\nmodule.exports = ParseTilesets;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Parses out the Wangset information from Tiled 1.1.5+ map data, if present.\r\n *\r\n * Since a given tile can be in more than one wangset, the resulting properties\r\n * are nested. `tile.data.wangid[someWangsetName]` will return the array-based wang id in\r\n * this implementation.\r\n *\r\n * Note that we're not guaranteed that there will be any 'normal' tiles if the only\r\n * thing in the tilset are wangtile definitions, so this has to be parsed separately.\r\n *\r\n * See https://doc.mapeditor.org/en/latest/manual/using-wang-tiles/ for more information.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseWangsets\r\n * @since 3.53.0\r\n *\r\n * @param {Array.<object>} wangsets - The array of wangset objects (parsed from JSON)\r\n * @param {object} datas - The field into which to put wangset data from Tiled.\r\n *\r\n * @return {object} An object containing the tileset and image collection data.\r\n */\r\nvar ParseWangsets = function (wangsets, datas)\r\n{\r\n    for (var w = 0; w < wangsets.length; w++)\r\n    {\r\n        var wangset = wangsets[w];\r\n        var identifier = w;\r\n\r\n        if (wangset.name && wangset.name !== '')\r\n        {\r\n            identifier = wangset.name;\r\n        }\r\n\r\n        if (Array.isArray(wangset.wangtiles) && wangset.wangtiles.length > 0)\r\n        {\r\n            var edgeColors = {};\r\n            var cornerColors = {};\r\n\r\n            var c;\r\n            var color;\r\n            var colorIndex;\r\n\r\n            // Tiled before v2020.09.09\r\n            if (Array.isArray(wangset.edgecolors))\r\n            {\r\n                for (c = 0; c < wangset.edgecolors.length; c++)\r\n                {\r\n                    colorIndex = 1 + c;\r\n                    color = wangset.edgecolors[c];\r\n\r\n                    if (color.name !== '')\r\n                    {\r\n                        edgeColors[colorIndex] = color.name;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (Array.isArray(wangset.cornercolors))\r\n            {\r\n                for (c = 0; c < wangset.cornercolors.length; c++)\r\n                {\r\n                    colorIndex = 1 + c;\r\n                    color = wangset.cornercolors[c];\r\n\r\n                    if (color.name !== '')\r\n                    {\r\n                        cornerColors[colorIndex] = color.name;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Tiled after v2020.09.09\r\n            if (Array.isArray(wangset.colors))\r\n            {\r\n                for (c = 0; c < wangset.colors.length; c++)\r\n                {\r\n                    color = wangset.colors[c];\r\n                    colorIndex = 1 + c;\r\n\r\n                    if (color.name !== '')\r\n                    {\r\n                        edgeColors[colorIndex] = cornerColors[colorIndex] = color.name;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // The wangid layout is north, northeast, east, southeast, etc.\r\n            var idLayout = [\r\n                edgeColors, cornerColors, edgeColors, cornerColors,\r\n                edgeColors, cornerColors, edgeColors, cornerColors\r\n            ];\r\n\r\n            for (var t = 0; t < wangset.wangtiles.length; t++)\r\n            {\r\n                var wangtile = wangset.wangtiles[t];\r\n\r\n                var obj = (datas[wangtile.tileid] || (datas[wangtile.tileid] = {}));\r\n\r\n                obj = (obj.wangid || (obj.wangid = {}));\r\n\r\n                var wangid = [];\r\n\r\n                for (var i = 0; i < Math.min(idLayout.length, wangtile.wangid.length); i++)\r\n                {\r\n                    color = wangtile.wangid[i];\r\n\r\n                    if (color === 0)\r\n                    {\r\n                        wangid.push(undefined);\r\n                        continue;\r\n                    }\r\n\r\n                    var renamed = idLayout[i][color];\r\n\r\n                    if (renamed !== undefined)\r\n                    {\r\n                        wangid.push(renamed);\r\n                        continue;\r\n                    }\r\n\r\n                    wangid.push(color);\r\n                }\r\n\r\n                obj[identifier] = wangid;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = ParseWangsets;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Parsers.Tiled\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    AssignTileProperties: require('./AssignTileProperties'),\r\n    Base64Decode: require('./Base64Decode'),\r\n    BuildTilesetIndex: require('./BuildTilesetIndex'),\r\n    CreateGroupLayer: require('./CreateGroupLayer'),\r\n    ParseGID: require('./ParseGID'),\r\n    ParseImageLayers: require('./ParseImageLayers'),\r\n    ParseJSONTiled: require('./ParseJSONTiled'),\r\n    ParseObject: require('./ParseObject'),\r\n    ParseObjectLayers: require('./ParseObjectLayers'),\r\n    ParseTileLayers: require('./ParseTileLayers'),\r\n    ParseTilesets: require('./ParseTilesets')\r\n\r\n};\r\n"],"names":["module","exports","CSV","TILED_JSON","ARRAY_2D","WELTMEISTER","ImageCollection","initialize","name","firstgid","width","height","margin","spacing","properties","undefined","this","imageWidth","imageHeight","imageMargin","imageSpacing","images","total","containsImageIndex","imageIndex","addImage","gid","image","push","ObjectHelper","tilesets","gids","t","length","tileset","i","_gids","enabled","get","set","v","getTypeIncludingTile","obj","type","tileData","getTileData","setTextureAndFrame","sprite","key","frame","scene","textures","getFrame","setTexture","setPropertiesFromTiledObject","setFromJSON","getTileProperties","Array","isArray","forEach","propData","setData","value","Formats","MapData","Parse","Tilemap","tileWidth","tileHeight","data","insertNull","mapData","tilemapData","cache","tilemap","format","console","warn","CONST","Class","Components","Rectangle","Tile","Mixins","Alpha","Flip","Visible","layer","index","x","y","baseWidth","baseHeight","right","bottom","pixelX","pixelY","updatePixelXY","rotation","collideLeft","collideRight","collideUp","collideDown","faceLeft","faceRight","faceTop","faceBottom","collisionCallback","collisionCallbackContext","tint","physics","containsPoint","copy","tile","alpha","visible","setFlip","flipX","flipY","getCollisionGroup","getTileCollisionGroup","getLeft","camera","tilemapLayer","tileToWorldXY","getRight","scaleX","getTop","tileToWorldY","scaleY","getBottom","getBounds","output","getCenterX","getCenterY","intersects","isInteresting","collides","faces","canCollide","hasInterestingFace","resetCollision","recalculateFaces","calculateFacesAt","resetFaces","setCollision","left","up","down","setCollisionCallback","callback","context","setSize","orientation","ORTHOGONAL","ISOMETRIC","STAGGERED","HEXAGONAL","len","hexSideLength","rowHeight","destroy","gidMap","DegToRad","GetFastValue","LayerData","ORIENTATION","Rotate","SpliceOne","Sprite","TilemapComponents","TilemapLayer","Tileset","renderOrder","version","widthInPixels","heightInPixels","imageCollections","layers","objects","currentLayerIndex","_convert","WorldToTileXY","GetWorldToTileXYFunction","WorldToTileX","GetWorldToTileXFunction","WorldToTileY","GetWorldToTileYFunction","TileToWorldXY","GetTileToWorldXYFunction","TileToWorldX","GetTileToWorldXFunction","TileToWorldY","GetTileToWorldYFunction","createBlankDynamicLayer","createBlankLayer","createDynamicLayer","layerID","createLayer","createStaticLayer","setRenderOrder","orders","indexOf","addTilesetImage","tilesetName","tileMargin","tileSpacing","sys","exists","texture","getTilesetIndex","setTileSize","setSpacing","setImage","srcTileX","srcTileY","destTileX","destTileY","getLayer","Copy","getLayerIndex","row","layerData","tileY","tileX","displayList","add","getTileLayerNames","join","createFromObjects","objectLayerName","config","useTileset","results","objectLayer","getObjectLayer","objectHelper","c","singleConfig","id","toConvert","s","classType","container","setName","setPosition","displayWidth","displayHeight","isometricRatio","isometricPosition","offset","originX","originY","angle","flippedHorizontal","flippedVertical","existing","createFromTiles","indexes","replacements","spriteConfig","CreateFromTiles","fill","Fill","filterObjects","filter","filterTiles","filteringOptions","FilterTiles","findByIndex","findIndex","skip","reverse","FindByIndex","findObject","find","findTile","FindTile","forEachTile","ForEachTile","getImageIndex","getIndex","getImageLayerNames","map","location","getObjectLayerNames","object","getLayerIndexByName","layerIndex","getTileAt","nonNull","GetTileAt","getTileAtWorldXY","worldX","worldY","GetTileAtWorldXY","getTilesWithin","GetTilesWithin","getTilesWithinShape","shape","GetTilesWithinShape","getTilesWithinWorldXY","GetTilesWithinWorldXY","getTileset","hasTileAt","HasTileAt","hasTileAtWorldXY","HasTileAtWorldXY","setLayer","putTileAt","PutTileAt","putTileAtWorldXY","PutTileAtWorldXY","putTilesAt","tilesArray","PutTilesAt","randomize","Randomize","CalculateFacesAt","calculateFacesWithin","CalculateFacesWithin","removeLayer","destroyLayer","removeAllLayers","removeTile","tiles","replaceIndex","removed","removeTileAt","replaceWithNull","RemoveTileAt","removeTileAtWorldXY","RemoveTileAtWorldXY","renderDebug","graphics","styleConfig","RenderDebug","renderDebugFull","replaceByIndex","newIndex","ReplaceByIndex","updateLayer","SetCollision","setCollisionBetween","start","stop","SetCollisionBetween","setCollisionByProperty","SetCollisionByProperty","setCollisionByExclusion","SetCollisionByExclusion","setCollisionFromCollisionGroup","SetCollisionFromCollisionGroup","setTileIndexCallback","callbackContext","SetTileIndexCallback","setTileLocationCallback","SetTileLocationCallback","setBaseTileSize","baseTileWidth","baseTileHeight","mapWidth","mapHeight","col","setLayerTileSize","shuffle","Shuffle","swapByIndex","indexA","indexB","SwapByIndex","tileToWorldX","vec2","weightedRandomize","weightedIndexes","WeightedRandomize","worldToTileX","snapToFloor","worldToTileY","worldToTileXY","GameObjectCreator","ParseToTilemap","register","GameObjectFactory","GameObject","TilemapLayerRender","Extends","BlendMode","ComputedSize","Depth","GetBounds","Origin","Pipeline","Transform","ScrollFactor","call","isTilemap","tilesDrawn","tilesTotal","culledTiles","skipCull","cullPaddingX","cullPaddingY","cullCallback","GetCullTilesFunction","_renderOrder","setTilesets","setAlpha","setOrigin","initPipeline","setList","cull","setSkipCull","setCullPadding","paddingX","paddingY","point","removeFromTilemap","prototype","TransformMatrix","tempMatrix1","tempMatrix2","tempMatrix3","renderer","src","parentMatrix","renderTiles","tileCount","camMatrix","layerMatrix","calcMatrix","applyITRS","copyFrom","matrix","ctx","currentContext","save","multiplyWithOffset","scrollX","scrollFactorX","scrollY","scrollFactorY","e","f","multiply","copyToContext","antialias","imageSmoothingEnabled","getSourceImage","tileTexCoords","getTileTextureCoordinates","halfWidth","halfHeight","tileOffset","translate","rotate","scale","globalAlpha","drawImage","restore","renderWebGL","renderCanvas","Utils","pipeline","pipelines","getTint","getTintAppendFloatAlpha","sx","sy","preBatch","glTexture","textureUnit","setTexture2D","frameWidth","frameHeight","frameX","frameY","tw","th","tOffsetX","tOffsetY","batchTexture","postBatch","Vector2","tileProperties","rows","columns","texCoordinates","tileIndex","containsTileIndex","objectgroup","source","updateTileData","rowCount","colCount","Math","floor","tx","ty","above","below","tileCollides","pos","worldView","srcTiles","offsetX","offsetY","cameras","main","sprites","make","SnapCeil","SnapFloor","bounds","tileW","tileH","boundsLeft","boundsRight","boundsTop","boundsBottom","setTo","CullBounds","RunCull","outputArray","top","SetTileCollision","doesIndexCollide","collideIndexes","count","CullTiles","HexagonalCullTiles","IsometricCullTiles","NOOP","StaggeredCullTiles","IsInLayerBounds","HexagonalTileToWorldXY","IsometricTileToWorldXY","StaggeredTileToWorldXY","HexagonalTileToWorldY","StaggeredTileToWorldY","isNotEmpty","isColliding","max","Geom","Intersects","TriangleToRectangle","triangle","rect","RectangleToTriangle","pointStart","pointEnd","intersectTest","Circle","CircleToRectangle","RectangleToRectangle","Triangle","Line","LineToRectangle","xStart","yStart","xEnd","ceil","yEnd","tileRect","HexagonalWorldToTileXY","IsometricWorldToTileXY","StaggeredWorldToTileXY","HexagonalWorldToTileY","StaggeredWorldToTileY","rowH","layerWorldX","layerWorldY","CheckIsoBounds","drawRight","drawBottom","BuildTilesetIndex","oldTile","oldTileCollides","newTile","sid","GetRandom","Color","defaultTileColor","defaultCollidingTileColor","defaultFaceColor","tileColor","collidingTileColor","faceColor","translateCanvas","scaleCanvas","color","fillStyle","fillRect","lineStyle","lineBetween","drawLeft","min","drawTop","SetLayerCollisionIndex","HasValue","property","values","collisionGroup","loc","splice","callbacks","ShuffleArray","weightTotal","weight","rand","random","sum","randomIndex","j","chosen","HexagonalCullBounds","StaggeredCullBounds","Extend","Tilemaps","Parsers","TilemapCreator","TilemapFactory","Orientation","ObjectLayer","bodies","infinite","collision","opacity","propertyTypes","toLowerCase","Parse2DArray","ParseCSV","ParseJSONTiled","ParseWeltmeister","mapFormat","newMap","parseInt","isNaN","array2D","trim","split","json","tileLayers","tilesize","tileGrid","tilesetsNames","ParseTileLayers","ParseTilesets","FromOrientationString","Impact","Tiled","k","binaryString","window","atob","bytes","charCodeAt","collection","countX","countY","groupl","parentstate","layerX","tilewidth","layerY","tileheight","Boolean","flippedAntiDiagonal","flipped","PI","CreateGroupLayer","groupStack","curGroupState","pop","curi","layerOffsetX","layerOffsetY","nextGroupState","AssignTileProperties","ParseImageLayers","ParseObjectLayers","renderorder","hexsidelength","sets","Pick","ParseGID","copyPoints","p","commonObjectProps","tiledObject","parsedObject","gidInfo","polyline","polygon","ellipse","text","rectangle","ParseObject","objectLayers","curo","Base64Decode","infiniteMap","curl","compression","encoding","chunks","blankTile","chunk","len2","newOffsetX","newOffsetY","ParseWangsets","stringID","lastSet","newSet","tileoffset","datas","props","newPropData","parsedObjects2","animation","wangsets","tileproperties","objectGroup","parsedObjects1","imagewidth","imageheight","newCollection","maxId","tileId","lastgid","w","wangset","identifier","wangtiles","colorIndex","edgeColors","cornerColors","edgecolors","cornercolors","colors","idLayout","wangtile","tileid","wangid","renamed"],"sourceRoot":""}